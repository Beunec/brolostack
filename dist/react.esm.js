import t,{createContext as e,useState as s,useEffect as r,useContext as i}from"react";import a from"localforage";import{nanoid as o}from"nanoid";var n,c={exports:{}},h={};var l,m={};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */"production"===process.env.NODE_ENV?c.exports=function(){if(n)return h;n=1;var t=Symbol.for("react.transitional.element"),e=Symbol.for("react.fragment");function s(e,s,r){var i=null;if(void 0!==r&&(i=""+r),void 0!==s.key&&(i=""+s.key),"key"in s)for(var a in r={},s)"key"!==a&&(r[a]=s[a]);else r=s;return s=r.ref,{$$typeof:t,type:e,key:i,ref:void 0!==s?s:null,props:r}}return h.Fragment=e,h.jsx=s,h.jsxs=s,h}():c.exports=(l||(l=1,"production"!==process.env.NODE_ENV&&function(){function e(t){if(null==t)return null;if("function"==typeof t)return t.$$typeof===I?null:t.displayName||t.name||null;if("string"==typeof t)return t;switch(t){case p:return"Fragment";case d:return"Profiler";case y:return"StrictMode";case S:return"Suspense";case b:return"SuspenseList";case E:return"Activity"}if("object"==typeof t)switch("number"==typeof t.tag&&console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."),t.$$typeof){case u:return"Portal";case w:return(t.displayName||"Context")+".Provider";case f:return(t._context.displayName||"Context")+".Consumer";case v:var s=t.render;return(t=t.displayName)||(t=""!==(t=s.displayName||s.name||"")?"ForwardRef("+t+")":"ForwardRef"),t;case k:return null!==(s=t.displayName||null)?s:e(t.type)||"Memo";case _:s=t._payload,t=t._init;try{return e(t(s))}catch(t){}}return null}function s(t){return""+t}function r(t){try{s(t);var e=!1}catch(t){e=!0}if(e){var r=(e=console).error,i="function"==typeof Symbol&&Symbol.toStringTag&&t[Symbol.toStringTag]||t.constructor.name||"Object";return r.call(e,"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",i),s(t)}}function i(t){if(t===p)return"<>";if("object"==typeof t&&null!==t&&t.$$typeof===_)return"<...>";try{var s=e(t);return s?"<"+s+">":"<...>"}catch(t){return"<...>"}}function a(){return Error("react-stack-top-frame")}function o(){var t=e(this.type);return $[t]||($[t]=!0,console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.")),void 0!==(t=this.props.ref)?t:null}function n(t,s,i,a,n,l,m,u){var p,y=s.children;if(void 0!==y)if(a)if(A(y)){for(a=0;a<y.length;a++)c(y[a]);Object.freeze&&Object.freeze(y)}else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");else c(y);if(z.call(s,"key")){y=e(t);var d=Object.keys(s).filter(function(t){return"key"!==t});a=0<d.length?"{key: someKey, "+d.join(": ..., ")+": ...}":"{key: someKey}",D[y+a]||(d=0<d.length?"{"+d.join(": ..., ")+": ...}":"{}",console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',a,y,d,y),D[y+a]=!0)}if(y=null,void 0!==i&&(r(i),y=""+i),function(t){if(z.call(t,"key")){var e=Object.getOwnPropertyDescriptor(t,"key").get;if(e&&e.isReactWarning)return!1}return void 0!==t.key}(s)&&(r(s.key),y=""+s.key),"key"in s)for(var f in i={},s)"key"!==f&&(i[f]=s[f]);else i=s;return y&&function(t,e){function s(){h||(h=!0,console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",e))}s.isReactWarning=!0,Object.defineProperty(t,"key",{get:s,configurable:!0})}(i,"function"==typeof t?t.displayName||t.name||"Unknown":t),function(t,e,s,r,i,a,n,c){return s=a.ref,t={$$typeof:g,type:t,key:e,props:a,_owner:i},null!==(void 0!==s?s:null)?Object.defineProperty(t,"ref",{enumerable:!1,get:o}):Object.defineProperty(t,"ref",{enumerable:!1,value:null}),t._store={},Object.defineProperty(t._store,"validated",{configurable:!1,enumerable:!1,writable:!0,value:0}),Object.defineProperty(t,"_debugInfo",{configurable:!1,enumerable:!1,writable:!0,value:null}),Object.defineProperty(t,"_debugStack",{configurable:!1,enumerable:!1,writable:!0,value:n}),Object.defineProperty(t,"_debugTask",{configurable:!1,enumerable:!1,writable:!0,value:c}),Object.freeze&&(Object.freeze(t.props),Object.freeze(t)),t}(t,y,l,0,null===(p=x.A)?null:p.getOwner(),i,m,u)}function c(t){"object"==typeof t&&null!==t&&t.$$typeof===g&&t._store&&(t._store.validated=1)}var h,l=t,g=Symbol.for("react.transitional.element"),u=Symbol.for("react.portal"),p=Symbol.for("react.fragment"),y=Symbol.for("react.strict_mode"),d=Symbol.for("react.profiler"),f=Symbol.for("react.consumer"),w=Symbol.for("react.context"),v=Symbol.for("react.forward_ref"),S=Symbol.for("react.suspense"),b=Symbol.for("react.suspense_list"),k=Symbol.for("react.memo"),_=Symbol.for("react.lazy"),E=Symbol.for("react.activity"),I=Symbol.for("react.client.reference"),x=l.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,z=Object.prototype.hasOwnProperty,A=Array.isArray,O=console.createTask?console.createTask:function(){return null},$={},T=(l={react_stack_bottom_frame:function(t){return t()}}).react_stack_bottom_frame.bind(l,a)(),N=O(i(a)),D={};m.Fragment=p,m.jsx=function(t,e,s,r,a){var o=1e4>x.recentlyCreatedOwnerStacks++;return n(t,e,s,!1,0,a,o?Error("react-stack-top-frame"):T,o?O(i(t)):N)},m.jsxs=function(t,e,s,r,a){var o=1e4>x.recentlyCreatedOwnerStacks++;return n(t,e,s,!0,0,a,o?Error("react-stack-top-frame"):T,o?O(i(t)):N)}}()),m);var g,u=c.exports;!function(t){t[t.DEBUG=0]="DEBUG",t[t.INFO=1]="INFO",t[t.WARN=2]="WARN",t[t.ERROR=3]="ERROR"}(g||(g={}));class p{constructor(t=!1,e="Brolostack"){this.level=t?g.DEBUG:g.INFO,this.prefix=e}debug(t,e){this.level<=g.DEBUG&&console.debug(`[${this.prefix}] ${t}`,e||"")}info(t,e){this.level<=g.INFO&&console.info(`[${this.prefix}] ${t}`,e||"")}warn(t,e){this.level<=g.WARN&&console.warn(`[${this.prefix}] ${t}`,e||"")}error(t,e){this.level<=g.ERROR&&console.error(`[${this.prefix}] ${t}`,e||"")}setLevel(t){this.level=t}setPrefix(t){this.prefix=t}}class y{constructor(t){this.isInitialized=!1,this.stats={totalItems:0,totalSize:0,availableSpace:0,usedSpace:0,averageItemSize:0},this.config={storeName:"brolostack",version:1,size:52428800,driver:["localStorageWrapper","indexedDB","webSQLStorage"],...t},this.logger=new p(!1,"LocalStorageAdapter"),this.storage=a.createInstance({name:this.config.name,storeName:this.config.storeName||"brolostack",description:this.config.description||"",version:this.config.version||1,size:this.config.size||52428800,driver:this.config.driver||["localStorageWrapper","indexedDB","webSQLStorage"]})}async initialize(){if(!this.isInitialized)try{await this.storage.setItem("__brolostack_test__","test"),await this.storage.removeItem("__brolostack_test__"),await this.updateStats(),this.isInitialized=!0,this.logger.info("LocalStorageAdapter initialized successfully")}catch(t){throw new Error(`Failed to initialize LocalStorageAdapter: ${t instanceof Error?t.message:"Unknown error"}`)}}async getItem(t){try{const e=await this.storage.getItem(t);return e?e.metadata?.expires&&Date.now()>e.metadata.expires?(await this.removeItem(t),null):e.value:null}catch(e){return this.logger.error(`Failed to get item '${t}'`,e),null}}async setItem(t,e){try{const s={key:t,value:e,timestamp:Date.now(),version:this.config.version||1,metadata:{size:new Blob([e]).size,compressed:!1,encrypted:!1}};await this.storage.setItem(t,s),await this.updateStats()}catch(e){throw this.logger.error(`Failed to set item '${t}'`,e),e}}async removeItem(t){try{await this.storage.removeItem(t),await this.updateStats()}catch(e){throw this.logger.error(`Failed to remove item '${t}'`,e),e}}async clear(){try{await this.storage.clear(),await this.updateStats()}catch(t){throw this.logger.error("Failed to clear storage",t),t}}async keys(){try{return await this.storage.keys()}catch(t){return this.logger.error("Failed to get keys",t),[]}}async length(){try{return await this.storage.length()}catch(t){return this.logger.error("Failed to get length",t),0}}getStats(){return{...this.stats}}getAvailableSpace(){return this.stats.availableSpace}getUsedSpace(){return this.stats.usedSpace}getSize(){return this.stats.totalSize}isAvailable(){return this.isInitialized}async createBackup(){try{const t=await this.keys(),e={};for(const s of t){const t=await this.storage.getItem(s);t&&(e[s]=t)}return{version:this.config.version?.toString()||"1.0.0",timestamp:Date.now(),data:e,metadata:{totalItems:t.length,totalSize:this.stats.totalSize,appName:this.config.name,appVersion:this.config.version?.toString()||"1.0.0"}}}catch(t){throw this.logger.error("Failed to create backup",t),t}}async restoreBackup(t){try{await this.clear();for(const[e,s]of Object.entries(t.data))await this.storage.setItem(e,s);await this.updateStats()}catch(t){throw this.logger.error("Failed to restore backup",t),t}}async getItems(t=0,e=100){try{const s=await this.keys(),r=[];for(let i=t;i<Math.min(t+e,s.length);i++){const t=s[i];if(t){const e=await this.storage.getItem(t);e&&r.push(e)}}return r}catch(t){return this.logger.error("Failed to get items",t),[]}}async searchItems(t){try{const e=(await this.keys()).filter(e=>"string"==typeof t?e.includes(t):t.test(e)),s=[];for(const t of e){const e=await this.storage.getItem(t);e&&s.push(e)}return s}catch(t){return this.logger.error("Failed to search items",t),[]}}async cleanup(){try{const t=await this.keys();let e=0;for(const s of t){const t=await this.storage.getItem(s);t&&t.metadata?.expires&&Date.now()>t.metadata.expires&&(await this.removeItem(s),e++)}return await this.updateStats(),e}catch(t){return this.logger.error("Failed to cleanup expired items",t),0}}async updateStats(){try{const t=await this.keys();let e,s,r=0;for(const i of t){const t=await this.storage.getItem(i);t&&(r+=t.metadata?.size||0,(!e||t.timestamp<e.timestamp)&&(e=t),(!s||t.timestamp>s.timestamp)&&(s=t))}this.stats={totalItems:t.length,totalSize:r,availableSpace:(this.config.size||52428800)-r,usedSpace:r,oldestItem:e,newestItem:s,averageItemSize:t.length>0?r/t.length:0}}catch(t){this.logger.error("Failed to update stats",t)}}}class d{constructor(t){this._storage=t,this.middleware=[],this.router=new f,this.setupDefaultEndpoints()}async get(t){return(await this.request("GET",t,void 0,{})).data}async post(t,e){return(await this.request("POST",t,e,{})).data}async put(t,e){return(await this.request("PUT",t,e,{})).data}async delete(t){return(await this.request("DELETE",t,void 0,{})).data}async patch(t,e){return(await this.request("PATCH",t,e,{})).data}async request(t,e,s,r){const i={method:t,path:e,headers:r?.headers||{},body:s,query:r?.query||{},params:{},timestamp:Date.now()};try{for(const t of this.middleware)if(t.request){const e=await t.request(i);Object.assign(i,e)}let t=await this.router.handle(i);for(const e of this.middleware)e.response&&(t=await e.response(t));return{data:t.data,status:t.status,statusText:t.statusText,headers:t.headers||{},config:i,request:i}}catch(t){let e=t;for(const t of this.middleware)t.error&&(e=await t.error(e));throw e}}registerEndpoint(t){this.router.register(t)}use(t){this.middleware.push(t)}setupDefaultEndpoints(){this.router.register({path:"/storage/:key",method:"GET",handler:async t=>{const e=t.params.key;if(!e)return{data:null,status:400,statusText:"Bad Request"};return{data:await this._storage.getItem(e),status:200,statusText:"OK"}}}),this.router.register({path:"/storage/:key",method:"POST",handler:async t=>{const e=t.params.key;return e?(await this._storage.setItem(e,t.body),{data:{success:!0,key:e},status:201,statusText:"Created"}):{data:null,status:400,statusText:"Bad Request"}}}),this.router.register({path:"/storage/:key",method:"PUT",handler:async t=>{const e=t.params.key;return e?(await this._storage.setItem(e,t.body),{data:{success:!0,key:e},status:200,statusText:"OK"}):{data:null,status:400,statusText:"Bad Request"}}}),this.router.register({path:"/storage/:key",method:"DELETE",handler:async t=>{const e=t.params.key;return e?(await this._storage.removeItem(e),{data:{success:!0,key:e},status:200,statusText:"OK"}):{data:null,status:400,statusText:"Bad Request"}}}),this.router.register({path:"/storage",method:"GET",handler:async t=>{const e=await this._storage.keys(),s={};for(const t of e)s[t]=await this._storage.getItem(t);return{data:s,status:200,statusText:"OK"}}}),this.router.register({path:"/storage/clear",method:"POST",handler:async t=>(await this._storage.clear(),{data:{success:!0},status:200,statusText:"OK"})}),this.router.register({path:"/storage/stats",method:"GET",handler:async t=>({data:{totalItems:await this._storage.length(),keys:await this._storage.keys()},status:200,statusText:"OK"})}),this.router.register({path:"/health",method:"GET",handler:async t=>({data:{status:"healthy",timestamp:Date.now(),storage:{available:!0,totalItems:await this._storage.length()}},status:200,statusText:"OK"})})}}class f{constructor(){this.routes=new Map,this.middleware=[]}register(t){const e=`${t.method}:${t.path}`;this.routes.set(e,t)}unregister(t,e){const s=`${e}:${t}`;this.routes.delete(s)}async handle(t){const e=`${t.method}:${t.path}`,s=this.routes.get(e);if(!s)return{data:{error:"Endpoint not found"},status:404,statusText:"Not Found"};try{for(const e of s.middleware||[])if(e.request){const s=await e.request(t);Object.assign(t,s)}let e=await s.handler(t);for(const t of s.middleware||[])t.response&&(e=await t.response(e));return e}catch(t){return{data:{error:t instanceof Error?t.message:"Internal Server Error"},status:500,statusText:"Internal Server Error"}}}use(t){this.middleware.push(t)}}class w{constructor(t,e){this._storage=t,this.eventEmitter=e,this.agents=new Map,this.multiAgentSystems=new Map,this.isInitialized=!1,this.memory=new S(t)}async initialize(){if(!this.isInitialized)try{"initialize"in this.memory&&"function"==typeof this.memory.initialize&&await this.memory.initialize(),await this.loadAgents(),this.isInitialized=!0,this.eventEmitter.emit("ai:manager:initialized",{timestamp:Date.now()})}catch(t){throw new Error(`Failed to initialize AI Manager: ${t instanceof Error?t.message:"Unknown error"}`)}}createAgent(t){const e=new v(t,this.memory,this.eventEmitter);return this.agents.set(e.id,e),this.saveAgent(e),this.eventEmitter.emit("ai:agent:created",{agentId:e.id,config:t}),e}getAgent(t){return this.agents.get(t)}removeAgent(t){return!!this.agents.get(t)&&(this.agents.delete(t),this._storage.removeItem(`ai_agent_${t}`),this.eventEmitter.emit("ai:agent:removed",{agentId:t}),!0)}getAllAgents(){return Array.from(this.agents.values())}async exportMemory(){return"export"in this.memory&&"function"==typeof this.memory.export&&await this.memory.export()||{}}async importMemory(t){"import"in this.memory&&"function"==typeof this.memory.import&&await this.memory.import(t)}async storeMemory(t,e,s="context",r=.5){const i={value:e,type:s,importance:r,timestamp:Date.now()};await this.memory.store(t,i)}async clearMemory(){this.memory.clear()}getMemoryStats(){return"getStats"in this.memory&&"function"==typeof this.memory.getStats?this.memory.getStats():{totalEntries:0,totalSize:0,averageImportance:0,entriesByType:{}}}async loadAgents(){try{const t=(await this._storage.keys()).filter(t=>t.startsWith("ai_agent_"));for(const e of t){const t=await this._storage.getItem(e);if(t){const e=JSON.parse(t),s=new v(e,this.memory,this.eventEmitter);this.agents.set(s.id,s)}}}catch(t){this.eventEmitter.emit("ai:manager:load-agents-error",{error:t instanceof Error?t.message:"Unknown error",timestamp:Date.now()})}}async saveAgent(t){try{const e={id:t.id,name:t.name,type:t.type,config:t.config,state:t.state};await this._storage.setItem(`ai_agent_${t.id}`,JSON.stringify(e))}catch(e){this.eventEmitter.emit("ai:manager:save-agent-error",{agentId:t.id,error:e instanceof Error?e.message:"Unknown error",timestamp:Date.now()})}}}class v{constructor(t,e,s){this.eventEmitter=s,this.state={isActive:!1,isProcessing:!1,lastActivity:0,totalRequests:0,totalTokens:0,errors:[]},this.id=t.id||o(),this.name=t.name,this.type=t.type,this.config=t,this.memory=e}async execute(t,e){this.state.isProcessing=!0,this.state.lastActivity=Date.now();try{let s;switch(await this.memory.store(`interaction_${Date.now()}`,{prompt:t,context:e,timestamp:Date.now(),agentId:this.id}),this.type){case"llm":s=await this.executeLLM(t,e);break;case"multi-agent":s=await this.executeMultiAgent(t,e);break;case"custom":s=await this.executeCustom(t,e);break;default:throw new Error(`Unknown agent type: ${this.type}`)}return this.state.totalRequests++,this.state.isProcessing=!1,this.eventEmitter.emit("ai:agent:executed",{agentId:this.id,prompt:t,result:s,timestamp:Date.now()}),s}catch(s){throw this.state.isProcessing=!1,this.state.errors.push({id:o(),timestamp:Date.now(),type:"execution",message:s instanceof Error?s.message:"Unknown error",context:{prompt:t,context:e},retryable:!0}),this.eventEmitter.emit("ai:agent:error",{agentId:this.id,error:s,timestamp:Date.now()}),s}}addTool(t){this.config.tools||(this.config.tools=[]),this.config.tools.push(t)}removeTool(t){this.config.tools&&(this.config.tools=this.config.tools.filter(e=>e.function.name!==t))}clearMemory(){this.memory.clear()}getMemoryStats(){return"getStats"in this.memory&&"function"==typeof this.memory.getStats?this.memory.getStats():{totalEntries:0,totalSize:0,averageImportance:0,entriesByType:{}}}async executeLLM(t,e){return{response:`AI Agent "${this.name}" processed: ${t}`,tokens:t.length,timestamp:Date.now()}}async executeMultiAgent(t,e){return{response:`Multi-agent system "${this.name}" processed: ${t}`,agents:[],timestamp:Date.now()}}async executeCustom(t,e){return{response:`Custom agent "${this.name}" processed: ${t}`,timestamp:Date.now()}}}class S{constructor(t){this._storage=t,this.entries=new Map,this.maxSize=1e3,this.strategy="lru"}async initialize(){await this.loadFromStorage()}async store(t,e,s="context",r=.5){const i={id:t,timestamp:Date.now(),type:s,content:e,importance:r,tags:[],metadata:{}};this.entries.set(t,i),this.entries.size>this.maxSize&&await this.cleanup(),await this._storage.setItem(`ai_memory_${t}`,JSON.stringify(i))}async retrieve(t){let e=this.entries.get(t);if(!e){const s=await this._storage.getItem(`ai_memory_${t}`);s&&(e=JSON.parse(s),e&&this.entries.set(t,e))}return e}async search(t,e,s=10){const r=[];for(const i of this.entries.values())if((!e||i.type===e)&&(JSON.stringify(i.content).toLowerCase().includes(t.toLowerCase())&&r.push(i),r.length>=s))break;return r.sort((t,e)=>{const s=t.importance+(Date.now()-t.timestamp)/864e5;return e.importance+(Date.now()-e.timestamp)/864e5-s})}async clear(){this.entries.clear();const t=(await this._storage.keys()).filter(t=>t.startsWith("ai_memory_"));for(const e of t)await this._storage.removeItem(e)}async getAll(){const t={};for(const[e,s]of this.entries)t[e]=s;return t}getStats(){const t=Array.from(this.entries.values()),e=t.reduce((t,e)=>t+JSON.stringify(e).length,0),s=t.length>0?t.reduce((t,e)=>t+e.importance,0)/t.length:0,r={};for(const e of t)r[e.type]=(r[e.type]||0)+1;const i=[...t].sort((t,e)=>t.timestamp-e.timestamp),a=[...t].sort((t,e)=>e.timestamp-t.timestamp);return{totalEntries:t.length,totalSize:e,averageImportance:s,oldestEntry:i[0]||void 0,newestEntry:a[0]||void 0,entriesByType:r}}async cleanup(){const t=Array.from(this.entries.values());let e;switch(this.strategy){case"fifo":case"lru":e=t.sort((t,e)=>t.timestamp-e.timestamp);break;case"importance":e=t.sort((t,e)=>t.importance-e.importance);break;default:e=t}const s=e.slice(0,Math.floor(.1*this.maxSize));for(const t of s)this.entries.delete(t.id),await this._storage.removeItem(`ai_memory_${t.id}`)}async loadFromStorage(){try{const t=(await this._storage.keys()).filter(t=>t.startsWith("ai_memory_"));for(const e of t){const t=await this._storage.getItem(e);if(t){const e=JSON.parse(t);this.entries.set(e.id,e)}}}catch(t){}}async export(){const t={};for(const[e,s]of this.entries)t[e]=s;return t}async import(t){for(const[e,s]of Object.entries(t))this.entries.set(e,s),await this._storage.setItem(`ai_memory_${e}`,JSON.stringify(s))}}class b{constructor(){this.events=new Map}on(t,e){this.events.has(t)||this.events.set(t,new Set),this.events.get(t).add(e)}off(t,e){const s=this.events.get(t);s&&(s.delete(e),0===s.size&&this.events.delete(t))}emit(t,...e){const s=this.events.get(t);s&&s.forEach(t=>{try{t(...e)}catch(t){}})}once(t,e){const s=(...r)=>{e(...r),this.off(t,s)};this.on(t,s)}removeAllListeners(t){t?this.events.delete(t):this.events.clear()}listenerCount(t){return this.events.get(t)?.size||0}eventNames(){return Array.from(this.events.keys())}}class k{constructor(t){this.isInitialized=!1,this.startTime=Date.now(),this.config={storageEngine:"localStorage",encryption:!1,compression:!1,maxStorageSize:100,debug:!1,...t},this.logger=new p(this.config.debug),this.eventEmitter=new b,this.stores=new Map,this.storage=new y({name:this.config.appName,version:parseInt(this.config.version)||1,size:this.config.maxStorageSize||52428800}),this.api=new d(this.storage),this.aiManager=new w(this.storage,this.eventEmitter),this.ai={agents:this.aiManager.agents,createAgent:t=>this.aiManager.createAgent(t),getAgent:t=>this.aiManager.getAgent(t),removeAgent:t=>this.aiManager.removeAgent(t),runAgent:async(t,e)=>{const s=this.aiManager.getAgent(t);if(!s)throw new Error(`Agent ${t} not found`);return await s.execute(e)},getMemory:async()=>await this.aiManager.exportMemory(),storeMemory:async(t,e,s,r)=>await this.aiManager.storeMemory(t,e,s,r),clearMemory:async()=>await this.aiManager.clearMemory(),getMemoryStats:()=>this.aiManager.getMemoryStats()},this.logger.info("Brolostack initialized",{appName:this.config.appName,version:this.config.version})}async initialize(){if(this.isInitialized)this.logger.warn("Brolostack already initialized");else try{"initialize"in this.storage&&"function"==typeof this.storage.initialize&&await this.storage.initialize(),await this.aiManager.initialize(),this.eventEmitter.emit("initialized",{appName:this.config.appName,version:this.config.version}),this.isInitialized=!0,this.logger.info("Brolostack initialization completed")}catch(t){const e={name:"BrolostackInitializationError",message:`Failed to initialize Brolostack: ${t instanceof Error?t.message:"Unknown error"}`,code:"INITIALIZATION_FAILED",context:{config:this.config},timestamp:Date.now()};throw this.logger.error("Brolostack initialization failed",e),e}}createStore(t,e){if(this.stores.has(t))return this.logger.warn(`Store '${t}' already exists, returning existing store`),this.stores.get(t);const s=new _(t,e,this.storage,this.eventEmitter);return this.stores.set(t,s),this.logger.info(`Store '${t}' created`,{initialState:e}),this.eventEmitter.emit("store:created",{name:t,initialState:e}),s}getStore(t){return this.stores.get(t)}removeStore(t){const e=this.stores.get(t);return!!e&&(e.clear(),this.stores.delete(t),this.logger.info(`Store '${t}' removed`),this.eventEmitter.emit("store:removed",{name:t}),!0)}getStoreNames(){return Array.from(this.stores.keys())}clearAllStores(){this.stores.forEach((t,e)=>{t.clear(),this.logger.info(`Store '${e}' cleared`)}),this.eventEmitter.emit("stores:cleared",{count:this.stores.size})}async exportData(){const t={};for(const[e,s]of this.stores)t[e]=s.getState();return t._aiMemory=await this.aiManager.exportMemory(),t._metadata={appName:this.config.appName,version:this.config.version,exportDate:(new Date).toISOString(),storeCount:this.stores.size,aiAgentCount:this.ai.agents.size},this.logger.info("Data exported",{storeCount:this.stores.size,aiAgentCount:this.ai.agents.size}),this.eventEmitter.emit("data:exported",{storeCount:this.stores.size,aiAgentCount:this.ai.agents.size}),t}async importData(t){try{for(const[e,s]of Object.entries(t)){if(e.startsWith("_"))continue;let t=this.stores.get(e);t?t.setState(s):t=this.createStore(e,s)}t._aiMemory&&await this.aiManager.importMemory(t._aiMemory),this.logger.info("Data imported successfully",{storeCount:Object.keys(t).filter(t=>!t.startsWith("_")).length}),this.eventEmitter.emit("data:imported",{storeCount:Object.keys(t).filter(t=>!t.startsWith("_")).length})}catch(t){throw this.logger.error("Data import failed:",t),t}}getStats(){return{stores:this.stores.size,aiAgents:this.ai.agents.size,storageSize:"getSize"in this.storage&&"function"==typeof this.storage.getSize?this.storage.getSize():0,uptime:Date.now()-this.startTime,version:this.config.version}}persist(t){this.stores.forEach((e,s)=>{"persist"in e&&"function"==typeof e.persist&&e.persist(t)}),this.logger.info("All stores persisted"),this.eventEmitter.emit("stores:persisted",{count:this.stores.size})}destroy(){this.logger.info("Destroying Brolostack instance"),this.clearAllStores(),this.ai.clearMemory(),this.eventEmitter.emit("destroyed",{appName:this.config.appName,version:this.config.version}),this.isInitialized=!1,this.logger.info("Brolostack instance destroyed")}getEventEmitter(){return this.eventEmitter}getLogger(){return this.logger}}class _{constructor(t,e,s,r){this.name=t,this.storage=s,this.eventEmitter=r,this.listeners=new Set,this.isPersisted=!1,this.persistConfig=null,this.state=e}getState(){return this.state}setState(t){const e=this.state;this.state={...this.state,...t},this.listeners.forEach(t=>t(this.state)),this.eventEmitter.emit("store:updated",{name:this.name,oldState:e,newState:this.state}),this.isPersisted&&this.saveToStorage()}subscribe(t){return this.listeners.add(t),()=>{this.listeners.delete(t)}}persist(t){this.persistConfig=t,this.isPersisted=!0,this.saveToStorage()}async saveToStorage(){try{await this.storage.setItem(`store:${this.name}`,JSON.stringify({state:this.state,config:this.persistConfig,timestamp:Date.now()}))}catch(t){this.logger.error(`Failed to persist store '${this.name}'`,t)}}async loadFromStorage(){try{const t=await this.storage.getItem(`store:${this.name}`);if(t&&"string"==typeof t){const e=JSON.parse(t);e&&"object"==typeof e&&"state"in e&&(this.state=e.state,this.persistConfig=e.config,this.isPersisted=!0)}}catch(t){this.logger.error(`Failed to load store '${this.name}'`,t)}}clear(){this.state={},this.listeners.clear(),this.isPersisted=!1,this.persistConfig=null,this.storage.removeItem(`store:${this.name}`),this.eventEmitter.emit("store:cleared",{name:this.name})}reset(){this.state={},this.listeners.clear(),this.isPersisted=!1,this.persistConfig=null,this.storage.removeItem(`store:${this.name}`),this.eventEmitter.emit("store:reset",{name:this.name})}}const E=e(null);function I({appName:t,config:e,children:i}){const[a,o]=s(null),[n,c]=s(new Map),[h,l]=s(!1);r(()=>((async()=>{try{const s=new k({appName:t,version:e?.version||"1.0.0",...e});await s.initialize(),o(s),c(s.stores),l(!0)}catch(t){}})(),()=>{a&&a.destroy()}),[t,e]);const m={app:a,stores:n};return h&&a?u.jsx(E.Provider,{value:m,children:i}):u.jsx("div",{children:"Initializing Brolostack..."})}function x(){const t=i(E);if(!t)throw new Error("useBrolostack must be used within a BrolostackProvider");return t}function z(t){const{stores:e}=x(),s=e.get(t);if(!s)throw new Error(`Store '${t}' not found`);return s}function A(t,e){const i=z(t),[a,o]=s(()=>{const t=i.getState();return e?e(t):t});return r(()=>i.subscribe(t=>{const s=e?e(t):t;o(s)}),[i,e]),a}export{I as BrolostackProvider,x as useBrolostack,A as useBrolostackState,z as useBrolostackStore};
//# sourceMappingURL=react.esm.js.map
