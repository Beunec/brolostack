import e,{createContext as t,useState as r,useEffect as i,useContext as s}from"react";import a from"localforage";import{nanoid as n}from"nanoid";var o,c={exports:{}},l={};var h,d={};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */"production"===process.env.NODE_ENV?c.exports=function(){if(o)return l;o=1;var e=Symbol.for("react.transitional.element"),t=Symbol.for("react.fragment");function r(t,r,i){var s=null;if(void 0!==i&&(s=""+i),void 0!==r.key&&(s=""+r.key),"key"in r)for(var a in i={},r)"key"!==a&&(i[a]=r[a]);else i=r;return r=i.ref,{$$typeof:e,type:t,key:s,ref:void 0!==r?r:null,props:i}}return l.Fragment=t,l.jsx=r,l.jsxs=r,l}():c.exports=(h||(h=1,"production"!==process.env.NODE_ENV&&function(){function t(e){if(null==e)return null;if("function"==typeof e)return e.$$typeof===C?null:e.displayName||e.name||null;if("string"==typeof e)return e;switch(e){case m:return"Fragment";case y:return"Profiler";case g:return"StrictMode";case b:return"Suspense";case S:return"SuspenseList";case T:return"Activity"}if("object"==typeof e)switch("number"==typeof e.tag&&console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."),e.$$typeof){case p:return"Portal";case w:return(e.displayName||"Context")+".Provider";case f:return(e._context.displayName||"Context")+".Consumer";case k:var r=e.render;return(e=e.displayName)||(e=""!==(e=r.displayName||r.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case v:return null!==(r=e.displayName||null)?r:t(e.type)||"Memo";case E:r=e._payload,e=e._init;try{return t(e(r))}catch(e){}}return null}function r(e){return""+e}function i(e){try{r(e);var t=!1}catch(e){t=!0}if(t){var i=(t=console).error,s="function"==typeof Symbol&&Symbol.toStringTag&&e[Symbol.toStringTag]||e.constructor.name||"Object";return i.call(t,"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",s),r(e)}}function s(e){if(e===m)return"<>";if("object"==typeof e&&null!==e&&e.$$typeof===E)return"<...>";try{var r=t(e);return r?"<"+r+">":"<...>"}catch(e){return"<...>"}}function a(){return Error("react-stack-top-frame")}function n(){var e=t(this.type);return _[e]||(_[e]=!0,console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.")),void 0!==(e=this.props.ref)?e:null}function o(e,r,s,a,o,h,d,p){var m,g=r.children;if(void 0!==g)if(a)if(I(g)){for(a=0;a<g.length;a++)c(g[a]);Object.freeze&&Object.freeze(g)}else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");else c(g);if(D.call(r,"key")){g=t(e);var y=Object.keys(r).filter(function(e){return"key"!==e});a=0<y.length?"{key: someKey, "+y.join(": ..., ")+": ...}":"{key: someKey}",$[g+a]||(y=0<y.length?"{"+y.join(": ..., ")+": ...}":"{}",console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',a,g,y,g),$[g+a]=!0)}if(g=null,void 0!==s&&(i(s),g=""+s),function(e){if(D.call(e,"key")){var t=Object.getOwnPropertyDescriptor(e,"key").get;if(t&&t.isReactWarning)return!1}return void 0!==e.key}(r)&&(i(r.key),g=""+r.key),"key"in r)for(var f in s={},r)"key"!==f&&(s[f]=r[f]);else s=r;return g&&function(e,t){function r(){l||(l=!0,console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",t))}r.isReactWarning=!0,Object.defineProperty(e,"key",{get:r,configurable:!0})}(s,"function"==typeof e?e.displayName||e.name||"Unknown":e),function(e,t,r,i,s,a,o,c){return r=a.ref,e={$$typeof:u,type:e,key:t,props:a,_owner:s},null!==(void 0!==r?r:null)?Object.defineProperty(e,"ref",{enumerable:!1,get:n}):Object.defineProperty(e,"ref",{enumerable:!1,value:null}),e._store={},Object.defineProperty(e._store,"validated",{configurable:!1,enumerable:!1,writable:!0,value:0}),Object.defineProperty(e,"_debugInfo",{configurable:!1,enumerable:!1,writable:!0,value:null}),Object.defineProperty(e,"_debugStack",{configurable:!1,enumerable:!1,writable:!0,value:o}),Object.defineProperty(e,"_debugTask",{configurable:!1,enumerable:!1,writable:!0,value:c}),Object.freeze&&(Object.freeze(e.props),Object.freeze(e)),e}(e,g,h,0,null===(m=A.A)?null:m.getOwner(),s,d,p)}function c(e){"object"==typeof e&&null!==e&&e.$$typeof===u&&e._store&&(e._store.validated=1)}var l,h=e,u=Symbol.for("react.transitional.element"),p=Symbol.for("react.portal"),m=Symbol.for("react.fragment"),g=Symbol.for("react.strict_mode"),y=Symbol.for("react.profiler"),f=Symbol.for("react.consumer"),w=Symbol.for("react.context"),k=Symbol.for("react.forward_ref"),b=Symbol.for("react.suspense"),S=Symbol.for("react.suspense_list"),v=Symbol.for("react.memo"),E=Symbol.for("react.lazy"),T=Symbol.for("react.activity"),C=Symbol.for("react.client.reference"),A=h.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,D=Object.prototype.hasOwnProperty,I=Array.isArray,x=console.createTask?console.createTask:function(){return null},_={},O=(h={react_stack_bottom_frame:function(e){return e()}}).react_stack_bottom_frame.bind(h,a)(),R=x(s(a)),$={};d.Fragment=m,d.jsx=function(e,t,r,i,a){var n=1e4>A.recentlyCreatedOwnerStacks++;return o(e,t,r,!1,0,a,n?Error("react-stack-top-frame"):O,n?x(s(e)):R)},d.jsxs=function(e,t,r,i,a){var n=1e4>A.recentlyCreatedOwnerStacks++;return o(e,t,r,!0,0,a,n?Error("react-stack-top-frame"):O,n?x(s(e)):R)}}()),d);var u,p=c.exports;!function(e){e[e.DEBUG=0]="DEBUG",e[e.INFO=1]="INFO",e[e.WARN=2]="WARN",e[e.ERROR=3]="ERROR"}(u||(u={}));class m{constructor(e=!1,t="Brolostack"){this.level=e?u.DEBUG:u.INFO,this.prefix=t}debug(e,t){this.level<=u.DEBUG&&console.debug(`[${this.prefix}] ${e}`,t||"")}info(e,t){this.level<=u.INFO&&console.info(`[${this.prefix}] ${e}`,t||"")}warn(e,t){this.level<=u.WARN&&console.warn(`[${this.prefix}] ${e}`,t||"")}error(e,t){this.level<=u.ERROR&&console.error(`[${this.prefix}] ${e}`,t||"")}setLevel(e){this.level=e}setPrefix(e){this.prefix=e}}class g{constructor(e){this.isInitialized=!1,this.stats={totalItems:0,totalSize:0,availableSpace:0,usedSpace:0,averageItemSize:0},this.config={storeName:"brolostack",version:1,size:52428800,driver:["localStorageWrapper","indexedDB","webSQLStorage"],...e},this.logger=new m(!1,"LocalStorageAdapter"),this.storage=a.createInstance({name:this.config.name,storeName:this.config.storeName||"brolostack",description:this.config.description||"",version:this.config.version||1,size:this.config.size||52428800,driver:this.config.driver||["localStorageWrapper","indexedDB","webSQLStorage"]})}async initialize(){if(!this.isInitialized)try{await this.storage.setItem("__brolostack_test__","test"),await this.storage.removeItem("__brolostack_test__"),await this.updateStats(),this.isInitialized=!0,this.logger.info("LocalStorageAdapter initialized successfully")}catch(e){throw new Error(`Failed to initialize LocalStorageAdapter: ${e instanceof Error?e.message:"Unknown error"}`)}}async getItem(e){try{const t=await this.storage.getItem(e);return t?t.metadata?.expires&&Date.now()>t.metadata.expires?(await this.removeItem(e),null):t.value:null}catch(t){return this.logger.error(`Failed to get item '${e}'`,t),null}}async setItem(e,t){try{const r={key:e,value:t,timestamp:Date.now(),version:this.config.version||1,metadata:{size:new Blob([t]).size,compressed:!1,encrypted:!1}};await this.storage.setItem(e,r),await this.updateStats()}catch(t){throw this.logger.error(`Failed to set item '${e}'`,t),t}}async removeItem(e){try{await this.storage.removeItem(e),await this.updateStats()}catch(t){throw this.logger.error(`Failed to remove item '${e}'`,t),t}}async clear(){try{await this.storage.clear(),await this.updateStats()}catch(e){throw this.logger.error("Failed to clear storage",e),e}}async keys(){try{return await this.storage.keys()}catch(e){return this.logger.error("Failed to get keys",e),[]}}async length(){try{return await this.storage.length()}catch(e){return this.logger.error("Failed to get length",e),0}}getStats(){return{...this.stats}}getAvailableSpace(){return this.stats.availableSpace}getUsedSpace(){return this.stats.usedSpace}getSize(){return this.stats.totalSize}isAvailable(){return this.isInitialized}async createBackup(){try{const e=await this.keys(),t={};for(const r of e){const e=await this.storage.getItem(r);e&&(t[r]=e)}return{version:this.config.version?.toString()||"1.0.0",timestamp:Date.now(),data:t,metadata:{totalItems:e.length,totalSize:this.stats.totalSize,appName:this.config.name,appVersion:this.config.version?.toString()||"1.0.0"}}}catch(e){throw this.logger.error("Failed to create backup",e),e}}async restoreBackup(e){try{await this.clear();for(const[t,r]of Object.entries(e.data))await this.storage.setItem(t,r);await this.updateStats()}catch(e){throw this.logger.error("Failed to restore backup",e),e}}async getItems(e=0,t=100){try{const r=await this.keys(),i=[];for(let s=e;s<Math.min(e+t,r.length);s++){const e=r[s];if(e){const t=await this.storage.getItem(e);t&&i.push(t)}}return i}catch(e){return this.logger.error("Failed to get items",e),[]}}async searchItems(e){try{const t=(await this.keys()).filter(t=>"string"==typeof e?t.includes(e):e.test(t)),r=[];for(const e of t){const t=await this.storage.getItem(e);t&&r.push(t)}return r}catch(e){return this.logger.error("Failed to search items",e),[]}}async cleanup(){try{const e=await this.keys();let t=0;for(const r of e){const e=await this.storage.getItem(r);e&&e.metadata?.expires&&Date.now()>e.metadata.expires&&(await this.removeItem(r),t++)}return await this.updateStats(),t}catch(e){return this.logger.error("Failed to cleanup expired items",e),0}}async updateStats(){try{const e=await this.keys();let t,r,i=0;for(const s of e){const e=await this.storage.getItem(s);e&&(i+=e.metadata?.size||0,(!t||e.timestamp<t.timestamp)&&(t=e),(!r||e.timestamp>r.timestamp)&&(r=e))}this.stats={totalItems:e.length,totalSize:i,availableSpace:(this.config.size||52428800)-i,usedSpace:i,oldestItem:t,newestItem:r,averageItemSize:e.length>0?i/e.length:0}}catch(e){this.logger.error("Failed to update stats",e)}}}class y{constructor(e){this._storage=e,this.middleware=[],this.router=new f,this.setupDefaultEndpoints()}async get(e){return(await this.request("GET",e,void 0,{})).data}async post(e,t){return(await this.request("POST",e,t,{})).data}async put(e,t){return(await this.request("PUT",e,t,{})).data}async delete(e){return(await this.request("DELETE",e,void 0,{})).data}async patch(e,t){return(await this.request("PATCH",e,t,{})).data}async request(e,t,r,i){const s={method:e,path:t,headers:i?.headers||{},body:r,query:i?.query||{},params:{},timestamp:Date.now()};try{for(const e of this.middleware)if(e.request){const t=await e.request(s);Object.assign(s,t)}let e=await this.router.handle(s);for(const t of this.middleware)t.response&&(e=await t.response(e));return{data:e.data,status:e.status,statusText:e.statusText,headers:e.headers||{},config:s,request:s}}catch(e){let t=e;for(const e of this.middleware)e.error&&(t=await e.error(t));throw t}}registerEndpoint(e){this.router.register(e)}use(e){this.middleware.push(e)}setupDefaultEndpoints(){this.router.register({path:"/storage/:key",method:"GET",handler:async e=>{const t=e.params.key;if(!t)return{data:null,status:400,statusText:"Bad Request"};return{data:await this._storage.getItem(t),status:200,statusText:"OK"}}}),this.router.register({path:"/storage/:key",method:"POST",handler:async e=>{const t=e.params.key;return t?(await this._storage.setItem(t,e.body),{data:{success:!0,key:t},status:201,statusText:"Created"}):{data:null,status:400,statusText:"Bad Request"}}}),this.router.register({path:"/storage/:key",method:"PUT",handler:async e=>{const t=e.params.key;return t?(await this._storage.setItem(t,e.body),{data:{success:!0,key:t},status:200,statusText:"OK"}):{data:null,status:400,statusText:"Bad Request"}}}),this.router.register({path:"/storage/:key",method:"DELETE",handler:async e=>{const t=e.params.key;return t?(await this._storage.removeItem(t),{data:{success:!0,key:t},status:200,statusText:"OK"}):{data:null,status:400,statusText:"Bad Request"}}}),this.router.register({path:"/storage",method:"GET",handler:async e=>{const t=await this._storage.keys(),r={};for(const e of t)r[e]=await this._storage.getItem(e);return{data:r,status:200,statusText:"OK"}}}),this.router.register({path:"/storage/clear",method:"POST",handler:async e=>(await this._storage.clear(),{data:{success:!0},status:200,statusText:"OK"})}),this.router.register({path:"/storage/stats",method:"GET",handler:async e=>({data:{totalItems:await this._storage.length(),keys:await this._storage.keys()},status:200,statusText:"OK"})}),this.router.register({path:"/health",method:"GET",handler:async e=>({data:{status:"healthy",timestamp:Date.now(),storage:{available:!0,totalItems:await this._storage.length()}},status:200,statusText:"OK"})})}}class f{constructor(){this.routes=new Map,this.middleware=[]}register(e){const t=`${e.method}:${e.path}`;this.routes.set(t,e)}unregister(e,t){const r=`${t}:${e}`;this.routes.delete(r)}async handle(e){const t=`${e.method}:${e.path}`,r=this.routes.get(t);if(!r)return{data:{error:"Endpoint not found"},status:404,statusText:"Not Found"};try{for(const t of r.middleware||[])if(t.request){const r=await t.request(e);Object.assign(e,r)}let t=await r.handler(e);for(const e of r.middleware||[])e.response&&(t=await e.response(t));return t}catch(e){return{data:{error:e instanceof Error?e.message:"Internal Server Error"},status:500,statusText:"Internal Server Error"}}}use(e){this.middleware.push(e)}}class w{constructor(e,t){this._storage=e,this.eventEmitter=t,this.agents=new Map,this.multiAgentSystems=new Map,this.isInitialized=!1,this.memory=new b(e)}async initialize(){if(!this.isInitialized)try{"initialize"in this.memory&&"function"==typeof this.memory.initialize&&await this.memory.initialize(),await this.loadAgents(),this.isInitialized=!0,this.eventEmitter.emit("ai:manager:initialized",{timestamp:Date.now()})}catch(e){throw new Error(`Failed to initialize AI Manager: ${e instanceof Error?e.message:"Unknown error"}`)}}createAgent(e){const t=new k(e,this.memory,this.eventEmitter);return this.agents.set(t.id,t),this.saveAgent(t),this.eventEmitter.emit("ai:agent:created",{agentId:t.id,config:e}),t}getAgent(e){return this.agents.get(e)}removeAgent(e){return!!this.agents.get(e)&&(this.agents.delete(e),this._storage.removeItem(`ai_agent_${e}`),this.eventEmitter.emit("ai:agent:removed",{agentId:e}),!0)}getAllAgents(){return Array.from(this.agents.values())}async exportMemory(){return"export"in this.memory&&"function"==typeof this.memory.export&&await this.memory.export()||{}}async importMemory(e){"import"in this.memory&&"function"==typeof this.memory.import&&await this.memory.import(e)}async storeMemory(e,t,r="context",i=.5){const s={value:t,type:r,importance:i,timestamp:Date.now()};await this.memory.store(e,s)}async clearMemory(){this.memory.clear()}getMemoryStats(){return"getStats"in this.memory&&"function"==typeof this.memory.getStats?this.memory.getStats():{totalEntries:0,totalSize:0,averageImportance:0,entriesByType:{}}}async loadAgents(){try{const e=(await this._storage.keys()).filter(e=>e.startsWith("ai_agent_"));for(const t of e){const e=await this._storage.getItem(t);if(e){const t=JSON.parse(e),r=new k(t,this.memory,this.eventEmitter);this.agents.set(r.id,r)}}}catch(e){this.eventEmitter.emit("ai:manager:load-agents-error",{error:e instanceof Error?e.message:"Unknown error",timestamp:Date.now()})}}async saveAgent(e){try{const t={id:e.id,name:e.name,type:e.type,config:e.config,state:e.state};await this._storage.setItem(`ai_agent_${e.id}`,JSON.stringify(t))}catch(t){this.eventEmitter.emit("ai:manager:save-agent-error",{agentId:e.id,error:t instanceof Error?t.message:"Unknown error",timestamp:Date.now()})}}}class k{constructor(e,t,r){this.eventEmitter=r,this.state={isActive:!1,isProcessing:!1,lastActivity:0,totalRequests:0,totalTokens:0,errors:[]},this.id=e.id||n(),this.name=e.name,this.type=e.type,this.config=e,this.memory=t}async execute(e,t){this.state.isProcessing=!0,this.state.lastActivity=Date.now();try{let r;switch(await this.memory.store(`interaction_${Date.now()}`,{prompt:e,context:t,timestamp:Date.now(),agentId:this.id}),this.type){case"llm":r=await this.executeLLM(e,t);break;case"multi-agent":r=await this.executeMultiAgent(e,t);break;case"custom":r=await this.executeCustom(e,t);break;default:throw new Error(`Unknown agent type: ${this.type}`)}return this.state.totalRequests++,this.state.isProcessing=!1,this.eventEmitter.emit("ai:agent:executed",{agentId:this.id,prompt:e,result:r,timestamp:Date.now()}),r}catch(r){throw this.state.isProcessing=!1,this.state.errors.push({id:n(),timestamp:Date.now(),type:"execution",message:r instanceof Error?r.message:"Unknown error",context:{prompt:e,context:t},retryable:!0}),this.eventEmitter.emit("ai:agent:error",{agentId:this.id,error:r,timestamp:Date.now()}),r}}addTool(e){this.config.tools||(this.config.tools=[]),this.config.tools.push(e)}removeTool(e){this.config.tools&&(this.config.tools=this.config.tools.filter(t=>t.function.name!==e))}clearMemory(){this.memory.clear()}getMemoryStats(){return"getStats"in this.memory&&"function"==typeof this.memory.getStats?this.memory.getStats():{totalEntries:0,totalSize:0,averageImportance:0,entriesByType:{}}}async executeLLM(e,t){return{response:`AI Agent "${this.name}" processed: ${e}`,tokens:e.length,timestamp:Date.now()}}async executeMultiAgent(e,t){return{response:`Multi-agent system "${this.name}" processed: ${e}`,agents:[],timestamp:Date.now()}}async executeCustom(e,t){return{response:`Custom agent "${this.name}" processed: ${e}`,timestamp:Date.now()}}}class b{constructor(e){this._storage=e,this.entries=new Map,this.maxSize=1e3,this.strategy="lru"}async initialize(){await this.loadFromStorage()}async store(e,t,r="context",i=.5){const s={id:e,timestamp:Date.now(),type:r,content:t,importance:i,tags:[],metadata:{}};this.entries.set(e,s),this.entries.size>this.maxSize&&await this.cleanup(),await this._storage.setItem(`ai_memory_${e}`,JSON.stringify(s))}async retrieve(e){let t=this.entries.get(e);if(!t){const r=await this._storage.getItem(`ai_memory_${e}`);r&&(t=JSON.parse(r),t&&this.entries.set(e,t))}return t}async search(e,t,r=10){const i=[];for(const s of this.entries.values())if((!t||s.type===t)&&(JSON.stringify(s.content).toLowerCase().includes(e.toLowerCase())&&i.push(s),i.length>=r))break;return i.sort((e,t)=>{const r=e.importance+(Date.now()-e.timestamp)/864e5;return t.importance+(Date.now()-t.timestamp)/864e5-r})}async clear(){this.entries.clear();const e=(await this._storage.keys()).filter(e=>e.startsWith("ai_memory_"));for(const t of e)await this._storage.removeItem(t)}async getAll(){const e={};for(const[t,r]of this.entries)e[t]=r;return e}getStats(){const e=Array.from(this.entries.values()),t=e.reduce((e,t)=>e+JSON.stringify(t).length,0),r=e.length>0?e.reduce((e,t)=>e+t.importance,0)/e.length:0,i={};for(const t of e)i[t.type]=(i[t.type]||0)+1;const s=[...e].sort((e,t)=>e.timestamp-t.timestamp),a=[...e].sort((e,t)=>t.timestamp-e.timestamp);return{totalEntries:e.length,totalSize:t,averageImportance:r,oldestEntry:s[0]||void 0,newestEntry:a[0]||void 0,entriesByType:i}}async cleanup(){const e=Array.from(this.entries.values());let t;switch(this.strategy){case"fifo":case"lru":t=e.sort((e,t)=>e.timestamp-t.timestamp);break;case"importance":t=e.sort((e,t)=>e.importance-t.importance);break;default:t=e}const r=t.slice(0,Math.floor(.1*this.maxSize));for(const e of r)this.entries.delete(e.id),await this._storage.removeItem(`ai_memory_${e.id}`)}async loadFromStorage(){try{const e=(await this._storage.keys()).filter(e=>e.startsWith("ai_memory_"));for(const t of e){const e=await this._storage.getItem(t);if(e){const t=JSON.parse(e);this.entries.set(t.id,t)}}}catch(e){}}async export(){const e={};for(const[t,r]of this.entries)e[t]=r;return e}async import(e){for(const[t,r]of Object.entries(e))this.entries.set(t,r),await this._storage.setItem(`ai_memory_${t}`,JSON.stringify(r))}}class S{constructor(){this.events=new Map}on(e,t){this.events.has(e)||this.events.set(e,new Set),this.events.get(e).add(t)}off(e,t){const r=this.events.get(e);r&&(r.delete(t),0===r.size&&this.events.delete(e))}emit(e,...t){const r=this.events.get(e);r&&r.forEach(e=>{try{e(...t)}catch(e){}})}once(e,t){const r=(...i)=>{t(...i),this.off(e,r)};this.on(e,r)}removeAllListeners(e){e?this.events.delete(e):this.events.clear()}listenerCount(e){return this.events.get(e)?.size||0}eventNames(){return Array.from(this.events.keys())}}class v extends S{constructor(e){super(),this.currentSession=null,this.refreshTimer=null,this.sessionTimer=null,this.ciamProviders=new Map,this.activeCiamProvider=null,this.cloudProviders=new Map,this.providerSessions=new Map,this.syncTimer=null,this.systemRoles=[{id:"admin",name:"Administrator",description:"Full system access",permissions:[],isSystemRole:!0,hierarchy:1e3},{id:"user",name:"User",description:"Basic user access",permissions:[],isSystemRole:!0,hierarchy:100},{id:"guest",name:"Guest",description:"Limited read-only access",permissions:[],isSystemRole:!0,hierarchy:10}],this.systemPermissions=[{id:"read",resource:"*",action:"read",description:"Read access to resources"},{id:"write",resource:"*",action:"write",description:"Write access to resources"},{id:"delete",resource:"*",action:"delete",description:"Delete access to resources"},{id:"admin",resource:"*",action:"*",description:"Full administrative access"}],this.config=e,this.logger=new m(!1,"AuthManager"),this.initializeSystemRoles(),this.initializeProviders()}async login(e){try{let t;switch(this.logger.info(`Login attempt for user: ${e.username} using provider: ${this.config.provider}`),this.config.provider){case"local":t=await this.localLogin(e);break;case"oauth":t=await this.oauthLogin(e);break;case"custom":t=await this.customLogin(e);break;case"ciam":t=await this.ciamLogin(e);break;case"hybrid":t=await this.hybridLogin(e);break;case"tribrid":t=await this.tribridLogin(e);break;default:throw new Error(`Unsupported auth provider: ${this.config.provider}`)}const r=await this.createSession(t);return this.currentSession=r,await this.storeToken(r.token),this.config.autoRefresh&&this.scheduleTokenRefresh(),this.config.sessionTimeout&&this.scheduleSessionTimeout(),"hybrid"!==this.config.provider&&"tribrid"!==this.config.provider||this.config.hybrid?.syncSessions&&this.scheduleSessionSync(),this.emit("login-success",{user:r.user,session:r,provider:this.config.provider}),this.logger.info(`User ${e.username} logged in successfully via ${this.config.provider}`),r}catch(t){throw this.emit("login-failed",{username:e.username,error:t,provider:this.config.provider}),this.logger.error("Login failed:",t),t}}async logout(){if(this.currentSession)try{this.config.endpoints?.logout&&await fetch(this.config.endpoints.logout,{method:"POST",headers:{Authorization:`${this.currentSession.token.tokenType} ${this.currentSession.token.accessToken}`,"Content-Type":"application/json"}}),await this.clearStoredToken(),this.refreshTimer&&(clearTimeout(this.refreshTimer),this.refreshTimer=null),this.sessionTimer&&(clearTimeout(this.sessionTimer),this.sessionTimer=null);const e=this.currentSession.user;this.currentSession=null,this.emit("logout",{user:e}),this.logger.info(`User ${e.username} logged out`)}catch(e){throw this.logger.error("Logout error:",e),e}}async refreshToken(){if(!this.currentSession?.token.refreshToken)throw new Error("No refresh token available");try{const e=await fetch(this.config.endpoints.refresh,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({refresh_token:this.currentSession.token.refreshToken})});if(!e.ok)throw new Error(`Token refresh failed: ${e.statusText}`);const t=await e.json(),r=this.parseTokenResponse(t);return this.currentSession.token=r,await this.storeToken(r),this.emit("token-refreshed",{token:r}),r}catch(e){throw this.emit("token-refresh-failed",{error:e}),e}}hasPermission(e,t,r){if(!this.currentSession)return!1;const i=this.currentSession.user;for(const s of i.permissions)if(this.matchesPermission(s,e,t,r))return!0;for(const s of i.roles)for(const i of s.permissions)if(this.matchesPermission(i,e,t,r))return!0;return!1}hasRole(e){return!!this.currentSession&&this.currentSession.user.roles.some(t=>t.name===e)}hasAnyRole(e){return!!this.currentSession&&this.currentSession.user.roles.some(t=>e.includes(t.name))}hasAllRoles(e){if(!this.currentSession)return!1;const t=this.currentSession.user.roles.map(e=>e.name);return e.every(e=>t.includes(e))}getHighestRole(){return this.currentSession?this.currentSession.user.roles.reduce((e,t)=>t.hierarchy>e.hierarchy?t:e):null}getCurrentUser(){return this.currentSession?.user||null}getCurrentSession(){return this.currentSession}isAuthenticated(){return!!this.currentSession&&this.isTokenValid()}isTokenValid(){return!!this.currentSession?.token&&new Date<this.currentSession.token.expiresAt}async storeSecureCredential(e,t){const r=await this.encryptValue(t);switch(this.config.tokenStorage){case"localStorage":localStorage.setItem(`brolostack_cred_${e}`,r);break;case"sessionStorage":sessionStorage.setItem(`brolostack_cred_${e}`,r);break;case"secure":await this.storeInSecureStorage(`brolostack_cred_${e}`,r)}}async getSecureCredential(e){let t=null;switch(this.config.tokenStorage){case"localStorage":t=localStorage.getItem(`brolostack_cred_${e}`);break;case"sessionStorage":t=sessionStorage.getItem(`brolostack_cred_${e}`);break;case"secure":t=await this.getFromSecureStorage(`brolostack_cred_${e}`);break;default:return null}return t?await this.decryptValue(t):null}async removeSecureCredential(e){switch(this.config.tokenStorage){case"localStorage":localStorage.removeItem(`brolostack_cred_${e}`);break;case"sessionStorage":sessionStorage.removeItem(`brolostack_cred_${e}`);break;case"secure":await this.removeFromSecureStorage(`brolostack_cred_${e}`)}}async localLogin(e){if(!this.config.endpoints?.login)throw new Error("Login endpoint not configured");const t=await fetch(this.config.endpoints.login,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!t.ok)throw new Error(`Login failed: ${t.statusText}`);return await t.json()}async oauthLogin(e){throw new Error("OAuth login requires browser redirect flow")}async customLogin(e){throw new Error("Custom login method not implemented")}async createSession(e){const t=this.parseTokenResponse(e);return{user:this.parseUserResponse(e),token:t,sessionId:this.generateSessionId(),createdAt:new Date,lastActivity:new Date,ipAddress:await this.getClientIP(),userAgent:navigator.userAgent}}parseTokenResponse(e){return{accessToken:e.access_token||e.token,refreshToken:e.refresh_token,tokenType:e.token_type||"Bearer",expiresIn:e.expires_in||3600,expiresAt:new Date(Date.now()+1e3*(e.expires_in||3600)),scope:e.scope?.split(" ")}}parseUserResponse(e){return{id:e.user?.id||e.sub,username:e.user?.username||e.preferred_username,email:e.user?.email,displayName:e.user?.name||e.user?.display_name,roles:e.user?.roles?.map(e=>this.parseRole(e))||[this.systemRoles[2]],permissions:e.user?.permissions?.map(e=>this.parsePermission(e))||[],metadata:e.user?.metadata,lastLogin:new Date,isActive:!0,mfaEnabled:e.user?.mfa_enabled}}parseRole(e){return{id:e.id,name:e.name,description:e.description,permissions:e.permissions?.map(e=>this.parsePermission(e))||[],isSystemRole:!1,hierarchy:e.hierarchy||0}}parsePermission(e){return{id:e.id,resource:e.resource,action:e.action,conditions:e.conditions,description:e.description}}matchesPermission(e,t,r,i){if("*"!==e.resource&&e.resource!==t)return!1;if("*"!==e.action&&e.action!==r)return!1;if(e.conditions&&i)for(const[t,r]of Object.entries(e.conditions))if(i[t]!==r)return!1;return!0}async storeToken(e){const t=JSON.stringify(e),r=await this.encryptValue(t);switch(this.config.tokenStorage){case"localStorage":localStorage.setItem("brolostack_auth_token",r);break;case"sessionStorage":sessionStorage.setItem("brolostack_auth_token",r);break;case"secure":await this.storeInSecureStorage("brolostack_auth_token",r)}}async clearStoredToken(){switch(this.config.tokenStorage){case"localStorage":localStorage.removeItem("brolostack_auth_token");break;case"sessionStorage":sessionStorage.removeItem("brolostack_auth_token");break;case"secure":await this.removeFromSecureStorage("brolostack_auth_token")}}scheduleTokenRefresh(){if(!this.currentSession)return;const e=this.currentSession.token.expiresAt.getTime()-Date.now(),t=Math.max(e-6e4,3e4);this.refreshTimer=setTimeout(async()=>{try{await this.refreshToken(),this.scheduleTokenRefresh()}catch(e){this.emit("auto-refresh-failed",{error:e})}},t)}scheduleSessionTimeout(){this.sessionTimer&&clearTimeout(this.sessionTimer),this.sessionTimer=setTimeout(()=>{this.emit("session-timeout"),this.logout()},this.config.sessionTimeout)}generateSessionId(){return`sess_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}async getClientIP(){return"unknown"}async encryptValue(e){return btoa(e)}async decryptValue(e){return atob(e)}async storeInSecureStorage(e,t){throw new Error("Secure storage not implemented for this platform")}async getFromSecureStorage(e){throw new Error("Secure storage not implemented for this platform")}async removeFromSecureStorage(e){throw new Error("Secure storage not implemented for this platform")}initializeSystemRoles(){this.systemRoles[0]&&(this.systemRoles[0].permissions=[...this.systemPermissions]),this.systemRoles[1]&&this.systemPermissions[0]&&this.systemPermissions[1]&&(this.systemRoles[1].permissions=[this.systemPermissions[0],this.systemPermissions[1]]),this.systemRoles[2]&&this.systemPermissions[0]&&(this.systemRoles[2].permissions=[this.systemPermissions[0]])}async initializeProviders(){try{this.config.ciam&&await this.initializeCiamProvider(),this.config.cloudAuth&&await this.initializeCloudProviders(),this.logger.info("Auth providers initialized successfully")}catch(e){throw this.logger.error("Failed to initialize auth providers:",e),e}}async initializeCiamProvider(){if(!this.config.ciam)return;const{provider:e,config:t}=this.config.ciam;try{let r;switch(e){case"auth0":r=new E,await r.initialize(t.auth0);break;case"entraId":r=new T,await r.initialize(t.entraId);break;case"cognito":r=new C,await r.initialize(t.cognito);break;case"keycloak":r=new A,await r.initialize(t.keycloak);break;case"okta":r=new D,await r.initialize(t.okta);break;case"stytch":r=new I,await r.initialize(t.stytch);break;case"firebase":r=new x,await r.initialize(t.firebase);break;case"frontegg":r=new _,await r.initialize(t.frontegg);break;case"workos":r=new O,await r.initialize(t.workos);break;default:throw new Error(`Unsupported CIAM provider: ${e}`)}this.ciamProviders.set(e,r),this.activeCiamProvider=r,this.logger.info(`CIAM provider ${e} initialized`)}catch(t){throw this.logger.error(`Failed to initialize CIAM provider ${e}:`,t),t}}async initializeCloudProviders(){if(this.config.cloudAuth){if(this.config.cloudAuth.aws){const e=new R;await e.initialize(this.config.cloudAuth.aws),this.cloudProviders.set("aws",e)}if(this.config.cloudAuth.azure){const e=new $;await e.initialize(this.config.cloudAuth.azure),this.cloudProviders.set("azure",e)}if(this.config.cloudAuth.gcp){const e=new N;await e.initialize(this.config.cloudAuth.gcp),this.cloudProviders.set("gcp",e)}this.logger.info("Cloud auth providers initialized")}}async ciamLogin(e){if(!this.activeCiamProvider)throw new Error("No CIAM provider configured");try{const t=await this.activeCiamProvider.login(e),r=await this.activeCiamProvider.getUser(),i=await this.mapCiamUserToBrolostack(r);return this.config.ciam?.integration.syncWithBrolostack&&await this.syncCiamUserWithBrolostack(i,r),{user:i,token:t.token||t,ciamProvider:this.config.ciam?.provider,ciamUserId:r.id,ciamToken:t}}catch(e){throw this.logger.error("CIAM login failed:",e),e}}async hybridLogin(e){if(!this.config.hybrid)throw new Error("Hybrid configuration not found");const{primary:t,fallbacks:r}=this.config.hybrid,i=[t,...r];for(const r of i)try{let s;switch(r){case"brolostack":s=await this.localLogin(e);break;case"ciam":s=await this.ciamLogin(e);break;case"cloud":s=await this.cloudLogin(e)}return this.providerSessions.set(r,s),r===t?{...s,hybridMode:!0,primaryProvider:r,availableProviders:i}:(this.logger.warn(`Primary provider ${t} failed, using fallback ${r}`),{...s,hybridMode:!0,primaryProvider:t,activeProvider:r,availableProviders:i})}catch(e){if(this.logger.warn(`Provider ${r} failed:`,e),r===i[i.length-1])throw new Error(`All authentication providers failed. Last error: ${e.message}`);continue}throw new Error("No authentication providers available")}async tribridLogin(e){const t=await this.hybridLogin(e),r={};for(const[e,t]of this.cloudProviders.entries())try{const i=await t.authenticate();r[e]=i,this.providerSessions.set(`cloud-${e}`,i)}catch(t){this.logger.warn(`Cloud provider ${e} authentication failed:`,t)}return{...t,tribridMode:!0,cloudProviders:r}}async cloudLogin(e){for(const[e,t]of this.cloudProviders.entries())try{const r=await t.authenticate(),i=await t.getCredentials();return{user:await this.createCloudUser(i,e),token:this.createTokenFromCloudAuth(r),cloudProvider:e,cloudCredentials:i}}catch(t){this.logger.warn(`Cloud provider ${e} login failed:`,t)}throw new Error("No cloud providers available for authentication")}async mapCiamUserToBrolostack(e){return this.config.ciam?.integration.customUserMapping?this.config.ciam.integration.customUserMapping(e):{id:e.id||e.sub||e.user_id,username:e.username||e.preferred_username||e.email,email:e.email,displayName:e.name||e.display_name||e.given_name+" "+e.family_name,roles:this.mapCiamRolesToBrolostack(e.roles||[]),permissions:this.mapCiamPermissionsToBrolostack(e.permissions||[]),metadata:{ciamProvider:this.config.ciam?.provider,ciamUserId:e.id,originalCiamUser:e},lastLogin:new Date,isActive:!0,mfaEnabled:e.mfa_enabled||!1}}async syncCiamUserWithBrolostack(e,t){try{const r=JSON.stringify(e);switch(this.config.tokenStorage){case"brolostack-encrypted":const t=await this.encryptValue(r);localStorage.setItem(`brolostack_user_${e.id}`,t);break;case"localStorage":localStorage.setItem(`brolostack_user_${e.id}`,r);break;case"sessionStorage":sessionStorage.setItem(`brolostack_user_${e.id}`,r)}const i=JSON.stringify({provider:this.config.ciam?.provider,userId:t.id,lastSync:new Date,originalUser:t});await this.storeSecureCredential(`ciam_${e.id}`,i),this.logger.info(`User ${e.id} synced with Brolostack storage`)}catch(e){this.logger.error("Failed to sync user with Brolostack:",e)}}async createCloudUser(e,t){return{id:e.userId||e.accountId||"cloud-user",username:e.username||e.email||"cloud-user",email:e.email||"",displayName:e.displayName||e.name||"Cloud User",roles:[this.systemRoles[1]],permissions:[],metadata:{cloudProvider:t,cloudCredentials:e},lastLogin:new Date,isActive:!0}}createTokenFromCloudAuth(e){return{accessToken:e.accessToken||e.token||"cloud-token",refreshToken:e.refreshToken,tokenType:"Bearer",expiresIn:e.expiresIn||3600,expiresAt:new Date(Date.now()+1e3*(e.expiresIn||3600))}}mapCiamRolesToBrolostack(e){return e.map(e=>({id:e.id||e.name,name:e.name,description:e.description||"",permissions:this.mapCiamPermissionsToBrolostack(e.permissions||[]),isSystemRole:!1,hierarchy:e.hierarchy||100}))}mapCiamPermissionsToBrolostack(e){return e.map(e=>({id:e.id||e.name,resource:e.resource||e.scope||"*",action:e.action||e.permission||"read",conditions:e.conditions,description:e.description||""}))}scheduleSessionSync(){this.syncTimer&&clearInterval(this.syncTimer),this.syncTimer=setInterval(async()=>{await this.syncProviderSessions()},3e5)}async syncProviderSessions(){if(this.currentSession)try{if(this.activeCiamProvider&&this.activeCiamProvider.isAuthenticated()){const e=await this.activeCiamProvider.getUser();await this.syncCiamUserWithBrolostack(this.currentSession.user,e)}for(const[e,t]of this.cloudProviders.entries())if(t.isAuthenticated()){const r=await t.getCredentials();this.providerSessions.set(`cloud-${e}`,r)}this.currentSession.syncStatus="synced",this.currentSession.lastSync=new Date,this.emit("session-synced",{sessionId:this.currentSession.sessionId,timestamp:new Date})}catch(e){this.logger.error("Session sync failed:",e),this.currentSession&&(this.currentSession.syncStatus="failed"),this.emit("session-sync-failed",{sessionId:this.currentSession?.sessionId,error:e})}}async enableMFA(){if(!this.activeCiamProvider?.enableMFA)throw new Error("MFA not supported by current CIAM provider");try{await this.activeCiamProvider.enableMFA(),this.currentSession&&(this.currentSession.user.mfaEnabled=!0),this.emit("mfa-enabled",{userId:this.currentSession?.user.id}),this.logger.info("MFA enabled for current user")}catch(e){throw this.logger.error("Failed to enable MFA:",e),e}}async socialLogin(e){if(!this.activeCiamProvider?.socialLogin)throw new Error("Social login not supported by current CIAM provider");try{const t=await this.activeCiamProvider.socialLogin(e),r=await this.createSession(t);return this.currentSession=r,await this.storeToken(r.token),this.emit("social-login-success",{provider:e,user:r.user,session:r}),r}catch(t){throw this.emit("social-login-failed",{provider:e,error:t}),t}}async passwordlessLogin(e){if(!this.activeCiamProvider?.passwordlessLogin)throw new Error("Passwordless login not supported by current CIAM provider");try{const t=await this.activeCiamProvider.passwordlessLogin(e),r=await this.createSession(t);return this.currentSession=r,await this.storeToken(r.token),this.emit("passwordless-login-success",{identifier:e,user:r.user,session:r}),r}catch(t){throw this.emit("passwordless-login-failed",{identifier:e,error:t}),t}}async biometricLogin(){if(!this.activeCiamProvider?.biometricLogin)throw new Error("Biometric login not supported by current CIAM provider");try{const e=await this.activeCiamProvider.biometricLogin(),t=await this.createSession(e);return this.currentSession=t,await this.storeToken(t.token),this.emit("biometric-login-success",{user:t.user,session:t}),t}catch(e){throw this.emit("biometric-login-failed",{error:e}),e}}getActiveProviders(){const e=[];this.activeCiamProvider&&e.push(`ciam-${this.config.ciam?.provider}`);for(const[t,r]of this.cloudProviders.entries())r.isAuthenticated()&&e.push(`cloud-${t}`);return e}getProviderSession(e){return this.providerSessions.get(e)}async switchProvider(e,t){try{if("ciam"===e&&this.activeCiamProvider)this.logger.info(`Switched to CIAM provider: ${this.config.ciam?.provider}`);else if("cloud"===e&&t){const e=this.cloudProviders.get(t);if(!e||!e.isAuthenticated())throw new Error(`Cloud provider ${t} not available or not authenticated`);this.providerSessions.set(`active-cloud-${t}`,e),this.logger.info(`Switched to cloud provider: ${t}`)}this.emit("provider-switched",{type:e,provider:t||this.config.ciam?.provider})}catch(e){throw this.logger.error("Failed to switch provider:",e),e}}}class E{constructor(){this.name="auth0"}async initialize(e){e?.domain&&console.log(`Initializing Auth0 with domain: ${e.domain}`)}async login(e){const{email:t,password:r}=e||{};if(!t||!r)throw new Error("Email and password are required for Auth0 login");return{user:{sub:`auth0|${Date.now()}`,email:t,email_verified:!0,name:t.split("@")[0],picture:`https://gravatar.com/avatar/${Date.now()}`,updated_at:(new Date).toISOString(),user_id:`auth0|${Date.now()}`,user_metadata:{},app_metadata:{}},tokens:{access_token:`at_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,id_token:`it_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,refresh_token:`rt_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,token_type:"Bearer",expires_in:86400}}}async logout(){}async getUser(){return{sub:`auth0|${Date.now()}`,email:"user@example.com",email_verified:!0,name:"Test User",picture:`https://gravatar.com/avatar/${Date.now()}`,updated_at:(new Date).toISOString()}}async refreshToken(){return{access_token:`at_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,token_type:"Bearer",expires_in:86400}}isAuthenticated(){return!1}async enableMFA(){}async socialLogin(e){throw new Error("Auth0 social login implementation required")}async passwordlessLogin(e){throw new Error("Auth0 passwordless login implementation required")}}class T{constructor(){this.name="entraId"}async initialize(e){e?.tenantId&&console.log(`Initializing Entra ID with tenant: ${e.tenantId}`)}async login(e){throw new Error("Entra ID login implementation required")}async logout(){}async getUser(){throw new Error("Entra ID getUser implementation required")}async refreshToken(){throw new Error("Entra ID refreshToken implementation required")}isAuthenticated(){return!1}}class C{constructor(){this.name="cognito"}async initialize(e){e?.userPoolId&&console.log(`Initializing Cognito with pool: ${e.userPoolId}`)}async login(e){throw new Error("Cognito login implementation required")}async logout(){}async getUser(){throw new Error("Cognito getUser implementation required")}async refreshToken(){throw new Error("Cognito refreshToken implementation required")}isAuthenticated(){return!1}}class A{constructor(){this.name="keycloak"}async initialize(e){e?.realm&&console.log(`Initializing Keycloak with realm: ${e.realm}`)}async login(e){throw new Error("Keycloak login implementation required")}async logout(){}async getUser(){throw new Error("Keycloak getUser implementation required")}async refreshToken(){throw new Error("Keycloak refreshToken implementation required")}isAuthenticated(){return!1}}class D{constructor(){this.name="okta"}async initialize(e){e?.issuer&&console.log(`Initializing Okta with issuer: ${e.issuer}`)}async login(e){throw new Error("Okta login implementation required")}async logout(){}async getUser(){throw new Error("Okta getUser implementation required")}async refreshToken(){throw new Error("Okta refreshToken implementation required")}isAuthenticated(){return!1}}class I{constructor(){this.name="stytch"}async initialize(e){e?.projectId&&console.log(`Initializing Stytch with project: ${e.projectId}`)}async login(e){throw new Error("Stytch login implementation required")}async logout(){}async getUser(){throw new Error("Stytch getUser implementation required")}async refreshToken(){throw new Error("Stytch refreshToken implementation required")}isAuthenticated(){return!1}async passwordlessLogin(e){throw new Error("Stytch passwordless login implementation required")}}class x{constructor(){this.name="firebase"}async initialize(e){e?.projectId&&console.log(`Initializing Firebase with project: ${e.projectId}`)}async login(e){throw new Error("Firebase login implementation required")}async logout(){}async getUser(){throw new Error("Firebase getUser implementation required")}async refreshToken(){throw new Error("Firebase refreshToken implementation required")}isAuthenticated(){return!1}async socialLogin(e){throw new Error("Firebase social login implementation required")}}class _{constructor(){this.name="frontegg"}async initialize(e){e?.clientId&&console.log(`Initializing Frontegg with client: ${e.clientId}`)}async login(e){throw new Error("Frontegg login implementation required")}async logout(){}async getUser(){throw new Error("Frontegg getUser implementation required")}async refreshToken(){throw new Error("Frontegg refreshToken implementation required")}isAuthenticated(){return!1}}class O{constructor(){this.name="workos"}async initialize(e){e?.clientId&&console.log(`Initializing WorkOS with client: ${e.clientId}`)}async login(e){throw new Error("WorkOS login implementation required")}async logout(){}async getUser(){throw new Error("WorkOS getUser implementation required")}async refreshToken(){throw new Error("WorkOS refreshToken implementation required")}isAuthenticated(){return!1}}class R{constructor(){this.name="aws"}async initialize(e){e?.region&&console.log(`Initializing AWS with region: ${e.region}`)}async authenticate(){throw new Error("AWS authentication implementation required")}async getCredentials(){throw new Error("AWS getCredentials implementation required")}async refreshCredentials(){throw new Error("AWS refreshCredentials implementation required")}isAuthenticated(){return!1}}class ${constructor(){this.name="azure"}async initialize(e){e?.tenantId&&console.log(`Initializing Azure with tenant: ${e.tenantId}`)}async authenticate(){throw new Error("Azure authentication implementation required")}async getCredentials(){throw new Error("Azure getCredentials implementation required")}async refreshCredentials(){throw new Error("Azure refreshCredentials implementation required")}isAuthenticated(){return!1}}class N{constructor(){this.name="gcp"}async initialize(e){e?.projectId&&console.log(`Initializing GCP with project: ${e.projectId}`)}async authenticate(){throw new Error("GCP authentication implementation required")}async getCredentials(){throw new Error("GCP getCredentials implementation required")}async refreshCredentials(){throw new Error("GCP refreshCredentials implementation required")}isAuthenticated(){return!1}}const P=new class{constructor(){this.currentEnvironment=this.detectEnvironment(),this.logger=new m(this.isDevelopment(),"EnvironmentManager"),this.config=this.createEnvironmentConfig(this.currentEnvironment),this.logger.info(`Brolostack Environment: ${this.currentEnvironment}`,{config:this.config,nodeEnv:process.env.NODE_ENV||"undefined",timestamp:(new Date).toISOString()})}detectEnvironment(){if(process.env.BROLOSTACK_ENV){const e=process.env.BROLOSTACK_ENV.toLowerCase();if(["development","testing","staging","production"].includes(e))return e}const e=process.env.NODE_ENV?.toLowerCase();switch(e){case"development":case"dev":default:return"development";case"test":case"testing":return"testing";case"staging":case"stage":return"staging";case"production":case"prod":return"production"}}createEnvironmentConfig(e){const t={environment:e,debug:!1,performance:{enableMinification:!1,enableCompression:!1,enableTreeShaking:!1,enableCaching:!1,cacheStrategy:"none",bundleOptimization:!1,lazyLoading:!1},security:{enableDetailedErrors:!1,enableStackTraces:!1,enableConsoleLogging:!1,enableSourceMaps:!1,enableCORS:!1,corsOrigins:[],enableCSP:!1,cspPolicy:""},storage:{engine:"memory",encryption:!1,compression:!1,maxSize:10,persistentCache:!1},api:{enableMocking:!1,enableRateLimiting:!1,requestTimeout:5e3,retryAttempts:1,enableRequestLogging:!1},cloud:{enableCloudSync:!1,syncStrategy:"manual",enableBackup:!1,backupFrequency:0,enableMultiCloud:!1},monitoring:{enableAnalytics:!1,enableErrorTracking:!1,enablePerformanceMonitoring:!1,enableUserTracking:!1,sampleRate:0}};switch(e){case"development":return{...t,debug:!0,performance:{...t.performance,enableCaching:!0,cacheStrategy:"minimal",lazyLoading:!0},security:{...t.security,enableDetailedErrors:!0,enableStackTraces:!0,enableConsoleLogging:!0,enableSourceMaps:!0,enableCORS:!0,corsOrigins:"*"},storage:{...t.storage,engine:"localStorage",maxSize:50,persistentCache:!0},api:{...t.api,enableMocking:!0,requestTimeout:1e4,retryAttempts:3,enableRequestLogging:!0},cloud:{...t.cloud,enableCloudSync:!0,syncStrategy:"manual"},monitoring:{...t.monitoring,enableErrorTracking:!0,enablePerformanceMonitoring:!0,sampleRate:1}};case"testing":return{...t,debug:!0,performance:{...t.performance,enableCaching:!0,cacheStrategy:"minimal"},security:{...t.security,enableDetailedErrors:!0,enableStackTraces:!0,enableConsoleLogging:!1,enableSourceMaps:!0},storage:{...t.storage,engine:"memory",maxSize:10},api:{...t.api,enableMocking:!0,requestTimeout:5e3,retryAttempts:1,enableRequestLogging:!1},monitoring:{...t.monitoring,enableErrorTracking:!0,sampleRate:1}};case"staging":return{...t,debug:!1,performance:{...t.performance,enableMinification:!0,enableCompression:!0,enableCaching:!0,cacheStrategy:"moderate",bundleOptimization:!0,lazyLoading:!0},security:{...t.security,enableDetailedErrors:!1,enableStackTraces:!1,enableConsoleLogging:!1,enableSourceMaps:!1,enableCORS:!0,corsOrigins:process.env.ALLOWED_ORIGINS?.split(",")||[],enableCSP:!0,cspPolicy:"default-src 'self'"},storage:{...t.storage,engine:"indexedDB",encryption:!0,compression:!0,maxSize:100,persistentCache:!0},api:{...t.api,enableRateLimiting:!0,requestTimeout:8e3,retryAttempts:2,enableRequestLogging:!1},cloud:{...t.cloud,enableCloudSync:!0,syncStrategy:"batch",enableBackup:!0,backupFrequency:36e5,enableMultiCloud:!0},monitoring:{...t.monitoring,enableAnalytics:!0,enableErrorTracking:!0,enablePerformanceMonitoring:!0,sampleRate:.5}};case"production":return{...t,debug:!1,performance:{...t.performance,enableMinification:!0,enableCompression:!0,enableTreeShaking:!0,enableCaching:!0,cacheStrategy:"aggressive",bundleOptimization:!0,lazyLoading:!0},security:{...t.security,enableDetailedErrors:!1,enableStackTraces:!1,enableConsoleLogging:!1,enableSourceMaps:!1,enableCORS:!0,corsOrigins:process.env.ALLOWED_ORIGINS?.split(",")||[],enableCSP:!0,cspPolicy:"default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'"},storage:{...t.storage,engine:"indexedDB",encryption:!0,compression:!0,maxSize:500,persistentCache:!0},api:{...t.api,enableRateLimiting:!0,requestTimeout:5e3,retryAttempts:3,enableRequestLogging:!1},cloud:{...t.cloud,enableCloudSync:!0,syncStrategy:"real-time",enableBackup:!0,backupFrequency:18e5,enableMultiCloud:!0},monitoring:{...t.monitoring,enableAnalytics:!0,enableErrorTracking:!0,enablePerformanceMonitoring:!0,enableUserTracking:!0,sampleRate:.1}};default:return t}}getEnvironment(){return this.currentEnvironment}getConfig(){return{...this.config}}isDevelopment(){return"development"===this.currentEnvironment}isTesting(){return"testing"===this.currentEnvironment}isStaging(){return"staging"===this.currentEnvironment}isProduction(){return"production"===this.currentEnvironment}switchEnvironment(e){this.currentEnvironment=e,this.config=this.createEnvironmentConfig(e),this.logger=new m(this.isDevelopment(),"EnvironmentManager"),this.logger.info(`Environment switched to: ${e}`,{config:this.config,timestamp:(new Date).toISOString()})}applyToConfig(e){const t=this.getConfig();return{...e,debug:t.debug,storageEngine:t.storage.engine,encryption:t.storage.encryption,compression:t.storage.compression,maxStorageSize:t.storage.maxSize,enterprise:{...e.enterprise,security:{...e.enterprise?.security,enabled:t.security.enableCSP||t.security.enableCORS,encryption:{enabled:t.storage.encryption,algorithm:t.storage.encryption?"AES-GCM":void 0}},cloud:{...e.enterprise?.cloud,enabled:t.cloud.enableCloudSync,syncStrategy:t.cloud.syncStrategy,backup:{enabled:t.cloud.enableBackup,frequency:t.cloud.backupFrequency}},worker:{...e.enterprise?.worker,enabled:t.performance.bundleOptimization,security:{encryption:{enabled:t.storage.encryption}}}}}}getPerformanceOptimizations(){const e=this.config.performance;return{shouldMinify:e.enableMinification,shouldCompress:e.enableCompression,shouldTreeShake:e.enableTreeShaking,shouldCache:e.enableCaching,cacheStrategy:e.cacheStrategy,shouldLazyLoad:e.lazyLoading}}getSecurityConfig(){const e=this.config.security;return{showDetailedErrors:e.enableDetailedErrors,showStackTraces:e.enableStackTraces,enableConsoleLogging:e.enableConsoleLogging,enableSourceMaps:e.enableSourceMaps,corsConfig:{enabled:e.enableCORS,origins:e.corsOrigins},cspConfig:{enabled:e.enableCSP,policy:e.cspPolicy}}}log(e,t,r){if(this.config.security.enableConsoleLogging||this.isDevelopment())switch(e){case"info":this.logger.info(t,r);break;case"warn":this.logger.warn(t,r);break;case"error":this.logger.error(t,r)}}handleError(e,t){const r=this.getSecurityConfig();r.showDetailedErrors?this.logger.error("Detailed error information:",{error:e.message,stack:r.showStackTraces?e.stack:void 0,context:t,environment:this.currentEnvironment,timestamp:(new Date).toISOString()}):this.logger.error("An error occurred",{errorId:this.generateErrorId(),timestamp:(new Date).toISOString()}),this.config.monitoring.enableErrorTracking&&this.sendToErrorTracking(e,t)}generateErrorId(){return`err_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}sendToErrorTracking(e,t){this.logger.info("Error sent to tracking service",{error:e.message,context:t,environment:this.currentEnvironment})}},M=()=>P.getEnvironment(),z=()=>P.isDevelopment(),L=()=>P.isStaging(),B=()=>P.isProduction(),j=(e,t,r)=>P.log(e,t,r),U=(e,t)=>P.handleError(e,t);class F extends S{constructor(e={}){super(),this.socket=null,this.messageQueue=[],this.rooms=new Map,this.latencyMeasurements=[],this.config=this.createEnvironmentConfig(e),this.logger=new m(z(),"BrolostackWSClientside"),this.stats={connected:!1,environment:M(),reconnectCount:0,messagesSent:0,messagesReceived:0,averageLatency:0,lastActivity:Date.now(),rooms:[]},this.logger.info("BrolostackWSClientside initialized",{environment:M(),config:this.config}),this.loadPersistedQueue(),this.config.autoConnect&&this.connect()}createEnvironmentConfig(e){const t=P.getConfig();return{...{url:this.getDefaultURL(),path:"/brolostack-ws",autoConnect:!0,reconnection:!0,reconnectionAttempts:B()?10:5,reconnectionDelay:B()?1e3:2e3,reconnectionDelayMax:B()?5e3:1e4,timeout:t.api.requestTimeout,forceNew:!1,compression:t.performance.enableCompression,enableHeartbeat:!0,heartbeatInterval:3e4,messageQueue:{enabled:B()||L(),maxSize:B()?1e3:100,persistOffline:B()},performance:{enableMetrics:t.monitoring.enablePerformanceMonitoring,sampleRate:B()?.1:1}},...e}}getDefaultURL(){return z()?"http://localhost:3001":L()?process.env.STAGING_WS_URL||"wss://staging-ws.yourdomain.com":B()?process.env.PRODUCTION_WS_URL||"wss://ws.yourdomain.com":"http://localhost:3001"}async connect(){return new Promise(async(e,t)=>{try{const r={path:this.config.path,autoConnect:!1,reconnection:this.config.reconnection,reconnectionAttempts:this.config.reconnectionAttempts,reconnectionDelay:this.config.reconnectionDelay,reconnectionDelayMax:this.config.reconnectionDelayMax,timeout:this.config.timeout,forceNew:this.config.forceNew,transports:["websocket","polling"]};this.config.auth&&(r.auth=this.config.auth),B()&&(r.upgrade=!0,r.rememberUpgrade=!0);const{io:i}=await import("socket.io-client");this.socket=i(this.config.url,r),this.setupEventHandlers(),this.socket.connect(),this.socket.on("connect",()=>{this.stats.connected=!0,this.stats.connectionTime=Date.now(),this.stats.lastActivity=Date.now(),this.logger.info("WebSocket connected",{url:this.config.url,environment:M(),socketId:this.socket?.id}),this.startHeartbeat(),this.processMessageQueue(),e()}),this.socket.on("connect_error",e=>{this.logger.error("WebSocket connection error:",e),t(e)})}catch(e){this.logger.error("Failed to initialize WebSocket connection:",e),t(e)}})}setupEventHandlers(){this.socket&&(this.socket.on("connect",()=>{this.handleConnect()}),this.socket.on("disconnect",e=>{this.handleDisconnect(e)}),this.socket.on("reconnect",e=>{this.handleReconnect(e)}),this.socket.on("reconnect_error",e=>{this.handleReconnectError(e)}),this.socket.on("message",e=>{this.handleMessage(e)}),this.socket.on("room-joined",e=>{this.handleRoomJoined(e)}),this.socket.on("room-left",e=>{this.handleRoomLeft(e)}),this.socket.on("user-joined",e=>{this.handleUserJoined(e)}),this.socket.on("user-left",e=>{this.handleUserLeft(e)}),this.config.performance?.enableMetrics&&this.socket.on("pong",e=>{this.updateLatencyMetrics(e)}))}handleConnect(){this.stats.connected=!0,this.stats.connectionTime=Date.now(),this.stats.lastActivity=Date.now(),this.emit("connected",{socketId:this.socket?.id,environment:M(),timestamp:Date.now()})}handleDisconnect(e){this.stats.connected=!1,this.stopHeartbeat(),this.emit("disconnected",{reason:e,environment:M(),timestamp:Date.now()}),this.logger.info("WebSocket disconnected",{reason:e})}handleReconnect(e){this.stats.reconnectCount++,this.stats.connectionTime=Date.now(),this.emit("reconnected",{attemptNumber:e,environment:M(),timestamp:Date.now()}),this.logger.info("WebSocket reconnected",{attemptNumber:e}),this.processMessageQueue()}handleReconnectError(e){this.emit("reconnect-error",{error:e.message,environment:M(),timestamp:Date.now()}),this.logger.error("WebSocket reconnection failed:",e)}handleMessage(e){this.stats.messagesReceived++,this.stats.lastActivity=Date.now(),this.emit("message",e),z()&&this.logger.info("Message received",e)}handleRoomJoined(e){const t={id:e.roomId,name:e.roomName,memberCount:e.memberCount,joinedAt:Date.now(),lastActivity:Date.now(),messageCount:0};this.rooms.set(e.roomId,t),this.stats.rooms=Array.from(this.rooms.keys()),this.emit("room-joined",e),this.logger.info("Joined room",e)}handleRoomLeft(e){this.rooms.delete(e.roomId),this.stats.rooms=Array.from(this.rooms.keys()),this.emit("room-left",e),this.logger.info("Left room",e)}handleUserJoined(e){const t=this.rooms.get(e.roomId);t&&(t.memberCount++,t.lastActivity=Date.now()),this.emit("user-joined",e)}handleUserLeft(e){const t=this.rooms.get(e.roomId);t&&(t.memberCount=Math.max(0,t.memberCount-1),t.lastActivity=Date.now()),this.emit("user-left",e)}send(e,t,r){const i={id:this.generateMessageId(),type:e,payload:t,timestamp:Date.now(),room:r?.room,priority:r?.priority||"medium"};if(!this.socket?.connected){if(this.config.messageQueue?.enabled)return void this.queueMessage(i);throw new Error("WebSocket not connected and message queuing is disabled")}if(this.socket.emit(e,t),this.stats.messagesSent++,this.stats.lastActivity=Date.now(),r?.room){const e=this.rooms.get(r.room);e&&(e.messageCount++,e.lastActivity=Date.now())}z()&&this.logger.info("Message sent",{event:e,data:t,options:r}),this.emit("message-sent",{event:e,data:t,options:r,timestamp:Date.now()})}joinRoom(e,t,r){if(!this.socket?.connected)throw new Error("WebSocket not connected");this.socket.emit("join-room",{roomId:e,roomName:t||e,userInfo:r,timestamp:Date.now()}),this.logger.info("Joining room",{roomId:e,roomName:t})}leaveRoom(e){if(!this.socket?.connected)throw new Error("WebSocket not connected");this.socket.emit("leave-room",{roomId:e,timestamp:Date.now()}),this.logger.info("Leaving room",{roomId:e})}sendToRoom(e,t,r){this.send(t,r,{room:e})}broadcast(e,t){for(const r of this.rooms.keys())this.sendToRoom(r,e,t)}on(e,t){this.socket&&this.socket.on(e,e=>{this.stats.messagesReceived++,this.stats.lastActivity=Date.now(),t(e)}),super.on(e,t)}off(e,t){this.socket&&this.socket.off(e,t),t&&super.off(e,t)}queueMessage(e){if(this.messageQueue.length>=(this.config.messageQueue?.maxSize||100)&&this.messageQueue.shift(),this.messageQueue.push(e),this.config.messageQueue?.persistOffline&&"undefined"!=typeof localStorage)try{localStorage.setItem("brolostack-ws-queue",JSON.stringify(this.messageQueue))}catch(e){this.logger.warn("Failed to persist message queue:",e)}this.emit("message-queued",{message:e,queueSize:this.messageQueue.length})}processMessageQueue(){if(0===this.messageQueue.length)return;this.logger.info("Processing message queue",{queueSize:this.messageQueue.length});const e=[...this.messageQueue];this.messageQueue=[],"undefined"!=typeof localStorage&&localStorage.removeItem("brolostack-ws-queue");for(const t of e)try{this.socket?.emit(t.type,t.payload),this.stats.messagesSent++}catch(e){this.logger.error("Failed to send queued message:",e),this.queueMessage(t)}this.emit("queue-processed",{processedCount:e.length})}loadPersistedQueue(){if(this.config.messageQueue?.persistOffline&&"undefined"!=typeof localStorage)try{const e=localStorage.getItem("brolostack-ws-queue");e&&(this.messageQueue=JSON.parse(e),this.logger.info("Loaded persisted message queue",{queueSize:this.messageQueue.length}))}catch(e){this.logger.warn("Failed to load persisted message queue:",e)}}startHeartbeat(){this.config.enableHeartbeat&&!this.heartbeatTimer&&(this.heartbeatTimer=setInterval(()=>{if(this.socket?.connected){const e=Date.now();this.socket.emit("ping",e),this.socket.once("pong",e=>{const t=Date.now()-e;this.updateLatencyMetrics(t)})}},this.config.heartbeatInterval))}stopHeartbeat(){this.heartbeatTimer&&(clearInterval(this.heartbeatTimer),this.heartbeatTimer=void 0)}updateLatencyMetrics(e){this.latencyMeasurements.push(e),this.latencyMeasurements.length>100&&this.latencyMeasurements.shift(),this.stats.averageLatency=this.latencyMeasurements.reduce((e,t)=>e+t,0)/this.latencyMeasurements.length,this.emit("latency-updated",{latency:e,average:this.stats.averageLatency})}generateMessageId(){return`msg_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}isConnected(){return this.socket?.connected||!1}getRooms(){return Array.from(this.rooms.values())}getStats(){return{...this.stats,rooms:Array.from(this.rooms.keys())}}getSocketId(){return this.socket?.id}disconnect(){this.socket&&(this.stopHeartbeat(),this.socket.disconnect(),this.stats.connected=!1,this.logger.info("WebSocket disconnected manually"),this.emit("manual-disconnect",{timestamp:Date.now()}))}reconnect(){this.socket&&(this.socket.connect(),this.logger.info("WebSocket reconnection requested"))}enableDevMode(){z()?(this.socket?.onAny((e,...t)=>{this.logger.info(`Socket event: ${e}`,t)}),this.config.performance={enableMetrics:!0,sampleRate:1}):this.logger.warn("Dev mode features requested in non-development environment")}enableProdMode(){B()?(this.socket?.offAny(),this.config.messageQueue={enabled:!0,maxSize:1e3,persistOffline:!0},this.config.reconnectionAttempts=10,this.config.reconnectionDelay=1e3):this.logger.warn("Production mode optimizations requested in non-production environment")}destroy(){this.stopHeartbeat(),this.socket&&(this.socket.removeAllListeners(),this.socket.disconnect()),this.rooms.clear(),this.messageQueue=[],"undefined"!=typeof localStorage&&localStorage.removeItem("brolostack-ws-queue"),this.removeAllListeners(),this.logger.info("BrolostackWSClientside destroyed")}}class q extends S{constructor(e){super(),this.socket=null,this.connected=!1,this.reconnectAttempts=0,this.reconnectTimer=null,this.heartbeatTimer=null,this.channels=new Map,this.messageQueue=[],this.messageId=0,this.config={reconnect:!0,reconnectInterval:3e3,maxReconnectAttempts:5,heartbeatInterval:3e4,compression:!0,binaryType:"arraybuffer",...e},this.logger=new m(z(),"WebSocketManager")}async connect(){return new Promise((e,t)=>{try{const r={};if(this.config.authentication)switch(this.config.authentication.type){case"bearer":r.Authorization=`Bearer ${this.config.authentication.token}`;break;case"basic":const e=btoa(`${this.config.authentication.username}:${this.config.authentication.password}`);r.Authorization=`Basic ${e}`;break;case"custom":Object.assign(r,this.config.authentication.customHeaders)}this.socket=new WebSocket(this.config.url,this.config.protocols),this.config.binaryType&&(this.socket.binaryType=this.config.binaryType),this.socket.onopen=()=>{this.connected=!0,this.reconnectAttempts=0,this.logger.info("WebSocket connected"),this.config.heartbeatInterval&&this.config.heartbeatInterval>0&&this.startHeartbeat(),this.processMessageQueue(),this.emit("connected"),e()},this.socket.onclose=e=>{this.connected=!1,this.stopHeartbeat(),this.logger.info(`WebSocket disconnected: ${e.code} - ${e.reason}`),this.emit("disconnected",{code:e.code,reason:e.reason}),this.config.reconnect&&this.reconnectAttempts<(this.config.maxReconnectAttempts||5)&&this.scheduleReconnect()},this.socket.onerror=e=>{this.logger.error("WebSocket error:",e),this.emit("error",e),this.connected||t(e)},this.socket.onmessage=e=>{this.handleMessage(e)}}catch(e){this.logger.error("Failed to create WebSocket connection:",e),t(e)}})}disconnect(){this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.stopHeartbeat(),this.socket&&(this.socket.close(1e3,"Client disconnect"),this.socket=null),this.connected=!1,this.emit("disconnected",{code:1e3,reason:"Client disconnect"})}isConnected(){return this.connected&&this.socket?.readyState===WebSocket.OPEN}createChannel(e,t=100){if(this.channels.has(e))throw new Error(`Channel ${e} already exists`);const r={name:e,subscribers:new Set,messageHistory:[],maxHistory:t};return this.channels.set(e,r),this.emit("channel-created",{channel:e}),r}joinChannel(e,t){const r=this.channels.get(e);return!!r&&(r.subscribers.add(t),this.emit("channel-joined",{channel:e,subscriber:t}),!0)}leaveChannel(e,t){const r=this.channels.get(e);return!!r&&(r.subscribers.delete(t),this.emit("channel-left",{channel:e,subscriber:t}),!0)}deleteChannel(e){const t=this.channels.delete(e);return t&&this.emit("channel-deleted",{channel:e}),t}getChannel(e){return this.channels.get(e)}getChannels(){return Array.from(this.channels.keys())}send(e){const t={id:this.generateMessageId(),type:e.type||"message",payload:e.payload,timestamp:Date.now(),source:e.source||"client",target:e.target||"server"};if(!this.isConnected())return this.messageQueue.push(t),this.logger.warn("WebSocket not connected, message queued"),!1;try{return this.socket.send(JSON.stringify(t)),this.emit("message-sent",t),!0}catch(e){return this.logger.error("Failed to send message:",e),this.emit("send-error",{message:t,error:e}),!1}}sendToChannel(e,t){const r=this.channels.get(e);if(!r)return this.logger.warn(`Channel ${e} not found`),!1;const i={id:this.generateMessageId(),type:t.type||"channel-message",payload:t.payload,timestamp:Date.now(),source:t.source||"client",target:e};return r.messageHistory.push(i),r.maxHistory&&r.messageHistory.length>r.maxHistory&&r.messageHistory.shift(),this.send(i)}broadcast(e){const t={id:this.generateMessageId(),type:e.type||"broadcast",payload:e.payload,timestamp:Date.now(),source:e.source||"client",target:"broadcast"};return this.send(t)}startDataStream(e,t,r=1e3){setInterval(async()=>{try{const r=await t();this.send({type:"data-stream",payload:{stream:e,data:r},source:"data-stream"})}catch(t){this.logger.error(`Data stream ${e} error:`,t),this.emit("stream-error",{stream:e,error:t})}},r),this.emit("stream-started",{stream:e,interval:r})}sendBinary(e,t){if(!this.isConnected())return!1;try{return t&&this.send({type:"binary-metadata",payload:t}),this.socket.send(e),this.emit("binary-sent",{size:e instanceof ArrayBuffer?e.byteLength:e.size}),!0}catch(e){return this.logger.error("Failed to send binary data:",e),!1}}handleMessage(e){try{let t;if("string"!=typeof e.data)return void this.emit("binary-received",{data:e.data});switch(t=JSON.parse(e.data),t.type){case"ping":this.send({type:"pong",payload:t.payload});break;case"pong":this.emit("pong-received",t);break;case"channel-message":this.handleChannelMessage(t);break;case"broadcast":this.emit("broadcast-received",t);break;case"data-stream":this.emit("data-stream-received",t);break;default:this.emit("message-received",t)}}catch(t){this.logger.error("Failed to handle message:",t),this.emit("message-error",{error:t,rawData:e.data})}}handleChannelMessage(e){if(e.target){const t=this.channels.get(e.target);t&&(t.messageHistory.push(e),t.maxHistory&&t.messageHistory.length>t.maxHistory&&t.messageHistory.shift(),this.emit("channel-message-received",{channel:e.target,message:e}))}}scheduleReconnect(){this.reconnectAttempts++,this.reconnectTimer=setTimeout(()=>{this.logger.info(`Attempting to reconnect (${this.reconnectAttempts}/${this.config.maxReconnectAttempts})`),this.connect().catch(()=>{})},this.config.reconnectInterval)}startHeartbeat(){this.heartbeatTimer=setInterval(()=>{this.isConnected()&&this.send({type:"ping",payload:{timestamp:Date.now()}})},this.config.heartbeatInterval)}stopHeartbeat(){this.heartbeatTimer&&(clearInterval(this.heartbeatTimer),this.heartbeatTimer=null)}processMessageQueue(){for(;this.messageQueue.length>0&&this.isConnected();){const e=this.messageQueue.shift();this.send(e)}}generateMessageId(){return`msg_${++this.messageId}_${Date.now()}`}getConnectionState(){if(!this.socket)return"CLOSED";switch(this.socket.readyState){case WebSocket.CONNECTING:return"CONNECTING";case WebSocket.OPEN:return"OPEN";case WebSocket.CLOSING:return"CLOSING";case WebSocket.CLOSED:return"CLOSED";default:return"UNKNOWN"}}getStats(){return{connected:this.connected,connectionState:this.getConnectionState(),reconnectAttempts:this.reconnectAttempts,queuedMessages:this.messageQueue.length,channels:this.channels.size,totalChannelSubscribers:Array.from(this.channels.values()).reduce((e,t)=>e+t.subscribers.size,0),environment:M()}}createMultiAgentClient(e){const t={url:this.config.url,autoConnect:!0,compression:this.config.compression,auth:this.config.authentication?{apiKey:this.config.authentication.token||void 0,userId:this.config.authentication.username||void 0}:void 0,...e},r=new F(t);return this.logger.info("Enhanced WebSocket client created",{environment:M(),config:t}),r}getEnvironmentConfig(){return{reconnectionAttempts:B()?10:5,reconnectionDelay:B()?1e3:2e3,timeout:B()?5e3:1e4,compression:B()||L(),enableAuth:B()||L()}}}class H{constructor(e,t){this.renderCache=new Map,this.brolostack=e,this.config=t,this.logger=new m(!1,"BrolostackMRMManager"),this.isServerEnvironment="undefined"==typeof window}async renderReact(e,t,r){const i=Date.now();try{const s=await this.renderComponentToString(e,r);return{html:s,metadata:{title:t.url,description:"Rendered with Brolostack SSR"},performance:{renderTime:Date.now()-i,cacheHit:!1,hydrationData:r},headers:{"Content-Type":"text/html","X-Rendered-By":"Brolostack-SSR"}}}catch(e){throw this.logger.error("React render failed:",e),e}}async generateStaticPages(e,t){if(!this.config.staticGeneration?.buildTime)throw new Error("Static generation not enabled");this.logger.info(`Generating static pages for ${e.length} routes`);for(const t of e)try{const e={url:t,headers:{},cookies:{},userAgent:"Brolostack-SSG",isBot:!0,timestamp:new Date};await this.render(e),this.logger.info(`Generated static page: ${t}`)}catch(e){this.logger.error(`Failed to generate static page for ${t}:`,e)}}async extractInitialData(){const e={},t=this.brolostack.stores;for(const[r,i]of t)e[r]=i.getState();return this.brolostack.ai&&(e._aiMemory=await this.brolostack.ai.getMemory()),e}createHydrationScript(e){return`\n      <script>\n        window.__BROLOSTACK_INITIAL_DATA__ = ${JSON.stringify(e)};\n        window.__BROLOSTACK_SSR_MODE__ = '${this.config.mode}';\n        window.__BROLOSTACK_HYDRATION_STRATEGY__ = '${this.config.hydration?.strategy||"immediate"}';\n      <\/script>\n    `}async render(e){const t=Date.now(),r=this.generateCacheKey(e);try{if("none"!==this.config.cacheStrategy){const i=await this.getCachedResult(r);if(i)return this.logger.info(`Cache hit for ${e.url}`),{...i,performance:{...i.performance,cacheHit:!0,renderTime:Date.now()-t}}}const i=await this.performRender(e);return"none"!==this.config.cacheStrategy&&await this.cacheResult(r,i),i.performance.renderTime=Date.now()-t,i.performance.cacheHit=!1,this.logger.info(`Rendered ${e.url} in ${i.performance.renderTime}ms`),i}catch(t){throw this.logger.error(`SSR failed for ${e.url}:`,t),t}}async generateStatic(e=[]){if("ssg"!==this.config.mode&&"hybrid"!==this.config.mode)throw new Error("Static generation is only available in SSG or hybrid mode");const t=new Map,r=e.length>0?e:this.config.prerenderRoutes||[];this.logger.info(`Generating static pages for ${r.length} routes`);for(const e of r)try{const r={url:e,headers:{},cookies:{},userAgent:"Brolostack SSG Generator",isBot:!1,timestamp:new Date},i=await this.render(r);t.set(e,i),this.config.staticGeneration?.outputDir&&await this.writeStaticFile(e,i)}catch(t){this.logger.error(`Failed to generate static page for ${e}:`,t)}return this.logger.info(`Generated ${t.size} static pages`),t}async hydrate(e,t){if(!this.isServerEnvironment)try{switch(this.config.hydration?.strategy||"immediate"){case"immediate":await this.immediateHydration(e,t);break;case"lazy":await this.lazyHydration(e,t);break;case"on-demand":await this.onDemandHydration(e,t)}this.logger.info("Hydration completed")}catch(e){throw this.logger.error("Hydration failed:",e),e}}generateMetadata(e,t){const r={title:this.extractTitle(t)||"Brolostack Application",description:this.extractDescription(t)||"Built with Brolostack - Zero-cost full-stack framework",keywords:this.extractKeywords(t)||["brolostack","full-stack","framework"],ogTags:{"og:type":"website","og:url":e.url,"og:title":this.extractTitle(t)||"Brolostack Application","og:description":this.extractDescription(t)||"Built with Brolostack","og:site_name":"Brolostack Application"}};return r.jsonLd=this.generateJsonLd(e,t),r}async preloadCriticalResources(e){const t=[],r=await this.extractCriticalCSS(e);r&&t.push(`<style>${r}</style>`);(await this.extractCriticalJS(e)).forEach(e=>{t.push(`<link rel="modulepreload" href="${e}">`)});return(await this.extractCriticalFonts(e)).forEach(e=>{t.push(`<link rel="preload" href="${e}" as="font" type="font/woff2" crossorigin>`)}),t}async invalidateCache(e){if(e){const t=[];for(const r of this.renderCache.keys())r.includes(e)&&t.push(r);t.forEach(e=>this.renderCache.delete(e))}else this.renderCache.clear();this.logger.info("Cache invalidated"+(e?` for pattern: ${e}`:" completely"))}async performRender(e){await this.brolostack.initialize();const t=await this.loadInitialData(e),r=await this.renderToString(e,t),i=this.generateMetadata(e,t);return{html:r,metadata:i,performance:{renderTime:0,cacheHit:!1,hydrationData:this.prepareHydrationData(t)},headers:this.generateHeaders(e,i)}}async loadInitialData(e){const t=[],r={};for(const[e,i]of t)r[e]=await i.getState();return r}async renderToString(e,t){const r=await this.getTemplate(e),i=await this.processTemplate(r,t);return this.wrapInDocument(i,e,t)}async getTemplate(e){return'\n      <!DOCTYPE html>\n      <html lang="en">\n      <head>\n        <meta charset="UTF-8">\n        <meta name="viewport" content="width=device-width, initial-scale=1.0">\n        {{HEAD}}\n      </head>\n      <body>\n        <div id="app">{{CONTENT}}</div>\n        {{SCRIPTS}}\n      </body>\n      </html>\n    '}async processTemplate(e,t){let r=e;return r=r.replace(/\{\{(\w+)\}\}/g,(e,r)=>t[r]||e),r}wrapInDocument(e,t,r){const i=this.generateMetadata(t,r);let s=e;const a=this.generateHeadContent(i);s=s.replace("{{HEAD}}",a);const n=this.generateHydrationScript(r);return s=s.replace("{{SCRIPTS}}",n),s}generateHeadContent(e){let t="";if(e.title&&(t+=`<title>${e.title}</title>\n`),e.description&&(t+=`<meta name="description" content="${e.description}">\n`),e.keywords&&(t+=`<meta name="keywords" content="${e.keywords.join(", ")}">\n`),e.ogTags)for(const[r,i]of Object.entries(e.ogTags))t+=`<meta property="${r}" content="${i}">\n`;return e.jsonLd&&e.jsonLd.length>0&&e.jsonLd.forEach(e=>{t+=`<script type="application/ld+json">${JSON.stringify(e)}<\/script>\n`}),t}generateHydrationScript(e){return`\n      <script>\n        window.__BROLOSTACK_SSR_DATA__ = ${JSON.stringify(e)};\n      <\/script>\n      <script type="module">\n        import { Brolostack } from '/dist/index.esm.js';\n        \n        // Initialize client-side Brolostack with SSR data\n        const app = new Brolostack();\n        await app.hydrate(window.__BROLOSTACK_SSR_DATA__);\n      <\/script>\n    `}generateCacheKey(e){const t=`${e.url}_${e.userAgent}_${JSON.stringify(e.cookies)}`;return btoa(t).replace(/[^a-zA-Z0-9]/g,"")}async getCachedResult(e){const t=this.renderCache.get(e);if(!t)return null;if(this.config.cacheMaxAge){if(Date.now()-t.timestamp.getTime()>1e3*this.config.cacheMaxAge)return this.renderCache.delete(e),null}return t.result}async cacheResult(e,t){this.renderCache.set(e,{result:t,timestamp:new Date})}async writeStaticFile(e,t){this.config.staticGeneration?.outputDir&&this.logger.info(`Would write static file for ${e} to ${this.config.staticGeneration.outputDir}`)}async immediateHydration(e,t){console.log("Immediate hydration with data:",t)}async lazyHydration(e,t){const r=new IntersectionObserver(async e=>{for(const i of e)i.isIntersecting&&(console.log("Lazy hydration with data:",t),r.disconnect())});r.observe(e)}async renderComponentToString(e,t){return`\n      <!DOCTYPE html>\n      <html>\n        <head>\n          <title>Brolostack SSR</title>\n          <meta charset="utf-8">\n          <meta name="viewport" content="width=device-width, initial-scale=1">\n        </head>\n        <body>\n          <div id="root">\n            \x3c!-- Component would be rendered here --\x3e\n            <div>Brolostack SSR Rendered Component</div>\n          </div>\n          ${this.createHydrationScript(t||{})}\n        </body>\n      </html>\n    `}async onDemandHydration(e,t){const r=["click","keydown","touchstart"],i=async()=>{console.log("Progressive hydration with data:",t),r.forEach(t=>e.removeEventListener(t,i))};r.forEach(t=>e.addEventListener(t,i,{once:!0}))}extractTitle(e){return e.page?.title||e.meta?.title}extractDescription(e){return e.page?.description||e.meta?.description}extractKeywords(e){return e.page?.keywords||e.meta?.keywords}generateJsonLd(e,t){const r=[];return r.push({"@context":"https://schema.org","@type":"Organization",name:"Brolostack Application",url:e.url}),t.schema&&r.push(t.schema),r}async extractCriticalCSS(e){return null}async extractCriticalJS(e){return["/dist/index.esm.js"]}async extractCriticalFonts(e){return[]}prepareHydrationData(e){return{stores:e,timestamp:Date.now(),version:"1.0.2"}}generateHeaders(e,t){const r={"Content-Type":"text/html; charset=utf-8","X-Powered-By":"Brolostack SSR"};return this.config.cacheMaxAge&&(r["Cache-Control"]=`public, max-age=${this.config.cacheMaxAge}`),r}}class K extends S{constructor(e){super(),this.cryptoKeys=new Map,this.blockchain=[],this.auditLogs=[],this.riskAssessment=new Map,this.config=e,this.logger=new m(!1,"SecurityManager")}async initialize(){try{this.logger.info("Initializing Security Manager..."),await this.initializeCryptography(),this.config.blockchain.enabled&&await this.initializeBlockchain(),this.config.audit.enabled&&await this.initializeAuditSystem(),this.config.encryption.keyRotationInterval>0&&this.startKeyRotation(),await this.initializeComplianceMonitoring(),this.emit("security-initialized"),this.logger.info("Security Manager initialized successfully")}catch(e){throw this.logger.error("Failed to initialize Security Manager:",e),e}}async shutdown(){try{this.keyRotationTimer&&clearInterval(this.keyRotationTimer),this.config.audit.enabled&&await this.finalizeAuditLogs(),this.config.blockchain.enabled&&await this.secureBlockchainState(),this.emit("security-shutdown"),this.logger.info("Security Manager shut down successfully")}catch(e){throw this.logger.error("Error during security shutdown:",e),e}}async encryptData(e,t,r){try{const i=await this.getOrCreateKey(t,"encryption"),s=crypto.getRandomValues(new Uint8Array(12)),a=(new TextEncoder).encode(JSON.stringify(e)),n=await crypto.subtle.encrypt({name:this.config.encryption.algorithm,iv:s},i.cryptoKey,a),o=new Uint8Array(n),c=Array.from(o).map(e=>e.toString(16).padStart(2,"0")).join(""),l=Array.from(s).map(e=>e.toString(16).padStart(2,"0")).join("");return await this.logSecurityEvent({type:"data-encryption",userId:r?.userId||"system",sessionId:r?.sessionId||"worker",operation:"encrypt",resource:t||"default",dataHash:await this.hashData(e),timestamp:Date.now(),metadata:{algorithm:this.config.encryption.algorithm}}),{encryptedData:c,keyId:i.id,algorithm:this.config.encryption.algorithm,iv:l,metadata:r}}catch(e){throw this.logger.error("Encryption failed:",e),new Error(`Encryption failed: ${e instanceof Error?e.message:"Unknown error"}`)}}async decryptData(e,t,r,i){try{const s=await this.getKey(t);if(!s)throw new Error(`Encryption key not found: ${t}`);const a=new Uint8Array(r.match(/.{2}/g).map(e=>parseInt(e,16))),n=new Uint8Array(e.match(/.{2}/g).map(e=>parseInt(e,16))),o=await crypto.subtle.decrypt({name:this.config.encryption.algorithm,iv:a},s.cryptoKey,n),c=(new TextDecoder).decode(o),l=JSON.parse(c);return await this.logSecurityEvent({type:"data-decryption",userId:i?.userId||"system",sessionId:i?.sessionId||"worker",operation:"decrypt",resource:t,dataHash:await this.hashData(l),timestamp:Date.now(),metadata:{algorithm:this.config.encryption.algorithm}}),l}catch(e){throw this.logger.error("Decryption failed:",e),await this.logSecurityEvent({type:"data-decryption",userId:i?.userId||"system",sessionId:i?.sessionId||"worker",operation:"decrypt",resource:t,dataHash:"unknown",timestamp:Date.now(),metadata:{algorithm:this.config.encryption.algorithm}}),new Error(`Decryption failed: ${e instanceof Error?e.message:"Unknown error"}`)}}async signData(e,t){try{const r=await this.getOrCreateKey(t,"signing"),i=(new TextEncoder).encode(JSON.stringify(e)),s=await crypto.subtle.sign("ECDSA",r.cryptoKey,i);return{signature:Array.from(new Uint8Array(s)).map(e=>e.toString(16).padStart(2,"0")).join(""),keyId:r.id,algorithm:"ECDSA",timestamp:Date.now()}}catch(e){throw this.logger.error("Data signing failed:",e),e}}async verifySignature(e,t,r){try{const i=await this.getKey(r);if(!i)return!1;const s=(new TextEncoder).encode(JSON.stringify(e)),a=new Uint8Array(t.match(/.{2}/g).map(e=>parseInt(e,16))),n=await crypto.subtle.verify("ECDSA",i.cryptoKey,a,s);return await this.logSecurityEvent({type:"signature-verification",userId:"system",sessionId:"worker",operation:"verify",resource:r,dataHash:await this.hashData(e),timestamp:Date.now(),metadata:{signatureValid:n,algorithm:"ECDSA"}}),n}catch(e){return this.logger.error("Signature verification failed:",e),!1}}async createSecurityBlock(e){if(!this.config.blockchain.enabled)throw new Error("Blockchain is not enabled");try{const t=this.blockchain[this.blockchain.length-1],r=await this.calculateMerkleRoot(e),i={index:this.blockchain.length,timestamp:Date.now(),previousHash:t?t.hash:"0".repeat(64),merkleRoot:r,nonce:0,difficulty:this.config.blockchain.difficulty,transactions:e,hash:"",validator:await this.selectValidator()};"PoW"===this.config.blockchain.consensusAlgorithm&&await this.mineBlock(i),i.hash=await this.calculateBlockHash(i);const s=await this.signData(i);i.signature=s.signature,this.blockchain.push(i);if(!await this.verifyBlockchain())throw new Error("Blockchain integrity verification failed");return this.emit("security-block-created",{block:i}),this.logger.info(`Security block ${i.index} created with ${e.length} transactions`),i}catch(e){throw this.logger.error("Failed to create security block:",e),e}}async verifyBlockchain(){try{for(let e=1;e<this.blockchain.length;e++){const t=this.blockchain[e],r=this.blockchain[e-1];if(!t||!r)return this.logger.error(`Block ${e} or previous block not found`),!1;const i=await this.calculateBlockHash(t);if(t.hash!==i)return this.logger.error(`Block ${e} hash verification failed`),!1;if(t.previousHash!==r.hash)return this.logger.error(`Block ${e} previous hash link broken`),!1;const s=await this.calculateMerkleRoot(t.transactions);if(t.merkleRoot!==s)return this.logger.error(`Block ${e} merkle root verification failed`),!1;if(t.signature){if(!await this.verifySignature({...t,signature:void 0},t.signature,"blockchain-validator"))return this.logger.error(`Block ${e} signature verification failed`),!1}}return!0}catch(e){return this.logger.error("Blockchain verification failed:",e),!1}}async authorizeOperation(e,t,r,i){try{const s=await this.calculateRiskScore(e,t,r,i),a=this.determineSecurityLevel(s,t,r),n=await this.checkAuthorization(e,t,r,a),o=this.isAuditRequired(t,r,a);return await this.logSecurityEvent({type:"authorization",userId:e,sessionId:i?.sessionId||"unknown",operation:t,resource:r,dataHash:i?.dataHash||"unknown",timestamp:Date.now(),metadata:{authorized:n,riskScore:s,securityLevel:a,auditRequired:o}}),{authorized:n,riskScore:s,securityLevel:a,restrictions:n?[]:["insufficient-permissions"],auditRequired:o}}catch(e){throw this.logger.error("Authorization failed:",e),e}}async verifyDataIntegrity(e,t){try{const r=await this.hashData(e),i=r===t;return await this.logSecurityEvent({type:"data-integrity-check",userId:"system",sessionId:"worker",operation:"verify",resource:"data-integrity",dataHash:r,timestamp:Date.now(),metadata:{expectedHash:t,actualHash:r,isValid:i}}),i}catch(e){return this.logger.error("Data integrity verification failed:",e),!1}}async createDataChecksum(e){try{const t=await this.hashData(e),r=await this.signData({hash:t,timestamp:Date.now()});return{hash:t,algorithm:"SHA-256",timestamp:Date.now(),signature:r.signature}}catch(e){throw this.logger.error("Checksum creation failed:",e),e}}async executeOperation(e){const t=Date.now();try{const r=await this.authorizeOperation(e.metadata?.userId||"anonymous",e.operation,e.payload?.resource||"unknown",e.metadata);if(!r.authorized)throw new Error("Operation not authorized");let i;switch(e.operation){case"encrypt":i=await this.encryptData(e.payload.data,e.payload.keyId,e.metadata);break;case"decrypt":i=await this.decryptData(e.payload.encryptedData,e.payload.keyId,e.payload.iv,e.metadata);break;case"sign":i=await this.signData(e.payload.data,e.payload.keyId);break;case"verify":i=await this.verifySignature(e.payload.data,e.payload.signature,e.payload.keyId);break;case"secure-transaction":i=await this.createSecureTransaction(e.payload.operations);break;case"audit-query":i=await this.queryAuditLogs(e.payload.filter,e.payload.options);break;default:throw new Error(`Unknown security operation: ${e.operation}`)}return r.auditRequired&&await this.createAuditLog({userId:e.metadata?.userId||"anonymous",sessionId:e.metadata?.sessionId||"worker",operation:e.operation,resource:e.payload?.resource||"unknown",result:"success",riskScore:r.riskScore,securityLevel:r.securityLevel,metadata:{ipAddress:e.metadata?.ipAddress||"unknown",userAgent:e.metadata?.userAgent||"worker",executionTime:Date.now()-t}}),i}catch(r){throw await this.createAuditLog({userId:e.metadata?.userId||"anonymous",sessionId:e.metadata?.sessionId||"worker",operation:e.operation,resource:e.payload?.resource||"unknown",result:"failure",riskScore:10,securityLevel:"critical",metadata:{ipAddress:e.metadata?.ipAddress||"unknown",userAgent:e.metadata?.userAgent||"worker",error:r instanceof Error?r.message:"Unknown error",executionTime:Date.now()-t}}),r}}async initializeCryptography(){if(!crypto||!crypto.subtle)throw new Error("Web Crypto API is not available");await this.getOrCreateKey("default","encryption"),await this.getOrCreateKey("default","signing"),this.logger.info("Cryptography initialized")}async initializeBlockchain(){if(0===this.blockchain.length){const e={index:0,timestamp:Date.now(),previousHash:"0".repeat(64),merkleRoot:"0".repeat(64),nonce:0,difficulty:this.config.blockchain.difficulty,transactions:[],hash:""};e.hash=await this.calculateBlockHash(e),this.blockchain.push(e)}this.logger.info("Blockchain initialized with genesis block")}async initializeAuditSystem(){setInterval(()=>{this.rotateAuditLogs()},864e5),this.logger.info("Audit system initialized")}async initializeComplianceMonitoring(){this.complianceMonitor={frameworks:this.config.compliance.frameworks,violations:[],lastCheck:new Date},setInterval(()=>{this.performComplianceCheck()},36e5),this.logger.info("Compliance monitoring initialized")}async getOrCreateKey(e,t="encryption"){const r=e||"default",i=this.cryptoKeys.get(r);if(i&&!this.isKeyExpired(i))return{id:r,cryptoKey:i.cryptoKey};let s;if("encryption"===t)s=await crypto.subtle.generateKey({name:this.config.encryption.algorithm,length:this.config.encryption.keySize},!1,["encrypt","decrypt"]);else{s=(await crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!1,["sign","verify"])).privateKey}const a={id:r,algorithm:"encryption"===t?this.config.encryption.algorithm:"ECDSA",keySize:this.config.encryption.keySize,purpose:t,createdAt:new Date,expiresAt:new Date(Date.now()+this.config.encryption.keyRotationInterval),rotationCount:0,metadata:{},cryptoKey:s};return this.cryptoKeys.set(r,a),this.emit("key-created",{keyId:r,purpose:t}),{id:r,cryptoKey:s}}async getKey(e){return this.cryptoKeys.get(e)}isKeyExpired(e){return!!e.expiresAt&&new Date>e.expiresAt}async hashData(e){const t=new TextEncoder,r=JSON.stringify(e),i=await crypto.subtle.digest("SHA-256",t.encode(r));return Array.from(new Uint8Array(i)).map(e=>e.toString(16).padStart(2,"0")).join("")}async calculateMerkleRoot(e){if(0===e.length)return"0".repeat(64);let t=await Promise.all(e.map(e=>this.hashData(e)));for(;t.length>1;){const e=[];for(let r=0;r<t.length;r+=2){const i=t[r],s=t[r+1]||i;if(i&&s){const t=await this.hashData(i+s);e.push(t)}}t=e}return t[0]||"0".repeat(64)}async calculateBlockHash(e){const t={index:e.index,timestamp:e.timestamp,previousHash:e.previousHash,merkleRoot:e.merkleRoot,nonce:e.nonce};return await this.hashData(t)}async mineBlock(e){const t="0".repeat(this.config.blockchain.difficulty);for(;;){if((await this.calculateBlockHash(e)).substring(0,this.config.blockchain.difficulty)===t)break;if(e.nonce++,e.nonce>1e6){this.logger.warn("Mining taking too long, reducing difficulty");break}}}async selectValidator(){if(0===this.config.blockchain.validatorNodes.length)return"self";const e=Math.floor(Math.random()*this.config.blockchain.validatorNodes.length);return this.config.blockchain.validatorNodes[e]||"self"}async logSecurityEvent(e){const t={id:`tx_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,signature:"",...e},r=await this.signData(t);t.signature=r.signature,this.addTransactionToQueue(t)}addTransactionToQueue(e){const t=this.blockchain[this.blockchain.length-1];(0===this.blockchain.length||t&&t.transactions.length>=this.config.blockchain.blockSize)&&this.createSecurityBlock([e]).catch(e=>{this.logger.error("Failed to create security block:",e)})}async createAuditLog(e){const t={id:`audit_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,timestamp:new Date,...e,integrity:{verified:!1,signature:"",tamperProof:this.config.audit.tamperProof}};if(this.config.audit.tamperProof){const e=await this.signData(t);t.integrity.signature=e.signature,t.integrity.verified=!0}if(this.config.blockchain.enabled){const r={id:`audit_tx_${Date.now()}`,type:"data-access",userId:e.userId,sessionId:e.sessionId,operation:e.operation,resource:e.resource,dataHash:await this.hashData(t),timestamp:Date.now(),metadata:e.metadata,signature:t.integrity.signature};this.addTransactionToQueue(r),t.blockHash="pending"}this.auditLogs.push(t),this.auditLogs.length>1e4&&this.rotateAuditLogs(),this.emit("audit-log-created",t)}async calculateRiskScore(e,t,r,i){let s=0;s+={delete:8,update:5,create:3,read:1}[t]||5;s+=this.riskAssessment.get(e)||0,i?.ipAddress&&this.isUnknownIP(i.ipAddress)&&(s+=3),i?.geolocation&&this.isUnusualLocation(i.geolocation)&&(s+=2);const a=(new Date).getHours();return(a<6||a>22)&&(s+=1),Math.min(s,10)}determineSecurityLevel(e,t,r){return e>=8?"critical":e>=6?"high":e>=3?"medium":"low"}async checkAuthorization(e,t,r,i){return!0}isAuditRequired(e,t,r){return"critical"===r||"high"===r||(!!["delete","update"].includes(e)||"verbose"===this.config.audit.logLevel)}isUnknownIP(e){return!1}isUnusualLocation(e){return!1}async rotateAuditLogs(){const e=24*this.config.audit.retention*60*60*1e3,t=new Date(Date.now()-e);this.auditLogs=this.auditLogs.filter(e=>e.timestamp>t),this.emit("audit-logs-rotated",{retainedLogs:this.auditLogs.length,cutoffDate:t})}async finalizeAuditLogs(){const e={totalLogs:this.auditLogs.length,timeRange:{start:this.auditLogs[0]?.timestamp,end:this.auditLogs[this.auditLogs.length-1]?.timestamp},operationCounts:this.auditLogs.reduce((e,t)=>(e[t.operation]=(e[t.operation]||0)+1,e),{}),securityEvents:this.auditLogs.filter(e=>e.riskScore>=7).length};this.logger.info("Audit summary:",e)}async secureBlockchainState(){if(this.blockchain.length>0){if(!await this.verifyBlockchain())throw this.logger.error("Final blockchain verification failed!"),new Error("Blockchain integrity compromised");this.logger.info(`Blockchain secured with ${this.blockchain.length} blocks`)}}startKeyRotation(){this.keyRotationTimer=setInterval(async()=>{try{await this.rotateKeys()}catch(e){this.logger.error("Key rotation failed:",e)}},this.config.encryption.keyRotationInterval)}async rotateKeys(){for(const[e,t]of this.cryptoKeys)this.isKeyExpired(t)&&(await this.getOrCreateKey(e,"key-derivation"===t.purpose?"encryption":t.purpose),await this.logSecurityEvent({type:"key-rotation",userId:"system",sessionId:"worker",operation:"rotate-key",resource:e,dataHash:"key-rotation",timestamp:Date.now(),metadata:{oldKeyRotationCount:t.rotationCount,newKeyRotationCount:t.rotationCount+1}}),this.emit("key-rotated",{keyId:e,purpose:t.purpose}))}async performComplianceCheck(){const e=[];this.config.compliance.frameworks.includes("GDPR"),this.config.compliance.frameworks.includes("HIPAA"),this.config.compliance.frameworks.includes("SOC2"),this.complianceMonitor.violations=e,this.complianceMonitor.lastCheck=new Date,e.length>0&&(this.emit("compliance-violations",e),this.logger.warn(`${e.length} compliance violations detected`))}async queryAuditLogs(e,t){let r=this.auditLogs;return e&&(r=r.filter(t=>Object.entries(e).every(([e,r])=>t[e]===r))),t?.sort&&r.sort((e,r)=>{const i=e[t.sort.field],s=r[t.sort.field];return"desc"===t.sort.direction?s-i:i-s}),t?.limit&&(r=r.slice(0,t.limit)),r}async createSecureTransaction(e){const t=`secure_tx_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,r={id:t,type:"data-modification",userId:"system",sessionId:"worker",operation:"secure-transaction",resource:"multiple",dataHash:await this.hashData(e),timestamp:Date.now(),metadata:{operationCount:e.length,transactionType:"atomic"},signature:""},i=await this.signData(r);return r.signature=i.signature,this.addTransactionToQueue(r),t}getSecurityMetrics(){return{encryptionEnabled:this.config.encryption.enabled,blockchainEnabled:this.config.blockchain.enabled,totalBlocks:this.blockchain.length,totalTransactions:this.blockchain.reduce((e,t)=>e+t.transactions.length,0),keyCount:this.cryptoKeys.size,auditLogCount:this.auditLogs.length,complianceStatus:this.complianceMonitor,lastKeyRotation:null}}getBlockchain(){return[...this.blockchain]}getAuditLogs(e){return e?this.auditLogs.slice(-e):[...this.auditLogs]}}class J extends S{constructor(e){super(),this.providers=new Map,this.cache=new Map,this.optimisticUpdates=new Map,this.conflictQueue=[],this.operationHistory=new Map,this.config=e,this.logger=new m(!1,"CRUDManager"),this.performanceMetrics={operationsPerSecond:0,averageLatency:0,cacheHitRate:0,conflictRate:0,errorRate:0}}async initialize(){try{this.logger.info("Initializing CRUD Manager...");for(const e of this.config.providers)e.enabled&&await this.initializeProvider(e);this.config.caching.enabled&&await this.initializeCache(),this.startConflictResolutionProcessor(),this.startOptimisticUpdateCleanup(),this.startPerformanceMonitoring(),this.emit("crud-manager-initialized"),this.logger.info("CRUD Manager initialized successfully")}catch(e){throw this.logger.error("Failed to initialize CRUD Manager:",e),e}}async shutdown(){try{await this.processRemainingOptimisticUpdates(),await this.resolveRemainingConflicts();for(const[e,t]of this.providers)try{t.disconnect&&await t.disconnect()}catch(t){this.logger.warn(`Failed to disconnect provider ${e}:`,t)}this.emit("crud-manager-shutdown"),this.logger.info("CRUD Manager shut down successfully")}catch(e){throw this.logger.error("Error during CRUD Manager shutdown:",e),e}}async executeOperation(e){const t=Date.now();try{if(this.validateOperation(e),"read"===e.type&&this.config.caching.enabled){const r=await this.getCachedResult(e);if(r)return{success:!0,data:r,metadata:{provider:"cache",executionTime:Date.now()-t,cacheHit:!0,conflictDetected:!1,consistencyLevel:"cached"}}}e.metadata.optimistic&&["create","update","delete"].includes(e.type)&&await this.applyOptimisticUpdate(e);const r=await this.selectProvider(e),i=await this.executeOnProvider(r,e);return this.config.replication.enabled&&["create","update","delete"].includes(e.type)&&await this.replicateOperation(e,i,r),this.config.caching.enabled&&i.success&&await this.updateCache(e,i.data),e.metadata.optimistic&&await this.confirmOptimisticUpdate(e.id,i),this.updatePerformanceMetrics(e,i,Date.now()-t),this.logOperation(e,i),i}catch(r){this.logger.error("CRUD operation failed:",r),e.metadata.optimistic&&await this.rollbackOptimisticUpdate(e.id);const i={success:!1,error:{code:"CRUD_ERROR",message:r instanceof Error?r.message:"Unknown error",recoverable:this.isRecoverableError(r)},metadata:{provider:e.provider,executionTime:Date.now()-t,cacheHit:!1,conflictDetected:!1,consistencyLevel:"error"}};return this.updatePerformanceMetrics(e,i,Date.now()-t),i}}async executeBatchOperation(e){const t=[],r=new Map;e.forEach(e=>{r.has(e.provider)||r.set(e.provider,[]),r.get(e.provider).push(e)});for(const[e,i]of r)try{const r=this.providers.get(e);if(!r)throw new Error(`Provider ${e} not found`);let s=null;r.beginTransaction&&(s=await r.beginTransaction());try{for(const e of i){const r=await this.executeOperation(e);if(t.push(r),!r.success&&s)throw new Error(`Operation ${e.id} failed in transaction`)}s&&await r.commitTransaction(s)}catch(e){throw s&&await r.rollbackTransaction(s),e}}catch(r){this.logger.error(`Batch operation failed for provider ${e}:`,r),i.forEach(i=>{t.push({success:!1,error:{code:"BATCH_ERROR",message:r instanceof Error?r.message:"Unknown error",recoverable:!1},metadata:{provider:e,executionTime:0,cacheHit:!1,conflictDetected:!1,consistencyLevel:"error"}})})}return this.emit("batch-operation-completed",{operations:e,results:t}),t}async syncData(e,t,r){const i=r||[this.config.defaultProvider],s=[],a={};let n=t;for(const r of i)try{const i=this.providers.get(r);if(!i)continue;const o=await this.executeOnProvider(i,{id:`sync_read_${Date.now()}`,type:"read",provider:r,collection:e,filter:{},metadata:{userId:"system",sessionId:"sync",timestamp:Date.now()}});if(o.success&&o.data){const r=await this.detectConflict(t,o.data,e);if(r){const e=await this.resolveConflict(r,t,o.data);s.push(e),"merged"===e.resolution?n=e.mergedData:"remote"===e.resolution&&(n=o.data)}}const c=await this.executeOnProvider(i,{id:`sync_write_${Date.now()}`,type:"update",provider:r,collection:e,data:n,filter:{},options:{upsert:!0},metadata:{userId:"system",sessionId:"sync",timestamp:Date.now()}});a[r]=c}catch(e){this.logger.error(`Sync failed for provider ${r}:`,e),a[r]={success:!1,error:{code:"SYNC_ERROR",message:e instanceof Error?e.message:"Unknown error",recoverable:!0},metadata:{provider:r,executionTime:0,cacheHit:!1,conflictDetected:!1,consistencyLevel:"error"}}}return this.emit("sync-completed",{storeName:e,conflicts:s,syncResults:a,finalData:n}),{conflicts:s,syncResults:a,finalData:n}}async applyOptimisticUpdate(e){const t={id:e.id,operation:e,localData:e.data,applied:!1,confirmed:!1,timestamp:new Date,ttl:3e4};try{await this.applyLocalUpdate(e),t.applied=!0,this.optimisticUpdates.set(e.id,t),this.emit("optimistic-update-applied",{operation:e,update:t})}catch(e){throw this.logger.error("Failed to apply optimistic update:",e),e}}async confirmOptimisticUpdate(e,t){const r=this.optimisticUpdates.get(e);r&&(t.success?(r.confirmed=!0,this.emit("optimistic-update-confirmed",{operationId:e,result:t})):await this.rollbackOptimisticUpdate(e),this.optimisticUpdates.delete(e))}async rollbackOptimisticUpdate(e){const t=this.optimisticUpdates.get(e);if(t&&t.applied)try{t.rollbackData&&await this.applyLocalUpdate({...t.operation,data:t.rollbackData,type:"create"===t.operation.type?"delete":"update"}),this.emit("optimistic-update-rolled-back",{operationId:e,update:t}),this.optimisticUpdates.delete(e)}catch(e){this.logger.error("Failed to rollback optimistic update:",e)}}async detectConflict(e,t,r){if(!e||!t)return null;const i=e.updatedAt||e.timestamp||0,s=t.updatedAt||t.timestamp||0;if(Math.abs(i-s)<1e3)return null;if(this.config.conflictResolution.vectorClockEnabled){const r=e.vectorClock||{},i=t.vectorClock||{};if("concurrent"===this.compareVectorClocks(r,i))return{conflictId:`conflict_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,operation:{},localVersion:e,remoteVersion:t,resolution:"manual",timestamp:new Date,resolvedBy:"system"}}return this.deepCompare(e,t).length>0?{conflictId:`conflict_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,operation:{},localVersion:e,remoteVersion:t,resolution:"manual",timestamp:new Date,resolvedBy:"system"}:null}async resolveConflict(e,t,r){try{switch(this.config.conflictResolution.strategy){case"last-write-wins":const i=t.updatedAt||t.timestamp||0;(r.updatedAt||r.timestamp||0)>i?(e.resolution="remote",e.mergedData=r):(e.resolution="local",e.mergedData=t);break;case"first-write-wins":const s=t.createdAt||t.timestamp||0;(r.createdAt||r.timestamp||0)<s?(e.resolution="remote",e.mergedData=r):(e.resolution="local",e.mergedData=t);break;case"merge":e.resolution="merged",e.mergedData=await this.mergeData(t,r);break;case"vector-clock":const a=this.compareVectorClocks(t.vectorClock||{},r.vectorClock||{});"local"===a?(e.resolution="local",e.mergedData=t):"remote"===a?(e.resolution="remote",e.mergedData=r):(e.resolution="merged",e.mergedData=await this.mergeData(t,r));break;default:return e.resolution="manual",this.conflictQueue.push(e),e}return e.resolvedBy="auto",this.emit("conflict-resolved",e),e}catch(t){return this.logger.error("Conflict resolution failed:",t),e.resolution="manual",this.conflictQueue.push(e),e}}async initializeProvider(e){try{let t;switch(e.type){case"sql":const{SQLAdapter:r}=await Promise.resolve().then(function(){return it});t=new r(e.config);break;case"nosql":const{NoSQLAdapter:i}=await Promise.resolve().then(function(){return st});t=new i(e.config);break;case"cache":const{RedisCloudAdapter:s}=await Promise.resolve().then(function(){return we});t=new s(e.config);break;default:throw new Error(`Unsupported provider type: ${e.type}`)}await t.connect(),this.providers.set(e.name,t),this.logger.info(`Provider ${e.name} (${e.type}) initialized`)}catch(t){throw this.logger.error(`Failed to initialize provider ${e.name}:`,t),t}}async selectProvider(e){if(e.provider&&this.providers.has(e.provider))return this.providers.get(e.provider);const t=Array.from(this.providers.entries()).filter(([t,r])=>this.isProviderSuitable(r,e)).sort((t,r)=>this.getProviderScore(r[1],e)-this.getProviderScore(t[1],e));if(0===t.length)throw new Error("No suitable provider found for operation");return t[0]?.[1]||this.providers.get(this.config.defaultProvider)}isProviderSuitable(e,t){const r=e.getCapabilities?e.getCapabilities():{};switch(t.type){case"read":return!0;case"create":case"update":case"delete":return!1!==r.supportsWrite;default:return!1}}getProviderScore(e,t){let r=0;const i=this.config.providers.find(t=>t.name===e.name);i&&(r+=i.priority);const s=this.getProviderStats(e.name);return s&&(r+=(100-s.averageLatency)/10,r+=s.successRate),"read"===t.type&&"cache"===e.type&&(r+=10),["create","update","delete"].includes(t.type)&&"sql"===e.type&&(r+=5),r}async executeOnProvider(e,t){const r=Date.now();try{let i;switch(t.type){case"create":if(e.create)i=await e.create(t.collection,t.data);else{if(!e.insert)throw new Error("Provider does not support create operation");i=await e.insert(t.collection,t.data)}break;case"read":if(e.read)i=await e.read(t.collection,t.filter,t.options);else{if(!e.find)throw new Error("Provider does not support read operation");i=await e.find(t.collection,t.filter,t.options)}break;case"update":if(!e.update)throw new Error("Provider does not support update operation");i=await e.update(t.collection,t.filter,t.data,t.options);break;case"delete":if(!e.delete)throw new Error("Provider does not support delete operation");i=await e.delete(t.collection,t.filter,t.options);break;default:throw new Error(`Unsupported operation type: ${t.type}`)}return{success:!0,data:i,metadata:{provider:e.name||"unknown",executionTime:Date.now()-r,cacheHit:!1,conflictDetected:!1,consistencyLevel:this.config.replication.consistency}}}catch(t){return{success:!1,error:{code:"PROVIDER_ERROR",message:t instanceof Error?t.message:"Unknown error",recoverable:this.isRecoverableError(t)},metadata:{provider:e.name||"unknown",executionTime:Date.now()-r,cacheHit:!1,conflictDetected:!1,consistencyLevel:"error"}}}}async initializeCache(){this.providers.get(this.config.caching.provider)?this.logger.info("Cache initialized"):this.logger.warn(`Cache provider ${this.config.caching.provider} not found`)}async getCachedResult(e){const t=this.generateCacheKey(e),r=this.cache.get(t);return r&&Date.now()-r.timestamp<this.config.caching.ttl?(this.emit("cache-hit",{operation:e,cacheKey:t}),r.data):(this.emit("cache-miss",{operation:e,cacheKey:t}),null)}async updateCache(e,t){if("read"!==e.type)return;const r=this.generateCacheKey(e);this.cache.size>=this.config.caching.maxSize&&await this.evictCacheEntries(),this.cache.set(r,{data:t,timestamp:Date.now(),accessCount:1,operation:e}),this.emit("cache-updated",{cacheKey:r,operation:e})}generateCacheKey(e){const t={provider:e.provider,collection:e.collection,filter:e.filter,options:e.options};return`cache_${Buffer.from(JSON.stringify(t)).toString("base64")}`}async evictCacheEntries(){const e=Array.from(this.cache.entries());switch(this.config.caching.evictionPolicy){case"LRU":case"FIFO":e.sort((e,t)=>e[1].timestamp-t[1].timestamp);break;case"LFU":e.sort((e,t)=>e[1].accessCount-t[1].accessCount);break;case"TTL":e.sort((e,t)=>Date.now()-e[1].timestamp-(Date.now()-t[1].timestamp))}const t=Math.floor(.25*e.length);for(let r=0;r<t;r++){const t=e[r];t&&this.cache.delete(t[0])}this.emit("cache-evicted",{removedCount:t})}async applyLocalUpdate(e){this.emit("local-update-applied",{operation:e})}async mergeData(e,t){const r={...t};return Object.keys(e).forEach(i=>{i in t?"object"==typeof e[i]&&"object"==typeof t[i]&&(r[i]=this.mergeObjects(e[i],t[i])):r[i]=e[i]}),r.mergedAt=(new Date).toISOString(),r.mergeStrategy=this.config.conflictResolution.strategy,r}mergeObjects(e,t){const r={...t};return Object.keys(e).forEach(i=>{i in t?Array.isArray(e[i])&&Array.isArray(t[i])&&(r[i]=[...new Set([...t[i],...e[i]])]):r[i]=e[i]}),r}compareVectorClocks(e,t){const r=new Set([...Object.keys(e),...Object.keys(t)]);let i=!1,s=!1;for(const a of r){const r=e[a]||0,n=t[a]||0;r>n?i=!0:n>r&&(s=!0)}return i&&!s?"local":s&&!i?"remote":"concurrent"}deepCompare(e,t){const r=[],i=(e,t,s="")=>{if(typeof e==typeof t)if("object"==typeof e&&null!==e){const a=new Set([...Object.keys(e),...Object.keys(t)]);for(const n of a){const a=s?`${s}.${n}`:n;n in e?n in t?i(e[n],t[n],a):r.push(`${a}: missing in remote`):r.push(`${a}: missing in local`)}}else e!==t&&r.push(`${s}: value mismatch`);else r.push(`${s}: type mismatch`)};return i(e,t),r}validateOperation(e){if(!e.id)throw new Error("Operation ID is required");if(!e.type)throw new Error("Operation type is required");if(!e.collection)throw new Error("Collection name is required");if(["create","update"].includes(e.type)&&!e.data)throw new Error("Data is required for create/update operations");if(["update","delete"].includes(e.type)&&!e.filter)throw new Error("Filter is required for update/delete operations")}isRecoverableError(e){return["NETWORK_ERROR","TIMEOUT","RATE_LIMITED","TEMPORARY_UNAVAILABLE","CONNECTION_LOST"].some(t=>e.message.includes(t)||e.code===t)}async replicateOperation(e,t,r){if(!this.config.replication.enabled)return;const i=Array.from(this.providers.values()).filter(e=>e!==r).slice(0,this.config.replication.factor-1).map(async t=>{try{await this.executeOnProvider(t,{...e,id:`repl_${e.id}_${t.name}`}),this.emit("replication-success",{operation:e,provider:t.name})}catch(r){this.emit("replication-failed",{operation:e,provider:t.name,error:r}),this.logger.warn(`Replication failed for provider ${t.name}:`,r)}});"eventual"===this.config.replication.consistency?Promise.all(i):await Promise.all(i)}startConflictResolutionProcessor(){setInterval(()=>{this.processConflictQueue()},5e3)}async processConflictQueue(){for(;this.conflictQueue.length>0;){const e=this.conflictQueue.shift();try{const t=await this.resolveConflict(e,e.localVersion,e.remoteVersion);"manual"!==t.resolution?this.emit("conflict-auto-resolved",t):this.emit("conflict-requires-manual-resolution",t)}catch(e){this.logger.error("Conflict processing failed:",e)}}}startOptimisticUpdateCleanup(){setInterval(()=>{this.cleanupExpiredOptimisticUpdates()},1e4)}cleanupExpiredOptimisticUpdates(){const e=Date.now();for(const[t,r]of this.optimisticUpdates)e-r.timestamp.getTime()>r.ttl&&(r.confirmed?this.optimisticUpdates.delete(t):this.rollbackOptimisticUpdate(t))}startPerformanceMonitoring(){setInterval(()=>{this.calculatePerformanceMetrics()},6e4)}calculatePerformanceMetrics(){this.emit("performance-metrics-updated",this.performanceMetrics)}updatePerformanceMetrics(e,t,r){}logOperation(e,t){const r=this.operationHistory.get(e.collection)||[];r.push(e),r.length>1e3&&r.shift(),this.operationHistory.set(e.collection,r)}getProviderStats(e){return{averageLatency:100,successRate:95,errorCount:5}}async processRemainingOptimisticUpdates(){for(const[e,t]of this.optimisticUpdates)t.confirmed||await this.rollbackOptimisticUpdate(e)}async resolveRemainingConflicts(){for(;this.conflictQueue.length>0;){const e=this.conflictQueue.shift();e.resolution="remote",this.emit("conflict-force-resolved",e)}}getProviders(){return Array.from(this.providers.keys())}getOperationHistory(e){return e?this.operationHistory.get(e)||[]:Array.from(this.operationHistory.values()).flat()}getOptimisticUpdates(){return Array.from(this.optimisticUpdates.values())}getConflictQueue(){return[...this.conflictQueue]}getPerformanceMetrics(){return{...this.performanceMetrics}}getCacheStats(){return{size:this.cache.size,hitRate:this.performanceMetrics.cacheHitRate,maxSize:this.config.caching.maxSize,evictionPolicy:this.config.caching.evictionPolicy}}getAIProviderStats(){return{totalProviders:this.providers.size,activeProviders:Array.from(this.providers.keys())}}getCloudProviderStats(){return{totalProviders:this.providers.size,activeProviders:Array.from(this.providers.keys())}}}class Q extends S{constructor(e){super(),this.isRunning=!1,this.workerInstance=null,this.messageHandlers=new Map,this.config=e,this.logger=new m(!1,"BrolostackWorker"),this.securityManager=new K({encryption:{enabled:e.security.encryption?.enabled??!0,algorithm:e.security.encryption?.algorithm??"AES-GCM",keySize:e.security.encryption?.keySize??256,keyDerivation:e.security.encryption?.keyDerivation??"PBKDF2",keyRotationInterval:864e5,saltSize:32},blockchain:{enabled:e.security.blockchain?.enabled??!1,networkType:e.security.blockchain?.networkType??"private",consensusAlgorithm:e.security.blockchain?.consensusAlgorithm??"PoW",blockSize:e.security.blockchain?.blockSize??100,difficulty:e.security.blockchain?.difficulty??4,miningReward:10,validatorNodes:[]},authentication:{multiFactorRequired:e.security.authentication?.multiFactorRequired??!1,biometricEnabled:e.security.authentication?.biometricEnabled??!1,sessionTimeout:e.security.authentication?.sessionTimeout??36e5,tokenRotationInterval:e.security.authentication?.tokenRotationInterval??18e5,passwordPolicy:{minLength:8,requireUppercase:!0,requireLowercase:!0,requireNumbers:!0,requireSymbols:!1,preventReuse:5}},audit:{enabled:!0,logLevel:"standard",retention:90,tamperProof:!0,realTimeMonitoring:!0},compliance:{frameworks:["SOC2"],dataClassification:{enabled:!0,levels:["public","internal"],autoClassification:!0},dataResidency:{enabled:!1,allowedRegions:[],crossBorderRestrictions:!1}}}),this.crudManager=new J({providers:e.database.providers.map(e=>({...e,capabilities:["read","write"]})),defaultProvider:e.database.defaultProvider,sharding:{...e.database.sharding,enabled:e.database.sharding?.enabled||!1,strategy:e.database.sharding?.strategy||"hash",shardKey:e.database.sharding?.shardKey||"id",shardCount:4},replication:{...e.database.replication,enabled:e.database.replication?.enabled||!1,factor:e.database.replication?.factor||1,consistency:e.database.replication?.consistency||"strong",readPreference:"primary"},caching:{enabled:!0,provider:"redis",ttl:36e5,maxSize:1e4,evictionPolicy:"LRU"},conflictResolution:{strategy:"last-write-wins",vectorClockEnabled:!1}}),this.syncManager={initialize:async()=>{},executeOperation:async()=>({})},this.networkManager={initialize:async()=>{}},this.operationQueue={pending:[],processing:new Map,completed:new Map,failed:new Map,maxSize:1e4},this.performanceMetrics={operationsPerSecond:0,averageLatency:0,errorRate:0,cacheHitRate:0,lastUpdated:new Date},this.setupMessageHandlers()}async initialize(){try{this.logger.info("Initializing Brolostack Worker..."),await this.securityManager.initialize(),await this.crudManager.initialize(),await this.syncManager.initialize(),await this.networkManager.initialize(),await this.createWorkerInstance(),this.startOperationProcessor(),this.startPerformanceMonitoring(),this.isRunning=!0,this.emit("worker-initialized"),this.logger.info("Brolostack Worker initialized successfully")}catch(e){throw this.logger.error("Failed to initialize Brolostack Worker:",e),e}}async shutdown(){try{this.isRunning=!1,await this.drainOperationQueue(),await Promise.all([this.securityManager.shutdown(),this.crudManager.shutdown(),this.syncManager.shutdown(),this.networkManager.shutdown()]),this.workerInstance&&(this.workerInstance.terminate(),this.workerInstance=null),this.emit("worker-shutdown"),this.logger.info("Brolostack Worker shut down successfully")}catch(e){throw this.logger.error("Error during worker shutdown:",e),e}}async executeOperation(e){const t={id:this.generateOperationId(),timestamp:Date.now(),...e};return new Promise((e,r)=>{this.addToQueue(t);const i=s=>{s.id===t.id&&(this.off("operation-completed",i),this.off("operation-failed",i),s.success?e(s):r(new Error(s.error?.message||"Operation failed")))};this.on("operation-completed",i),this.on("operation-failed",i),setTimeout(()=>{this.off("operation-completed",i),this.off("operation-failed",i),r(new Error("Operation timeout"))},3e4)})}async create(e,t,r,i){return this.executeOperation({type:"crud",operation:"create",payload:{provider:e,collection:t,data:r,options:i},priority:"normal"})}async read(e,t,r,i){return this.executeOperation({type:"crud",operation:"read",payload:{provider:e,collection:t,filter:r,options:i},priority:"normal"})}async update(e,t,r,i,s){return this.executeOperation({type:"crud",operation:"update",payload:{provider:e,collection:t,filter:r,data:i,options:s},priority:"normal"})}async delete(e,t,r,i){return this.executeOperation({type:"crud",operation:"delete",payload:{provider:e,collection:t,filter:r,options:i},priority:"high"})}async startSync(e,t){return(await this.executeOperation({type:"sync",operation:"start",payload:{storeName:e,options:t},priority:"high"})).data.syncId}async stopSync(e){await this.executeOperation({type:"sync",operation:"stop",payload:{syncId:e},priority:"high"})}async forcSync(e,t){await this.executeOperation({type:"sync",operation:"force",payload:{storeName:e,providers:t},priority:"critical"})}async encryptData(e,t){return(await this.executeOperation({type:"security",operation:"encrypt",payload:{data:e,keyId:t},priority:"high"})).data}async decryptData(e,t,r){return(await this.executeOperation({type:"security",operation:"decrypt",payload:{encryptedData:e,keyId:t,iv:r},priority:"high"})).data}async createSecureTransaction(e){return(await this.executeOperation({type:"security",operation:"secure-transaction",payload:{operations:e},priority:"critical"})).data.transactionId}async getOperationMetrics(){return(await this.executeOperation({type:"analytics",operation:"get-metrics",payload:{},priority:"low"})).data}async initializeApplicationTemplate(e,t){return(await this.executeOperation({type:"config",operation:"init-template",payload:{applicationType:e,config:t},priority:"high"})).data}async createWorkerInstance(){if("undefined"==typeof Worker)throw new Error("Web Workers are not supported in this environment");const e=this.generateWorkerScript(),t=new Blob([e],{type:"application/javascript"}),r=URL.createObjectURL(t);this.workerInstance=new Worker(r),this.workerInstance.onmessage=e=>{this.handleWorkerMessage(e.data)},this.workerInstance.onerror=e=>{this.logger.error("Worker error:",e),this.emit("worker-error",e)},this.workerInstance.postMessage({type:"init",config:this.config}),await new Promise((e,t)=>{const r=i=>{"ready"===i.data.type?(this.workerInstance.removeEventListener("message",r),e(void 0)):"init-error"===i.data.type&&(this.workerInstance.removeEventListener("message",r),t(new Error(i.data.error)))};this.workerInstance.addEventListener("message",r)}),URL.revokeObjectURL(r)}generateWorkerScript(){return"\n      // Brolostack Worker Script\n      let securityManager, crudManager, syncManager, networkManager;\n      let operationQueue = [];\n      let isProcessing = false;\n      let config = null;\n\n      // Message handler\n      self.onmessage = async function(event) {\n        const message = event.data;\n        \n        try {\n          switch (message.type) {\n            case 'init':\n              await initializeWorker(message.config);\n              break;\n            case 'operation':\n              await handleOperation(message);\n              break;\n            case 'batch':\n              await handleBatchOperations(message.operations);\n              break;\n            case 'shutdown':\n              await shutdownWorker();\n              break;\n            default:\n              console.warn('Unknown message type:', message.type);\n          }\n        } catch (error) {\n          self.postMessage({\n            type: 'error',\n            id: message.id,\n            error: {\n              code: 'WORKER_ERROR',\n              message: error.message,\n              recoverable: false\n            }\n          });\n        }\n      };\n\n      async function initializeWorker(workerConfig) {\n        try {\n          config = workerConfig;\n          \n          // Initialize managers (simplified for worker environment)\n          securityManager = new WorkerSecurityManager(config.security);\n          crudManager = new WorkerCRUDManager(config.database);\n          syncManager = new WorkerSyncManager(config.realtime);\n          networkManager = new WorkerNetworkManager(config.performance);\n\n          await Promise.all([\n            securityManager.initialize(),\n            crudManager.initialize(),\n            syncManager.initialize(),\n            networkManager.initialize()\n          ]);\n\n          self.postMessage({ type: 'ready' });\n        } catch (error) {\n          self.postMessage({ \n            type: 'init-error', \n            error: error.message \n          });\n        }\n      }\n\n      async function handleOperation(message) {\n        const startTime = Date.now();\n        \n        try {\n          let result;\n          \n          switch (message.type) {\n            case 'crud':\n              result = await crudManager.executeOperation(message);\n              break;\n            case 'sync':\n              result = await syncManager.executeOperation(message);\n              break;\n            case 'security':\n              result = await securityManager.executeOperation(message);\n              break;\n            case 'analytics':\n              result = await getAnalytics(message);\n              break;\n            default:\n              throw new Error('Unknown operation type: ' + message.type);\n          }\n\n          const executionTime = Date.now() - startTime;\n          \n          self.postMessage({\n            type: 'operation-completed',\n            id: message.id,\n            success: true,\n            data: result,\n            metadata: {\n              executionTime,\n              timestamp: Date.now()\n            }\n          });\n\n        } catch (error) {\n          const executionTime = Date.now() - startTime;\n          \n          self.postMessage({\n            type: 'operation-failed',\n            id: message.id,\n            success: false,\n            error: {\n              code: error.code || 'OPERATION_ERROR',\n              message: error.message,\n              recoverable: error.recoverable || false\n            },\n            metadata: {\n              executionTime,\n              timestamp: Date.now()\n            }\n          });\n        }\n      }\n\n      async function handleBatchOperations(operations) {\n        const results = [];\n        \n        for (const operation of operations) {\n          try {\n            const result = await handleOperation(operation);\n            results.push({ success: true, data: result });\n          } catch (error) {\n            results.push({ \n              success: false, \n              error: { message: error.message } \n            });\n          }\n        }\n\n        self.postMessage({\n          type: 'batch-completed',\n          results\n        });\n      }\n\n      // Simplified manager implementations for worker environment\n      class WorkerSecurityManager {\n        constructor(config) {\n          this.config = config;\n        }\n\n        async initialize() {\n          // Initialize cryptographic functions\n          if (this.config.encryption.enabled) {\n            await this.initializeCrypto();\n          }\n          \n          if (this.config.blockchain.enabled) {\n            await this.initializeBlockchain();\n          }\n        }\n\n        async executeOperation(message) {\n          switch (message.operation) {\n            case 'encrypt':\n              return await this.encryptData(message.payload.data, message.payload.keyId);\n            case 'decrypt':\n              return await this.decryptData(message.payload.encryptedData, message.payload.keyId, message.payload.iv);\n            case 'secure-transaction':\n              return await this.createSecureTransaction(message.payload.operations);\n            default:\n              throw new Error('Unknown security operation: ' + message.operation);\n          }\n        }\n\n        async initializeCrypto() {\n          // Initialize Web Crypto API\n          this.crypto = self.crypto;\n        }\n\n        async initializeBlockchain() {\n          // Initialize blockchain-like verification system\n          this.blockchain = new WorkerBlockchain(this.config.blockchain);\n        }\n\n        async encryptData(data, keyId) {\n          const key = await this.getOrCreateKey(keyId);\n          const iv = self.crypto.getRandomValues(new Uint8Array(12));\n          const encodedData = new TextEncoder().encode(JSON.stringify(data));\n          \n          const encrypted = await self.crypto.subtle.encrypt(\n            { name: 'AES-GCM', iv },\n            key,\n            encodedData\n          );\n\n          return {\n            encryptedData: Array.from(new Uint8Array(encrypted)).map(b => b.toString(16).padStart(2, '0')).join(''),\n            keyId: keyId || 'default',\n            algorithm: 'AES-GCM',\n            iv: Array.from(iv).map(b => b.toString(16).padStart(2, '0')).join('')\n          };\n        }\n\n        async decryptData(encryptedData, keyId, ivHex) {\n          const key = await this.getKey(keyId);\n          const iv = new Uint8Array(ivHex.match(/.{2}/g).map(byte => parseInt(byte, 16)));\n          const encrypted = new Uint8Array(encryptedData.match(/.{2}/g).map(byte => parseInt(byte, 16)));\n          \n          const decrypted = await self.crypto.subtle.decrypt(\n            { name: 'AES-GCM', iv },\n            key,\n            encrypted\n          );\n\n          const decodedData = new TextDecoder().decode(decrypted);\n          return JSON.parse(decodedData);\n        }\n\n        async getOrCreateKey(keyId) {\n          // Key management implementation\n          return await self.crypto.subtle.generateKey(\n            { name: 'AES-GCM', length: 256 },\n            false,\n            ['encrypt', 'decrypt']\n          );\n        }\n\n        async getKey(keyId) {\n          // Retrieve existing key\n          return await this.getOrCreateKey(keyId);\n        }\n      }\n\n      class WorkerCRUDManager {\n        constructor(config) {\n          this.config = config;\n          this.providers = new Map();\n        }\n\n        async initialize() {\n          // Initialize database providers\n          for (const provider of this.config.providers) {\n            if (provider.enabled) {\n              await this.initializeProvider(provider);\n            }\n          }\n        }\n\n        async executeOperation(message) {\n          const { provider, collection, operation } = message.payload;\n          \n          switch (operation) {\n            case 'create':\n              return await this.create(provider, collection, message.payload.data, message.payload.options);\n            case 'read':\n              return await this.read(provider, collection, message.payload.filter, message.payload.options);\n            case 'update':\n              return await this.update(provider, collection, message.payload.filter, message.payload.data, message.payload.options);\n            case 'delete':\n              return await this.delete(provider, collection, message.payload.filter, message.payload.options);\n            default:\n              throw new Error('Unknown CRUD operation: ' + operation);\n          }\n        }\n\n        async initializeProvider(providerConfig) {\n          // Initialize specific database provider\n          this.providers.set(providerConfig.name, {\n            config: providerConfig,\n            connected: true\n          });\n        }\n\n        async create(provider, collection, data, options) {\n          const endpoint = this.getProviderEndpoint(provider, 'create');\n          \n          const response = await fetch(endpoint, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n              collection,\n              data,\n              options,\n              timestamp: Date.now()\n            })\n          });\n\n          if (!response.ok) {\n            throw new Error('Create operation failed: ' + response.statusText);\n          }\n\n          return await response.json();\n        }\n\n        async read(provider, collection, filter, options) {\n          const endpoint = this.getProviderEndpoint(provider, 'read');\n          const url = new URL(endpoint);\n          \n          if (filter) url.searchParams.set('filter', JSON.stringify(filter));\n          if (options) url.searchParams.set('options', JSON.stringify(options));\n          \n          const response = await fetch(url.toString());\n\n          if (!response.ok) {\n            throw new Error('Read operation failed: ' + response.statusText);\n          }\n\n          return await response.json();\n        }\n\n        async update(provider, collection, filter, data, options) {\n          const endpoint = this.getProviderEndpoint(provider, 'update');\n          \n          const response = await fetch(endpoint, {\n            method: 'PUT',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n              collection,\n              filter,\n              data,\n              options,\n              timestamp: Date.now()\n            })\n          });\n\n          if (!response.ok) {\n            throw new Error('Update operation failed: ' + response.statusText);\n          }\n\n          return await response.json();\n        }\n\n        async delete(provider, collection, filter, options) {\n          const endpoint = this.getProviderEndpoint(provider, 'delete');\n          \n          const response = await fetch(endpoint, {\n            method: 'DELETE',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n              collection,\n              filter,\n              options,\n              timestamp: Date.now()\n            })\n          });\n\n          if (!response.ok) {\n            throw new Error('Delete operation failed: ' + response.statusText);\n          }\n\n          return await response.json();\n        }\n\n        getProviderEndpoint(provider, operation) {\n          const providerConfig = this.providers.get(provider);\n          if (!providerConfig) {\n            throw new Error('Provider not found: ' + provider);\n          }\n          \n          return providerConfig.config.endpoint + '/' + operation;\n        }\n      }\n\n      class WorkerSyncManager {\n        constructor(config) {\n          this.config = config;\n          this.activeSyncs = new Map();\n        }\n\n        async initialize() {\n          // Initialize sync mechanisms\n        }\n\n        async executeOperation(message) {\n          switch (message.operation) {\n            case 'start':\n              return await this.startSync(message.payload.storeName, message.payload.options);\n            case 'stop':\n              return await this.stopSync(message.payload.syncId);\n            case 'force':\n              return await this.forceSync(message.payload.storeName, message.payload.providers);\n            default:\n              throw new Error('Unknown sync operation: ' + message.operation);\n          }\n        }\n\n        async startSync(storeName, options) {\n          const syncId = 'sync_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n          \n          const syncConfig = {\n            id: syncId,\n            storeName,\n            interval: options?.interval || 5000,\n            providers: options?.providers || [config.database.defaultProvider],\n            conflictResolution: options?.conflictResolution || 'server-wins',\n            active: true\n          };\n\n          this.activeSyncs.set(syncId, syncConfig);\n          this.startSyncLoop(syncConfig);\n\n          return { syncId };\n        }\n\n        async stopSync(syncId) {\n          const syncConfig = this.activeSyncs.get(syncId);\n          if (syncConfig) {\n            syncConfig.active = false;\n            this.activeSyncs.delete(syncId);\n          }\n          \n          return { success: true };\n        }\n\n        async forceSync(storeName, providers) {\n          // Force immediate sync across providers\n          const timestamp = Date.now();\n          \n          for (const provider of providers || [config.database.defaultProvider]) {\n            try {\n              await this.syncToProvider(provider, storeName);\n            } catch (error) {\n              console.warn('Force sync failed for provider:', provider, error);\n            }\n          }\n\n          return { success: true, timestamp };\n        }\n\n        startSyncLoop(syncConfig) {\n          const syncInterval = setInterval(async () => {\n            if (!syncConfig.active) {\n              clearInterval(syncInterval);\n              return;\n            }\n\n            try {\n              for (const provider of syncConfig.providers) {\n                await this.syncToProvider(provider, syncConfig.storeName);\n              }\n            } catch (error) {\n              console.error('Sync error:', error);\n            }\n          }, syncConfig.interval);\n        }\n\n        async syncToProvider(provider, storeName) {\n          // Implement actual sync logic\n          const endpoint = this.getProviderSyncEndpoint(provider);\n          \n          const response = await fetch(endpoint, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n              storeName,\n              timestamp: Date.now()\n            })\n          });\n\n          if (!response.ok) {\n            throw new Error('Sync failed: ' + response.statusText);\n          }\n\n          return await response.json();\n        }\n\n        getProviderSyncEndpoint(provider) {\n          return '/api/sync/' + provider;\n        }\n      }\n\n      class WorkerNetworkManager {\n        constructor(config) {\n          this.config = config;\n        }\n\n        async initialize() {\n          // Initialize network optimizations\n        }\n      }\n\n      class WorkerBlockchain {\n        constructor(config) {\n          this.config = config;\n          this.chain = [];\n          this.pendingTransactions = [];\n        }\n\n        async createBlock(transactions) {\n          const previousBlock = this.chain[this.chain.length - 1];\n          const block = {\n            index: this.chain.length,\n            timestamp: Date.now(),\n            transactions,\n            previousHash: previousBlock ? previousBlock.hash : '0',\n            nonce: 0,\n            hash: ''\n          };\n\n          block.hash = await this.calculateHash(block);\n          this.chain.push(block);\n          \n          return block;\n        }\n\n        async calculateHash(block) {\n          const data = JSON.stringify({\n            index: block.index,\n            timestamp: block.timestamp,\n            transactions: block.transactions,\n            previousHash: block.previousHash,\n            nonce: block.nonce\n          });\n\n          const encoder = new TextEncoder();\n          const hashBuffer = await self.crypto.subtle.digest('SHA-256', encoder.encode(data));\n          const hashArray = Array.from(new Uint8Array(hashBuffer));\n          return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n        }\n\n        async verifyChain() {\n          for (let i = 1; i < this.chain.length; i++) {\n            const currentBlock = this.chain[i];\n            const previousBlock = this.chain[i - 1];\n\n            if (currentBlock.hash !== await this.calculateHash(currentBlock)) {\n              return false;\n            }\n\n            if (currentBlock.previousHash !== previousBlock.hash) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n      }\n    "}setupMessageHandlers(){this.messageHandlers.set("crud",async e=>{const t=await this.crudManager.executeOperation({id:e.id,type:e.operation,provider:e.payload.provider,collection:e.payload.collection,data:e.payload.data,filter:e.payload.filter,options:e.payload.options,metadata:{userId:e.metadata?.userId||"unknown",sessionId:e.metadata?.sessionId||"unknown",timestamp:e.timestamp}}),r={id:e.id,success:t.success,data:t.data,metadata:{executionTime:t.metadata.executionTime,provider:t.metadata.provider,cacheHit:t.metadata.cacheHit,timestamp:Date.now()}};return t.error&&(r.error={code:t.error.code,message:t.error.message,details:t.error.message,recoverable:t.error.recoverable}),r}),this.messageHandlers.set("sync",async e=>await this.syncManager.executeOperation(e)),this.messageHandlers.set("security",async e=>await this.securityManager.executeOperation(e)),this.messageHandlers.set("analytics",async e=>await this.getAnalyticsData(e)),this.messageHandlers.set("config",async e=>await this.handleConfigOperation(e))}addToQueue(e){if(this.operationQueue.pending.length>=this.operationQueue.maxSize)throw new Error("Operation queue is full");const t={critical:0,high:1,normal:2,low:3},r=this.operationQueue.pending.findIndex(r=>t[r.priority]>t[e.priority]);-1===r?this.operationQueue.pending.push(e):this.operationQueue.pending.splice(r,0,e),this.emit("operation-queued",{id:e.id,queueSize:this.operationQueue.pending.length})}startOperationProcessor(){(async()=>{for(;this.isRunning;){if(0===this.operationQueue.pending.length){await new Promise(e=>setTimeout(e,100));continue}if(this.operationQueue.processing.size>=this.config.performance.maxConcurrentOperations){await new Promise(e=>setTimeout(e,100));continue}const e=this.operationQueue.pending.shift();this.operationQueue.processing.set(e.id,e),this.processOperationInWorker(e)}})().catch(e=>{this.logger.error("Operation processor error:",e)})}async processOperationInWorker(e){try{if(!this.workerInstance)throw new Error("Worker instance not available");this.workerInstance.postMessage({messageType:"operation",id:e.id,type:e.type,operation:e.operation,payload:e.payload,priority:e.priority,timestamp:e.timestamp,metadata:e.metadata})}catch(t){this.operationQueue.processing.delete(e.id);const r={id:e.id,success:!1,error:{code:"WORKER_ERROR",message:t instanceof Error?t.message:"Unknown error",recoverable:!1},metadata:{executionTime:0,timestamp:Date.now()}};this.operationQueue.failed.set(e.id,r),this.emit("operation-failed",r)}}handleWorkerMessage(e){switch(e.type){case"operation-completed":this.handleOperationCompleted(e);break;case"operation-failed":this.handleOperationFailed(e);break;case"worker-error":this.handleWorkerError(e);break;case"performance-update":this.updatePerformanceMetrics(e.metrics);break;default:this.logger.warn("Unknown worker message type:",e.type)}}handleOperationCompleted(e){this.operationQueue.processing.get(e.id)&&(this.operationQueue.processing.delete(e.id),this.operationQueue.completed.set(e.id,e),this.updatePerformanceMetrics({operationCompleted:!0,executionTime:e.metadata.executionTime,success:!0}),this.emit("operation-completed",e))}handleOperationFailed(e){const t=this.operationQueue.processing.get(e.id);if(t){if(this.operationQueue.processing.delete(e.id),e.error.recoverable&&(t.retryCount||0)<this.config.performance.retryAttempts)return t.retryCount=(t.retryCount||0)+1,void setTimeout(()=>{this.addToQueue(t)},this.calculateRetryDelay(t.retryCount));this.operationQueue.failed.set(e.id,e),this.updatePerformanceMetrics({operationCompleted:!0,executionTime:e.metadata.executionTime,success:!1}),this.emit("operation-failed",e)}}handleWorkerError(e){this.logger.error("Worker error:",e.error),this.emit("worker-error",e)}calculateRetryDelay(e){switch(this.config.performance.retryBackoff){case"linear":return 1e3*e;case"exponential":return 1e3*Math.pow(2,e);default:return 2e3}}async drainOperationQueue(){const e=Date.now();for(;this.operationQueue.processing.size>0&&Date.now()-e<3e4;)await new Promise(e=>setTimeout(e,100));this.operationQueue.processing.size>0&&this.logger.warn(`${this.operationQueue.processing.size} operations still processing during shutdown`)}startPerformanceMonitoring(){setInterval(()=>{this.updatePerformanceMetrics({})},6e4)}updatePerformanceMetrics(e){this.emit("performance-updated",this.performanceMetrics)}async getAnalyticsData(e){return{queueStats:{pending:this.operationQueue.pending.length,processing:this.operationQueue.processing.size,completed:this.operationQueue.completed.size,failed:this.operationQueue.failed.size},performance:this.performanceMetrics,providers:{ai:this.crudManager.getAIProviderStats(),cloud:this.crudManager.getCloudProviderStats()}}}async handleConfigOperation(e){if("init-template"===e.operation)return await this.initializeApplicationTemplate(e.payload.applicationType,e.payload.config);throw new Error("Unknown config operation: "+e.operation)}generateOperationId(){return`op_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}getQueueStats(){return{pending:this.operationQueue.pending.length,processing:this.operationQueue.processing.size,completed:this.operationQueue.completed.size,failed:this.operationQueue.failed.size}}getPerformanceMetrics(){return{...this.performanceMetrics}}isWorkerRunning(){return this.isRunning&&null!==this.workerInstance}getConfig(){return{...this.config}}updateConfig(e){this.config={...this.config,...e},this.workerInstance&&this.workerInstance.postMessage({type:"config-update",config:this.config}),this.emit("config-updated",this.config)}}const W={EMAIL:/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g,PHONE:/(\+?1-?)?(\([0-9]{3}\)|[0-9]{3})[-.\s]?[0-9]{3}[-.\s]?[0-9]{4}/g,SSN:/\b(?:\d{3}-\d{2}-\d{4}|\d{9})\b/g,CREDIT_CARD:/\b(?:\d{4}[-.\s]?){3}\d{4}\b/g,API_KEY:/\b[A-Za-z0-9]{32,}\b/g,PASSWORD:/password["\s]*[:=]["\s]*[^\s"]+/gi,JWT_TOKEN:/eyJ[A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*/g,IP_ADDRESS:/\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b/g,URL:/https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)/g},G=[/(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|EXECUTE|UNION|SCRIPT)\b)/gi,/(\bOR\s+\d+\s*=\s*\d+\b)/gi,/(\bAND\s+\d+\s*=\s*\d+\b)/gi,/('|\"|;|--|\*|\/\*|\*\/)/g],V=[/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,/javascript:/gi,/on\w+\s*=/gi,/<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi,/<object\b[^<]*(?:(?!<\/object>)<[^<]*)*<\/object>/gi],X=[/ignore\s+(previous|all|above|system)\s+(instructions?|prompts?|rules?)/gi,/forget\s+(everything|all|previous)/gi,/act\s+as\s+(a\s+)?(different|another|new)\s+(ai|bot|assistant)/gi,/pretend\s+(to\s+be|you\s+are)/gi,/(roleplay|role\s+play)\s+as/gi,/system\s*:\s*you\s+are\s+now/gi];class Y extends Error{constructor(e,t,r="medium",i){super(e),this.code=t,this.severity=r,this.metadata=i,this.name="SecurityError"}}class Z extends Y{constructor(e,t){super(e,"AUTHENTICATION_ERROR","high",{reason:t}),this.reason=t,this.name="AuthenticationError"}}class ee extends Y{constructor(e,t){super(e,"ENCRYPTION_ERROR","critical",{operation:t}),this.operation=t,this.name="EncryptionError"}}class te extends S{constructor(e={}){super(),this.encryptionKeys=new Map,this.sessions=new Map,this.securityEvents=[],this.rateLimiters=new Map,this.consentRecords=new Map,this.config=this.mergeWithDefaults(e),this.logger=new m(!1,"BrolostackSecurity"),this.initialize()}mergeWithDefaults(e){return{clientSide:{dataEncryption:{enabled:!0,algorithm:"AES-GCM",keySize:256,autoEncryptSensitiveData:!0,sensitiveDataPatterns:["email","phone","ssn","credit_card","password","api_key"],...e.clientSide?.dataEncryption},storageProtection:{encryptLocalStorage:!0,encryptSessionStorage:!0,encryptIndexedDB:!0,storageQuota:52428800,dataRetention:30,...e.clientSide?.storageProtection},inputValidation:{enabled:!0,sanitizeHTML:!0,validateEmails:!0,validatePhoneNumbers:!0,customValidators:{},...e.clientSide?.inputValidation},csrfProtection:{enabled:!0,tokenName:"csrf_token",headerName:"X-CSRF-Token",cookieName:"csrf_token",...e.clientSide?.csrfProtection}},aiSecurity:{promptSanitization:{enabled:!0,blockMaliciousPrompts:!0,maxPromptLength:1e4,bannedKeywords:["ignore","forget","pretend","roleplay","system:","jailbreak"],allowedDomains:[],...e.aiSecurity?.promptSanitization},responseFiltering:{enabled:!0,blockSensitiveInfo:!0,contentModerationLevel:"medium",customFilters:[],...e.aiSecurity?.responseFiltering},rateLimiting:{enabled:!0,maxRequestsPerMinute:60,maxRequestsPerHour:1e3,maxRequestsPerDay:1e4,blockOnExceed:!0,...e.aiSecurity?.rateLimiting},auditLogging:{enabled:!0,logPrompts:!0,logResponses:!1,logUserActions:!0,retentionPeriod:90,...e.aiSecurity?.auditLogging}},authentication:{required:!1,methods:["password"],sessionManagement:{timeout:60,maxConcurrentSessions:5,renewOnActivity:!0},passwordPolicy:{minLength:8,requireUppercase:!0,requireLowercase:!0,requireNumbers:!0,requireSymbols:!1,preventCommonPasswords:!0,preventReuse:5},...e.authentication},privacy:{dataMinimization:!0,consentManagement:{enabled:!0,requiredConsents:["functional","analytics"],consentExpiry:365},dataSubjectRights:{enableDataExport:!0,enableDataDeletion:!0,enableDataPortability:!0},complianceFrameworks:["GDPR"],...e.privacy},monitoring:{threatDetection:{enabled:!0,detectBruteForce:!0,detectAnomalousActivity:!0,detectDataExfiltration:!0},alerting:{enabled:!0,alertThreshold:"medium",notificationChannels:[]},reporting:{enabled:!0,generateDailyReports:!1,generateWeeklyReports:!0,generateMonthlyReports:!0},...e.monitoring}}}async initialize(){try{if(!crypto||!crypto.subtle)throw new Error("Web Crypto API is not available");await this.generateKey("encryption"),this.config.monitoring.threatDetection.enabled&&this.startThreatDetection(),this.config.clientSide.storageProtection.encryptLocalStorage&&this.setupSecureStorage(),this.logger.info("Brolostack Security initialized successfully"),this.emit("security-initialized")}catch(e){throw this.logger.error("Failed to initialize security:",e),new Y("Security initialization failed","INIT_ERROR","critical")}}async encrypt(e,t={}){try{if(!this.config.clientSide.dataEncryption.enabled)throw new ee("Encryption is disabled","encrypt");const r=t.algorithm||this.config.clientSide.dataEncryption.algorithm,i=t.keyId||"default";let s=this.encryptionKeys.get(i);s||(s=await this.generateKey("encryption",{keyId:i}));const a=crypto.getRandomValues(new Uint8Array(12)),n=(new TextEncoder).encode(JSON.stringify(e));if(!s)throw new ee("Encryption key not found","encrypt");const o=await crypto.subtle.encrypt({name:r,iv:a},s,n),c={encryptedData:this.arrayBufferToHex(o),iv:this.arrayBufferToHex(a.buffer),keyId:i,algorithm:r,timestamp:new Date};return await this.logSecurityEvent({type:"encryption_success",severity:"low",source:"client",details:{description:"Data encrypted successfully",metadata:{algorithm:r,keyId:i,dataSize:n.length}},resolved:!0}),c}catch(e){const t=new ee(`Encryption failed: ${e instanceof Error?e.message:"Unknown error"}`,"encrypt");throw await this.logSecurityEvent({type:"encryption_failure",severity:"high",source:"client",details:{description:"Data encryption failed",metadata:{error:e instanceof Error?e.message:"Unknown error"}},resolved:!1}),t}}async decrypt(e){try{const t=this.encryptionKeys.get(e.keyId);if(!t)throw new ee(`Encryption key not found: ${e.keyId}`,"decrypt");const r=this.hexToArrayBuffer(e.iv),i=this.hexToArrayBuffer(e.encryptedData),s=await crypto.subtle.decrypt({name:e.algorithm,iv:r},t,i),a=(new TextDecoder).decode(s);return JSON.parse(a)}catch(t){const r=new ee(`Decryption failed: ${t instanceof Error?t.message:"Unknown error"}`,"decrypt");throw await this.logSecurityEvent({type:"encryption_failure",severity:"high",source:"client",details:{description:"Data decryption failed",metadata:{error:t instanceof Error?t.message:"Unknown error",keyId:e.keyId}},resolved:!1}),r}}async generateKey(e,t={}){try{const r=t.keyId||`${e}_${Date.now()}`;let i;if("encryption"===e)i=await crypto.subtle.generateKey({name:this.config.clientSide.dataEncryption.algorithm,length:this.config.clientSide.dataEncryption.keySize},!1,["encrypt","decrypt"]);else{i=(await crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!1,["sign","verify"])).privateKey}return this.encryptionKeys.set(r,i),this.emit("key-generated",{keyId:r,purpose:e}),{id:r,key:i}}catch(e){throw new ee(`Key generation failed: ${e instanceof Error?e.message:"Unknown error"}`,"generateKey")}}async rotateKey(e){if(!this.encryptionKeys.get(e))throw new ee(`Key not found for rotation: ${e}`,"rotateKey");const t=await this.generateKey("encryption",{keyId:`${e}_rotated`});return this.encryptionKeys.delete(e),this.emit("key-rotated",{oldKeyId:e,newKeyId:t.id}),t}validateInput(e,t){const r={valid:!0,errors:[],warnings:[]};for(const i of t){const t="object"==typeof e?e[i.name]:e;if(!i.required||null!=t&&""!==t){if(i.required||null!=t&&""!==t){if(i.pattern){("string"==typeof i.pattern?new RegExp(i.pattern):i.pattern).test(String(t))||(r.errors.push({field:i.name,message:i.message||`${i.name} format is invalid`,value:t}),r.valid=!1)}i.validator&&!i.validator(t)&&(r.errors.push({field:i.name,message:i.message||`${i.name} validation failed`,value:t}),r.valid=!1)}}else r.errors.push({field:i.name,message:i.message||`${i.name} is required`,value:t}),r.valid=!1}return this.config.clientSide.dataEncryption.autoEncryptSensitiveData&&this.detectSensitiveData(e,r),r}sanitizeHTML(e,t={}){if(!this.config.clientSide.inputValidation.sanitizeHTML)return e;let r=e.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,"").replace(/<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi,"").replace(/<object\b[^<]*(?:(?!<\/object>)<[^<]*)*<\/object>/gi,"").replace(/javascript:/gi,"").replace(/on\w+\s*=/gi,"");return!1!==t.encodeEntities&&(r=r.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#x27;")),r}sanitizeSQL(e){return e.replace(/'/g,"''").replace(/;/g,"").replace(/--/g,"").replace(/\/\*/g,"").replace(/\*\//g,"")}detectXSS(e){for(const t of V)if(t.test(e))return!0;return!1}detectSQLInjection(e){for(const t of G)if(t.test(e))return!0;return!1}async analyzePrompt(e){const t=Date.now(),r={safe:!0,riskScore:0,detectedThreats:[],metadata:{originalLength:e.length,processingTime:0,modelUsed:"rule-based"}};e.length>this.config.aiSecurity.promptSanitization.maxPromptLength&&(r.safe=!1,r.riskScore+=30,r.detectedThreats.push({type:"data_extraction",confidence:.8,description:"Prompt exceeds maximum allowed length",recommendation:"Truncate prompt to allowed length"}));for(const t of this.config.aiSecurity.promptSanitization.bannedKeywords)e.toLowerCase().includes(t.toLowerCase())&&(r.safe=!1,r.riskScore+=20,r.detectedThreats.push({type:"injection",confidence:.7,description:`Contains banned keyword: ${t}`,recommendation:"Remove or replace banned keyword"}));for(const t of X)t.test(e)&&(r.safe=!1,r.riskScore+=40,r.detectedThreats.push({type:"injection",confidence:.9,description:"Potential prompt injection detected",recommendation:"Review and sanitize prompt"}));return!r.safe&&this.config.aiSecurity.promptSanitization.enabled&&(r.sanitizedPrompt=this.sanitizePrompt(e),r.metadata.sanitizedLength=r.sanitizedPrompt.length),r.metadata.processingTime=Date.now()-t,this.config.aiSecurity.auditLogging.enabled&&this.config.aiSecurity.auditLogging.logPrompts&&await this.logSecurityEvent({type:r.safe?"ai_prompt_analyzed":"malicious_prompt",severity:r.safe?"low":"medium",source:"ai",details:{description:"AI prompt analyzed",metadata:{riskScore:r.riskScore,threatCount:r.detectedThreats.length}},resolved:!0}),r}async analyzeResponse(e){const t=Date.now(),r={safe:!0,riskScore:0,detectedIssues:[],metadata:{originalLength:e.length,processingTime:0,contentModerationLevel:this.config.aiSecurity.responseFiltering.contentModerationLevel}};if(this.config.aiSecurity.responseFiltering.blockSensitiveInfo)for(const[t,i]of Object.entries(W))i.test(e)&&(r.safe=!1,r.riskScore+=25,r.detectedIssues.push({type:"sensitive_info",confidence:.8,description:`Contains ${t.toLowerCase()} information`,recommendation:"Remove or mask sensitive information"}));for(const t of this.config.aiSecurity.responseFiltering.customFilters){new RegExp(t.pattern,"gi").test(e)&&(r.riskScore+=15,r.detectedIssues.push({type:"harmful_content",confidence:.7,description:`Matches custom filter: ${t.name}`,recommendation:"block"===t.action?"Block response":"Apply content filter"}),"block"===t.action&&(r.safe=!1))}return!r.safe&&this.config.aiSecurity.responseFiltering.enabled&&(r.filteredResponse=this.filterResponse(e),r.metadata.filteredLength=r.filteredResponse.length),r.metadata.processingTime=Date.now()-t,r}async checkAIUsageLimits(e){const t=Date.now(),r=this.rateLimiters.get(e)||{requests:[],totalRequests:0,flaggedRequests:0,riskScore:0};r.requests=r.requests.filter(e=>t-e<864e5);const i=r.requests.filter(e=>t-e<6e4).length,s=r.requests.filter(e=>t-e<36e5).length,a=r.requests.length,n=this.config.aiSecurity.rateLimiting;if((i>=n.maxRequestsPerMinute||s>=n.maxRequestsPerHour||a>=n.maxRequestsPerDay)&&n.blockOnExceed)throw await this.logSecurityEvent({type:"rate_limit_exceeded",severity:"medium",source:"ai",userId:e,details:{description:"AI usage rate limit exceeded",metadata:{requestsInLastMinute:i,requestsInLastHour:s,requestsInLastDay:a}},resolved:!1}),new Y("Rate limit exceeded","RATE_LIMIT_EXCEEDED","medium");return r.requests.push(t),r.totalRequests++,this.rateLimiters.set(e,r),{userId:e,sessionId:"current",totalRequests:r.totalRequests,requestsInLastMinute:i,requestsInLastHour:s,requestsInLastDay:a,averageResponseTime:150,totalTokensUsed:100*r.totalRequests,riskScore:r.riskScore,flaggedRequests:r.flaggedRequests,lastActivity:new Date}}sanitizePrompt(e){let t=e;for(const e of X)t=t.replace(e,"[REMOVED]");for(const e of this.config.aiSecurity.promptSanitization.bannedKeywords){const r=new RegExp(e,"gi");t=t.replace(r,"[FILTERED]")}return t.length>this.config.aiSecurity.promptSanitization.maxPromptLength&&(t=t.substring(0,this.config.aiSecurity.promptSanitization.maxPromptLength)+"..."),t}filterResponse(e){let t=e;for(const[e,r]of Object.entries(W))t=t.replace(r,`[${e.toUpperCase()}_REMOVED]`);return t}async authenticate(e,t){try{const r={success:!1,metadata:{loginMethod:t,deviceId:this.generateDeviceId(),ipAddress:"unknown",userAgent:navigator.userAgent}};if("password"===t&&e.username&&e.password){if(!this.validatePassword(e.password).valid)throw new Z("Password does not meet policy requirements","WEAK_PASSWORD");r.success=!0,r.userId=`user_${Date.now()}`,r.sessionId=this.generateSessionId(),r.accessToken=this.generateAccessToken(),r.expiresAt=new Date(Date.now()+60*this.config.authentication.sessionManagement.timeout*1e3),r.permissions=["read","write"],r.roles=["user"]}if(r.success){const e=await this.createSession(r.userId,r.metadata);this.sessions.set(r.sessionId,e),await this.logSecurityEvent({type:"authentication_success",severity:"low",source:"auth",userId:r.userId||"unknown",sessionId:r.sessionId||"unknown",details:{description:"User authenticated successfully",metadata:{method:t,deviceId:r.metadata?.deviceId}},resolved:!0})}else await this.logSecurityEvent({type:"authentication_failure",severity:"medium",source:"auth",details:{description:"Authentication failed",metadata:{method:t,username:e.username}},resolved:!0});return r}catch(e){if(e instanceof Z)throw e;throw new Z(`Authentication failed: ${e instanceof Error?e.message:"Unknown error"}`,"AUTH_ERROR")}}async createSession(e,t={}){const r=this.generateSessionId(),i=new Date,s={id:r,userId:e,createdAt:i,lastActivity:i,expiresAt:new Date(i.getTime()+60*this.config.authentication.sessionManagement.timeout*1e3),ipAddress:t.ipAddress||"unknown",userAgent:t.userAgent||"unknown",deviceId:t.deviceId||this.generateDeviceId(),active:!0,permissions:["read"],roles:["user"],securityLevel:"medium",metadata:t};return this.sessions.set(r,s),this.emit("session-created",{sessionId:r,userId:e}),s}async validateSession(e){const t=this.sessions.get(e);return t?t.expiresAt<new Date?(t.active=!1,this.sessions.delete(e),null):(this.config.authentication.sessionManagement.renewOnActivity&&(t.lastActivity=new Date,t.expiresAt=new Date(Date.now()+60*this.config.authentication.sessionManagement.timeout*1e3)),t):null}async revokeSession(e){const t=this.sessions.get(e);return!!t&&(t.active=!1,this.sessions.delete(e),await this.logSecurityEvent({type:"session_revoked",severity:"low",source:"auth",userId:t.userId,sessionId:e,details:{description:"Session revoked",metadata:{reason:"manual_revocation"}},resolved:!0}),this.emit("session-revoked",{sessionId:e,userId:t.userId}),!0)}async renewSession(e){const t=await this.validateSession(e);if(!t)throw new Z("Session not found or expired","SESSION_INVALID");return t.lastActivity=new Date,t.expiresAt=new Date(Date.now()+60*this.config.authentication.sessionManagement.timeout*1e3),t}async recordConsent(e,t,r){const i={userId:e,consentType:t,granted:r,grantedAt:new Date,expiresAt:r?new Date(Date.now()+24*this.config.privacy.consentManagement.consentExpiry*60*60*1e3):new Date(0),version:"1.0",metadata:{ipAddress:"unknown",userAgent:navigator.userAgent,method:"explicit"}},s=this.consentRecords.get(e)||[];return s.push(i),this.consentRecords.set(e,s),this.emit("consent-recorded",{userId:e,consentType:t,granted:r}),i}async checkConsent(e,t){const r=(this.consentRecords.get(e)||[]).filter(e=>e.consentType===t).sort((e,t)=>t.grantedAt.getTime()-e.grantedAt.getTime())[0];return r?r.expiresAt&&r.expiresAt<new Date?null:r.granted?r:null:null}async processDataSubjectRequest(e){const t={id:`dsr_${Date.now()}`,requestedAt:new Date,status:"pending",...e};return await this.logSecurityEvent({type:"data_subject_request",severity:"medium",source:"client",userId:e.userId,details:{description:`Data subject request: ${e.type}`,metadata:{requestType:e.type,requestId:t.id}},resolved:!1}),this.emit("data-subject-request",t),t}async generateComplianceReport(e,t,r){const i=this.securityEvents.filter(e=>e.timestamp>=t&&e.timestamp<=r);return{id:`report_${Date.now()}`,framework:e,generatedAt:new Date,period:{start:t,end:r},summary:{totalUsers:this.sessions.size,totalDataProcessed:i.length,consentRate:85,dataSubjectRequests:i.filter(e=>"data_subject_request"===e.type).length,securityIncidents:i.filter(e=>"high"===e.severity||"critical"===e.severity).length,complianceScore:92},violations:i.filter(e=>e.type.includes("violation")||"critical"===e.severity).map(e=>({type:e.type,severity:e.severity,description:e.details.description,affectedUsers:1,remediation:"Review and address",status:e.resolved?"resolved":"open"})),recommendations:["Implement regular security training","Enhance monitoring capabilities","Review data retention policies"]}}async logSecurityEvent(e){const t={id:`event_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,timestamp:new Date,...e};return this.securityEvents.push(t),this.securityEvents.length>1e4&&(this.securityEvents=this.securityEvents.slice(-5e3)),this.emit("security-event",t),"high"!==e.severity&&"critical"!==e.severity||this.emit("security-alert",t),t}async getSecurityEvents(e={}){let t=[...this.securityEvents];return e.userId&&(t=t.filter(t=>t.userId===e.userId)),e.type&&(t=t.filter(t=>t.type===e.type)),e.severity&&(t=t.filter(t=>t.severity===e.severity)),e.startDate&&(t=t.filter(t=>t.timestamp>=e.startDate)),e.endDate&&(t=t.filter(t=>t.timestamp<=e.endDate)),t.sort((e,t)=>t.timestamp.getTime()-e.timestamp.getTime())}async analyzeSecurityTrends(){const e=this.securityEvents,t=new Date,r=new Date(t.getTime()-864e5),i=new Date(t.getTime()-6048e5),s=e.filter(e=>e.timestamp>=r),a=e.filter(e=>e.timestamp>=i);return{totalEvents:e.length,recentEvents:s.length,weeklyEvents:a.length,criticalEvents:e.filter(e=>"critical"===e.severity).length,topEventTypes:this.getTopEventTypes(e),trendAnalysis:{increasing:s.length>a.length/7,riskLevel:this.calculateRiskLevel(s)}}}async generateSecurityReport(e){const t=this.securityEvents.filter(t=>t.timestamp>=e.start&&t.timestamp<=e.end);return{period:e,generatedAt:new Date,summary:{totalEvents:t.length,criticalEvents:t.filter(e=>"critical"===e.severity).length,highSeverityEvents:t.filter(e=>"high"===e.severity).length,resolvedEvents:t.filter(e=>e.resolved).length,averageResolutionTime:this.calculateAverageResolutionTime(t)},eventBreakdown:this.getEventBreakdown(t),recommendations:this.generateSecurityRecommendations(t)}}async detectBruteForce(e,t){const r=this.securityEvents.filter(r=>"authentication_failure"===r.type&&(r.userId===e||r.details.metadata?.ipAddress===t)&&Date.now()-r.timestamp.getTime()<9e5),i=r.length>=5;return i&&await this.logSecurityEvent({type:"brute_force_attempt",severity:"high",source:"auth",userId:e,details:{description:"Brute force attack detected",metadata:{ipAddress:t,failureCount:r.length}},resolved:!1}),i}async detectAnomalousActivity(e,t){const r=Array.from(this.sessions.values()).filter(t=>t.userId===e),i=r[r.length-1];if(!i)return!1;const s=t.location&&i.metadata?.geolocation?.country!==t.location.country,a=(new Date).getHours(),n=a<6||a>22,o=t.deviceId&&i.deviceId!==t.deviceId,c=s||n&&o;return c&&await this.logSecurityEvent({type:"anomalous_activity",severity:"medium",source:"client",userId:e,details:{description:"Anomalous user activity detected",metadata:{unusualLocation:s,unusualTime:n,unusualDevice:o,activity:t}},resolved:!1}),c}async detectDataExfiltration(e,t){const r=this.securityEvents.filter(t=>t.userId===e&&"data_access"===t.type&&Date.now()-t.timestamp.getTime()<36e5),i=r.length>100||t.size&&t.size>10485760;return i&&await this.logSecurityEvent({type:"data_exfiltration",severity:"critical",source:"client",userId:e,details:{description:"Potential data exfiltration detected",metadata:{accessCount:r.length,dataSize:t.size}},resolved:!1}),i}async calculateRiskScore(e,t){let r=0;const i=this.securityEvents.filter(t=>t.userId===e&&Date.now()-t.timestamp.getTime()<864e5);r+=5*i.length;r+=20*i.filter(e=>"critical"===e.severity||"high"===e.severity).length;return r+=10*i.filter(e=>"authentication_failure"===e.type).length,t.newDevice&&(r+=15),t.unusualLocation&&(r+=20),t.offHours&&(r+=10),t.vpnUsage&&(r+=5),Math.min(r,100)}async secureStore(e,t,r={}){try{const i=this.config.clientSide.storageProtection;let s=t;if(!1!==r.encrypt&&i.encryptLocalStorage){s=await this.encrypt(t)}r.compress&&(s=JSON.stringify(s));const a={value:s,timestamp:Date.now(),ttl:r.ttl,namespace:r.namespace||"default",encrypted:!1!==r.encrypt&&i.encryptLocalStorage};return localStorage.setItem(e,JSON.stringify(a)),!0}catch(e){return this.logger.error("Secure storage failed:",e),!1}}async secureRetrieve(e,t={}){try{const t=localStorage.getItem(e);if(!t)return null;const r=JSON.parse(t);if(r.ttl&&Date.now()-r.timestamp>r.ttl)return localStorage.removeItem(e),null;let i=r.value;return r.encrypted&&(i=await this.decrypt(i)),i}catch(e){return this.logger.error("Secure retrieval failed:",e),null}}async secureDelete(e,t={}){try{return localStorage.removeItem(e),!0}catch(e){return this.logger.error("Secure deletion failed:",e),!1}}async clearSecureStorage(){try{return localStorage.clear(),!0}catch(e){return this.logger.error("Clear secure storage failed:",e),!1}}detectSensitiveData(e,t){const r=JSON.stringify(e);for(const[e,i]of Object.entries(W))i.test(r)&&t.warnings.push({field:"data",message:`Sensitive ${e.toLowerCase()} data detected`,value:"redacted"})}validatePassword(e){const t=this.config.authentication.passwordPolicy,r={valid:!0,errors:[],warnings:[]};return e.length<t.minLength&&(r.valid=!1,r.errors.push({field:"password",message:`Password must be at least ${t.minLength} characters`,value:"redacted"})),t.requireUppercase&&!/[A-Z]/.test(e)&&(r.valid=!1,r.errors.push({field:"password",message:"Password must contain uppercase letters",value:"redacted"})),t.requireLowercase&&!/[a-z]/.test(e)&&(r.valid=!1,r.errors.push({field:"password",message:"Password must contain lowercase letters",value:"redacted"})),t.requireNumbers&&!/\d/.test(e)&&(r.valid=!1,r.errors.push({field:"password",message:"Password must contain numbers",value:"redacted"})),t.requireSymbols&&!/[!@#$%^&*(),.?":{}|<>]/.test(e)&&(r.valid=!1,r.errors.push({field:"password",message:"Password must contain symbols",value:"redacted"})),r}setupSecureStorage(){const e=localStorage.setItem.bind(localStorage),t=localStorage.getItem.bind(localStorage);localStorage.setItem=(t,r)=>{this.config.clientSide.storageProtection.encryptLocalStorage?this.secureStore(t,r):e(t,r)},localStorage.getItem=e=>(this.config.clientSide.storageProtection.encryptLocalStorage,t(e))}startThreatDetection(){setInterval(async()=>{for(const[e,t]of this.rateLimiters){const r=Date.now(),i=t.requests.filter(e=>r-e<6e4).length;i>.8*this.config.aiSecurity.rateLimiting.maxRequestsPerMinute&&await this.logSecurityEvent({type:"suspicious_ai_usage",severity:"medium",source:"ai",userId:e,details:{description:"Suspicious AI usage pattern detected",metadata:{requestsPerMinute:i}},resolved:!1})}},6e4)}generateSessionId(){return`session_${Date.now()}_${Math.random().toString(36).substr(2,16)}`}generateDeviceId(){const e=document.createElement("canvas"),t=e.getContext("2d");t?.fillText("device-fingerprint",10,10);const r=[navigator.userAgent,navigator.language,screen.width,screen.height,(new Date).getTimezoneOffset(),e.toDataURL()].join("|");return btoa(r).substr(0,32)}generateAccessToken(){return`token_${Date.now()}_${Math.random().toString(36).substr(2,32)}`}arrayBufferToHex(e){return Array.from(new Uint8Array(e)).map(e=>e.toString(16).padStart(2,"0")).join("")}hexToArrayBuffer(e){const t=new Uint8Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=parseInt(e.substr(r,2),16);return t.buffer}getTopEventTypes(e){const t={};return e.forEach(e=>{t[e.type]=(t[e.type]||0)+1}),Object.entries(t).sort(([,e],[,t])=>t-e).slice(0,5).map(([e,t])=>({type:e,count:t}))}calculateRiskLevel(e){const t=e.filter(e=>"critical"===e.severity).length,r=e.filter(e=>"high"===e.severity).length;return t>0?"critical":r>2?"high":e.length>10?"medium":"low"}calculateAverageResolutionTime(e){const t=e.filter(e=>e.resolved&&e.resolvedAt);if(0===t.length)return 0;return t.reduce((e,t)=>e+(t.resolvedAt.getTime()-t.timestamp.getTime()),0)/t.length/1e3/60}getEventBreakdown(e){const t={};return e.forEach(e=>{t[e.type]=(t[e.type]||0)+1}),t}generateSecurityRecommendations(e){const t=[],r=new Set(e.map(e=>e.type));return r.has("brute_force_attempt")&&t.push("Implement stronger rate limiting for authentication"),r.has("malicious_prompt")&&t.push("Enhance AI prompt filtering rules"),r.has("data_exfiltration")&&t.push("Review data access patterns and implement DLP controls"),e.filter(e=>"critical"===e.severity).length>0&&t.push("Conduct immediate security review of critical events"),t}getConfig(){return{...this.config}}updateConfig(e){this.config={...this.config,...e},this.emit("config-updated",this.config)}getSecurityStatus(){const e=this.securityEvents.filter(e=>Date.now()-e.timestamp.getTime()<864e5);return{encryptionEnabled:this.config.clientSide.dataEncryption.enabled,activeSessions:this.sessions.size,recentEvents:e.length,riskLevel:this.calculateRiskLevel(e),complianceStatus:this.config.privacy.complianceFrameworks.length>0?"enabled":"disabled"}}}class re extends S{constructor(e){super(),this.config=e,this.logger=new m(!1,`${e.provider}Adapter`)}}class ie extends re{async generateText(e,t){const r=await fetch("https://api.deepseek.com/v1/chat/completions",{method:"POST",headers:{Authorization:`Bearer ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({model:t.model||"deepseek-chat",messages:[{role:"user",content:e}],temperature:t.temperature||.7,max_tokens:t.maxTokens||1e3})});if(!r.ok)throw new Error(`DeepSeek API error: ${r.statusText}`);const i=await r.json();return{content:i.choices[0].message.content,usage:i.usage,model:t.model||"deepseek-chat",provider:"deepseek",timestamp:new Date}}async streamCompletion(e,t,r){throw new Error("Streaming not yet implemented for DeepSeek")}async generateEmbedding(e,t){throw new Error("Embeddings not yet implemented for DeepSeek")}async chatCompletion(e,t){const r=await fetch("https://api.deepseek.com/v1/chat/completions",{method:"POST",headers:{Authorization:`Bearer ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({model:t.model||"deepseek-chat",messages:e,temperature:t.temperature||.7,max_tokens:t.maxTokens||1e3})});if(!r.ok)throw new Error(`DeepSeek API error: ${r.statusText}`);const i=await r.json();return{content:i.choices[0].message.content,usage:i.usage,model:t.model||"deepseek-chat",provider:"deepseek",timestamp:new Date}}getCapabilities(){return{textGeneration:!0,chatCompletion:!0,streaming:!1,embedding:!1,imageGeneration:!1,audioGeneration:!1,audioTranscription:!1,imageAnalysis:!1,functionCalling:!0,fineTuning:!1,multimodal:!1,maxContextLength:16e3,supportedLanguages:["en"]}}async healthCheck(){try{const e=await fetch("https://api.deepseek.com/v1/models",{method:"GET",headers:{Authorization:`Bearer ${this.config.apiKey}`}});if(!e.ok)throw new Error(`DeepSeek health check failed: ${e.statusText}`)}catch(e){throw new Error(`DeepSeek health check failed: ${e instanceof Error?e.message:"Unknown error"}`)}}}class se extends re{async generateText(e,t){const r=await fetch("https://api.perplexity.ai/chat/completions",{method:"POST",headers:{Authorization:`Bearer ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({model:t.model,messages:[{role:"user",content:e}],max_tokens:t.maxTokens||2e3,temperature:t.temperature||.7})});if(!r.ok)throw new Error(`Perplexity API error: ${r.statusText}`);const i=await r.json();return{content:i.choices[0].message.content,usage:i.usage,model:t.model,provider:"perplexity",timestamp:new Date}}async chatCompletion(e,t){const r=await fetch("https://api.perplexity.ai/chat/completions",{method:"POST",headers:{Authorization:`Bearer ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({model:t.model,messages:e,max_tokens:t.maxTokens||2e3,temperature:t.temperature||.7})});if(!r.ok)throw new Error(`Perplexity API error: ${r.statusText}`);const i=await r.json();return{content:i.choices[0].message.content,usage:i.usage,model:t.model,provider:"perplexity",timestamp:new Date}}async streamCompletion(e,t,r){throw new Error("Streaming not supported by Perplexity")}async generateEmbedding(e,t){throw new Error("Embeddings not supported by Perplexity")}getCapabilities(){return{textGeneration:!0,chatCompletion:!0,imageGeneration:!1,imageAnalysis:!1,audioGeneration:!1,audioTranscription:!1,embedding:!1,fineTuning:!1,streaming:!1,functionCalling:!1,multimodal:!1,maxContextLength:16e3,supportedLanguages:["en"]}}async healthCheck(){await this.generateText("test",this.config)}}class ae extends re{async generateText(e,t){const r=await fetch(`${t.endpoint}/v1/generate`,{method:"POST",headers:{Authorization:`Bearer ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({model_id:t.model,input:e,parameters:{max_new_tokens:t.maxTokens||2e3,temperature:t.temperature||.7}})});if(!r.ok)throw new Error(`IBM Watson API error: ${r.statusText}`);return{content:(await r.json()).results[0].generated_text,model:t.model,provider:"ibm-watson",timestamp:new Date}}async chatCompletion(e,t){return this.generateText(e.map(e=>e.content).join("\n"),t)}async streamCompletion(e,t,r){throw new Error("Streaming not yet implemented for IBM Watson")}async generateEmbedding(e,t){const r=await fetch(`${t.endpoint}/v1/embeddings`,{method:"POST",headers:{Authorization:`Bearer ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({model_id:"ibm/slate-125m-english-rtrvr",inputs:[e]})});if(!r.ok)throw new Error(`IBM Watson API error: ${r.statusText}`);return{embedding:(await r.json()).results[0].embedding,model:"ibm/slate-125m-english-rtrvr"}}getCapabilities(){return{textGeneration:!0,chatCompletion:!0,imageGeneration:!1,imageAnalysis:!0,audioGeneration:!1,audioTranscription:!0,embedding:!0,fineTuning:!0,streaming:!1,functionCalling:!1,multimodal:!0,maxContextLength:8192,supportedLanguages:["en","es","fr","de","it","pt","ja","ko","zh"]}}async healthCheck(){await this.generateText("test",this.config)}}class ne extends re{async generateText(e,t){const r=await fetch("https://api.minimax.chat/v1/text/chatcompletion_pro",{method:"POST",headers:{Authorization:`Bearer ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({model:t.model,messages:[{sender_type:"USER",text:e}],tokens_to_generate:t.maxTokens||2e3,temperature:t.temperature||.7})});if(!r.ok)throw new Error(`MiniMax API error: ${r.statusText}`);const i=await r.json();return{content:i.reply,usage:i.usage,model:t.model,provider:"minimax",timestamp:new Date}}async chatCompletion(e,t){const r=e.map(e=>({sender_type:"user"===e.role?"USER":"BOT",text:e.content})),i=await fetch("https://api.minimax.chat/v1/text/chatcompletion_pro",{method:"POST",headers:{Authorization:`Bearer ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({model:t.model,messages:r,tokens_to_generate:t.maxTokens||2e3,temperature:t.temperature||.7})});if(!i.ok)throw new Error(`MiniMax API error: ${i.statusText}`);const s=await i.json();return{content:s.reply,usage:s.usage,model:t.model,provider:"minimax",timestamp:new Date}}async streamCompletion(e,t,r){throw new Error("Streaming not yet implemented for MiniMax")}async generateEmbedding(e,t){const r=await fetch("https://api.minimax.chat/v1/embeddings",{method:"POST",headers:{Authorization:`Bearer ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({model:"embo-01",texts:[e],type:"db"})});if(!r.ok)throw new Error(`MiniMax API error: ${r.statusText}`);return{embedding:(await r.json()).vectors[0],model:"embo-01"}}getCapabilities(){return{textGeneration:!0,chatCompletion:!0,imageGeneration:!1,imageAnalysis:!1,audioGeneration:!1,audioTranscription:!1,embedding:!0,fineTuning:!1,streaming:!1,functionCalling:!1,multimodal:!1,maxContextLength:245760,supportedLanguages:["en","zh"]}}async healthCheck(){await this.generateText("test",this.config)}}class oe extends re{async generateText(e,t){const r=await fetch(`${t.endpoint}/serving-endpoints/${t.model}/invocations`,{method:"POST",headers:{Authorization:`Bearer ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({inputs:{prompt:e,max_tokens:t.maxTokens||2e3,temperature:t.temperature||.7}})});if(!r.ok)throw new Error(`Databricks API error: ${r.statusText}`);return{content:(await r.json()).predictions[0].output,model:t.model,provider:"databricks",timestamp:new Date}}async chatCompletion(e,t){return this.generateText(e.map(e=>e.content).join("\n"),t)}async streamCompletion(e,t,r){throw new Error("Streaming not yet implemented for Databricks")}async generateEmbedding(e,t){const r=await fetch(`${t.endpoint}/serving-endpoints/embedding-model/invocations`,{method:"POST",headers:{Authorization:`Bearer ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({inputs:{text:e}})});if(!r.ok)throw new Error(`Databricks API error: ${r.statusText}`);return{embedding:(await r.json()).predictions[0].embedding,model:"databricks-embedding"}}getCapabilities(){return{textGeneration:!0,chatCompletion:!0,imageGeneration:!1,imageAnalysis:!1,audioGeneration:!1,audioTranscription:!1,embedding:!0,fineTuning:!0,streaming:!1,functionCalling:!1,multimodal:!1,maxContextLength:32e3,supportedLanguages:["en"]}}async healthCheck(){await this.generateText("test",this.config)}}class ce extends re{async generateText(e,t){const r=await fetch("https://api.x.ai/v1/chat/completions",{method:"POST",headers:{Authorization:`Bearer ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({model:t.model,messages:[{role:"user",content:e}],max_tokens:t.maxTokens||2e3,temperature:t.temperature||.7})});if(!r.ok)throw new Error(`xAI API error: ${r.statusText}`);const i=await r.json();return{content:i.choices[0].message.content,usage:i.usage,model:t.model,provider:"xai",timestamp:new Date}}async chatCompletion(e,t){const r=await fetch("https://api.x.ai/v1/chat/completions",{method:"POST",headers:{Authorization:`Bearer ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({model:t.model,messages:e,max_tokens:t.maxTokens||2e3,temperature:t.temperature||.7})});if(!r.ok)throw new Error(`xAI API error: ${r.statusText}`);const i=await r.json();return{content:i.choices[0].message.content,usage:i.usage,model:t.model,provider:"xai",timestamp:new Date}}async streamCompletion(e,t,r){const i=await fetch("https://api.x.ai/v1/chat/completions",{method:"POST",headers:{Authorization:`Bearer ${r.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({model:r.model,messages:[{role:"user",content:e}],max_tokens:r.maxTokens||2e3,temperature:r.temperature||.7,stream:!0})});if(!i.ok)throw new Error(`xAI API error: ${i.statusText}`);const s=i.body?.getReader(),a=new TextDecoder;for(;s;){const{done:e,value:r}=await s.read();if(e)break;const i=a.decode(r).split("\n").filter(e=>e.trim());for(const e of i)if(e.startsWith("data: ")){const r=e.slice(6);if("[DONE]"===r)break;try{const e=JSON.parse(r),i=e.choices[0]?.delta?.content;i&&t(i)}catch(e){}}}}async generateEmbedding(e,t){throw new Error("Embeddings not yet supported by xAI")}getCapabilities(){return{textGeneration:!0,chatCompletion:!0,imageGeneration:!1,imageAnalysis:!1,audioGeneration:!1,audioTranscription:!1,embedding:!1,fineTuning:!1,streaming:!0,functionCalling:!0,multimodal:!1,maxContextLength:131072,supportedLanguages:["en"]}}async healthCheck(){await this.generateText("test",this.config)}}class le extends re{async generateText(e,t){const r=await fetch("https://api.clarifai.com/v2/models/predictions",{method:"POST",headers:{Authorization:`Key ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({inputs:[{data:{text:{raw:e}}}],model:{id:t.model}})});if(!r.ok)throw new Error(`Clarifai API error: ${r.statusText}`);return{content:(await r.json()).outputs[0].data.text.raw,model:t.model,provider:"clarifai",timestamp:new Date}}async chatCompletion(e,t){return this.generateText(e.map(e=>e.content).join("\n"),t)}async streamCompletion(e,t,r){throw new Error("Streaming not yet implemented for Clarifai")}async generateEmbedding(e,t){const r=await fetch("https://api.clarifai.com/v2/models/predictions",{method:"POST",headers:{Authorization:`Key ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({inputs:[{data:{text:{raw:e}}}],model:{id:"text-embedding-ada"}})});if(!r.ok)throw new Error(`Clarifai API error: ${r.statusText}`);return{embedding:(await r.json()).outputs[0].data.embeddings[0].vector,model:"text-embedding-ada"}}async analyzeImage(e,t){const r="string"==typeof e?e:await this.blobToBase64(e),i=await fetch("https://api.clarifai.com/v2/models/predictions",{method:"POST",headers:{Authorization:`Key ${this.config.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({inputs:[{data:{image:{base64:r},text:t?{raw:t}:void 0}}],model:{id:"general-image-recognition"}})});if(!i.ok)throw new Error(`Clarifai API error: ${i.statusText}`);return await i.json()}getCapabilities(){return{textGeneration:!0,chatCompletion:!0,imageGeneration:!0,imageAnalysis:!0,audioGeneration:!1,audioTranscription:!0,embedding:!0,fineTuning:!0,streaming:!1,functionCalling:!1,multimodal:!0,maxContextLength:8192,supportedLanguages:["en","es","fr","de","it","pt","ru","ja","ko","zh"]}}async healthCheck(){await this.generateText("test",this.config)}async blobToBase64(e){return new Promise((t,r)=>{const i=new FileReader;i.onload=()=>{const e=i.result.split(",")[1];t(e||"")},i.onerror=r,i.readAsDataURL(e)})}}class he extends re{async generateText(e,t){const r=await fetch("https://api.together.xyz/v1/completions",{method:"POST",headers:{Authorization:`Bearer ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({model:t.model,prompt:e,max_tokens:t.maxTokens||2e3,temperature:t.temperature||.7})});if(!r.ok)throw new Error(`Together AI API error: ${r.statusText}`);const i=await r.json();return{content:i.choices[0].text,usage:i.usage,model:t.model,provider:"together-ai",timestamp:new Date}}async chatCompletion(e,t){const r=await fetch("https://api.together.xyz/v1/chat/completions",{method:"POST",headers:{Authorization:`Bearer ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({model:t.model,messages:e,max_tokens:t.maxTokens||2e3,temperature:t.temperature||.7})});if(!r.ok)throw new Error(`Together AI API error: ${r.statusText}`);const i=await r.json();return{content:i.choices[0].message.content,usage:i.usage,model:t.model,provider:"together-ai",timestamp:new Date}}async streamCompletion(e,t,r){const i=await fetch("https://api.together.xyz/v1/chat/completions",{method:"POST",headers:{Authorization:`Bearer ${r.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({model:r.model,messages:[{role:"user",content:e}],max_tokens:r.maxTokens||2e3,temperature:r.temperature||.7,stream:!0})});if(!i.ok)throw new Error(`Together AI API error: ${i.statusText}`);const s=i.body?.getReader(),a=new TextDecoder;for(;s;){const{done:e,value:r}=await s.read();if(e)break;const i=a.decode(r).split("\n").filter(e=>e.trim());for(const e of i)if(e.startsWith("data: ")){const r=e.slice(6);if("[DONE]"===r)break;try{const e=JSON.parse(r),i=e.choices[0]?.delta?.content;i&&t(i)}catch(e){}}}}async generateEmbedding(e,t){throw new Error("Embeddings not supported by Together AI base API")}getCapabilities(){return{textGeneration:!0,chatCompletion:!0,imageGeneration:!0,imageAnalysis:!1,audioGeneration:!1,audioTranscription:!1,embedding:!1,fineTuning:!0,streaming:!0,functionCalling:!1,multimodal:!1,maxContextLength:32768,supportedLanguages:["en"]}}async healthCheck(){await this.generateText("test",this.config)}}class de extends re{async generateText(e,t){const r=await fetch(`https://api.nlpcloud.io/v1/${t.model}/generation`,{method:"POST",headers:{Authorization:`Token ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({text:e,max_length:t.maxTokens||2e3,temperature:t.temperature||.7})});if(!r.ok)throw new Error(`NLP Cloud API error: ${r.statusText}`);return{content:(await r.json()).generated_text,model:t.model,provider:"nlp-cloud",timestamp:new Date}}async chatCompletion(e,t){const r=await fetch(`https://api.nlpcloud.io/v1/${t.model}/chatbot`,{method:"POST",headers:{Authorization:`Token ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({input:e[e.length-1].content,history:e.slice(0,-1).map(e=>e.content),max_length:t.maxTokens||2e3,temperature:t.temperature||.7})});if(!r.ok)throw new Error(`NLP Cloud API error: ${r.statusText}`);return{content:(await r.json()).response,model:t.model,provider:"nlp-cloud",timestamp:new Date}}async streamCompletion(e,t,r){throw new Error("Streaming not supported by NLP Cloud")}async generateEmbedding(e,t){const r=await fetch("https://api.nlpcloud.io/v1/paraphrase-multilingual-mpnet-base-v2/embeddings",{method:"POST",headers:{Authorization:`Token ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({sentences:[e]})});if(!r.ok)throw new Error(`NLP Cloud API error: ${r.statusText}`);return{embedding:(await r.json()).embeddings[0],model:"paraphrase-multilingual-mpnet-base-v2"}}getCapabilities(){return{textGeneration:!0,chatCompletion:!0,imageGeneration:!1,imageAnalysis:!1,audioGeneration:!1,audioTranscription:!1,embedding:!0,fineTuning:!1,streaming:!1,functionCalling:!1,multimodal:!1,maxContextLength:2048,supportedLanguages:["en","es","fr","de","it","pt","ru","ja","ko","zh","ar","hi"]}}async healthCheck(){await this.generateText("test",this.config)}}class ue extends re{async generateText(e,t){const r=await fetch(`${t.endpoint||"https://api.aimlapi.com"}/chat/completions`,{method:"POST",headers:{Authorization:`Bearer ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({model:t.model,messages:[{role:"user",content:e}],max_tokens:t.maxTokens||2e3,temperature:t.temperature||.7})});if(!r.ok)throw new Error(`AIMLAPI error: ${r.statusText}`);const i=await r.json();return{content:i.choices[0].message.content,usage:i.usage,model:t.model,provider:"aimlapi",timestamp:new Date}}async chatCompletion(e,t){const r=await fetch(`${t.endpoint||"https://api.aimlapi.com"}/chat/completions`,{method:"POST",headers:{Authorization:`Bearer ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({model:t.model,messages:e,max_tokens:t.maxTokens||2e3,temperature:t.temperature||.7})});if(!r.ok)throw new Error(`AIMLAPI error: ${r.statusText}`);const i=await r.json();return{content:i.choices[0].message.content,usage:i.usage,model:t.model,provider:"aimlapi",timestamp:new Date}}async streamCompletion(e,t,r){const i=await fetch(`${r.endpoint||"https://api.aimlapi.com"}/chat/completions`,{method:"POST",headers:{Authorization:`Bearer ${r.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({model:r.model,messages:[{role:"user",content:e}],max_tokens:r.maxTokens||2e3,temperature:r.temperature||.7,stream:!0})});if(!i.ok)throw new Error(`AIMLAPI error: ${i.statusText}`);const s=i.body?.getReader(),a=new TextDecoder;for(;s;){const{done:e,value:r}=await s.read();if(e)break;const i=a.decode(r).split("\n").filter(e=>e.trim());for(const e of i)if(e.startsWith("data: ")){const r=e.slice(6);if("[DONE]"===r)break;try{const e=JSON.parse(r),i=e.choices[0]?.delta?.content;i&&t(i)}catch(e){}}}}async generateEmbedding(e,t){const r=await fetch(`${t.endpoint||"https://api.aimlapi.com"}/embeddings`,{method:"POST",headers:{Authorization:`Bearer ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({model:"text-embedding-ada-002",input:e})});if(!r.ok)throw new Error(`AIMLAPI error: ${r.statusText}`);const i=await r.json();return{embedding:i.data[0].embedding,model:"text-embedding-ada-002",usage:i.usage}}getCapabilities(){return{textGeneration:!0,chatCompletion:!0,imageGeneration:!0,imageAnalysis:!0,audioGeneration:!0,audioTranscription:!0,embedding:!0,fineTuning:!0,streaming:!0,functionCalling:!0,multimodal:!0,maxContextLength:128e3,supportedLanguages:["en","es","fr","de","it","pt","ru","ja","ko","zh"]}}async healthCheck(){await this.generateText("test",this.config)}}class pe extends S{constructor(){super(),this.providers=new Map,this.configs=new Map,this.logger=new m(!1,"AIProviderFactory")}registerProvider(e){const t=this.createProviderAdapter(e);this.providers.set(e.provider,t),this.configs.set(e.provider,e),this.emit("provider-registered",{provider:e.provider,config:e}),this.logger.info(`Registered AI provider: ${e.provider}`)}unregisterProvider(e){this.providers.delete(e),this.configs.delete(e),this.emit("provider-unregistered",{provider:e}),this.logger.info(`Unregistered AI provider: ${e}`)}async generateText(e,t,r){const i=this.getProvider(e),s=this.mergeConfig(e,r);try{const r=await i.generateText(t,s);return this.emit("text-generated",{provider:e,prompt:t,response:r}),r}catch(r){throw this.emit("text-generation-failed",{provider:e,prompt:t,error:r}),r}}async chatCompletion(e,t,r){const i=this.getProvider(e),s=this.mergeConfig(e,r);try{const r=await i.chatCompletion(t,s);return this.emit("chat-completed",{provider:e,messages:t,response:r}),r}catch(r){throw this.emit("chat-completion-failed",{provider:e,messages:t,error:r}),r}}async streamCompletion(e,t,r,i){const s=this.getProvider(e),a=this.mergeConfig(e,{...i,streaming:!0});try{await s.streamCompletion(t,r,a),this.emit("stream-completed",{provider:e,prompt:t})}catch(r){throw this.emit("stream-failed",{provider:e,prompt:t,error:r}),r}}async generateEmbedding(e,t,r){const i=this.getProvider(e),s=this.mergeConfig(e,r);try{const r=await i.generateEmbedding(t,s);return this.emit("embedding-generated",{provider:e,text:t,response:r}),r}catch(r){throw this.emit("embedding-failed",{provider:e,text:t,error:r}),r}}async generateImage(e,t,r){const i=this.getProvider(e);if(!i.generateImage)throw new Error(`Provider ${e} does not support image generation`);try{const s=await i.generateImage(t,r);return this.emit("image-generated",{provider:e,prompt:t,response:s}),s}catch(r){throw this.emit("image-generation-failed",{provider:e,prompt:t,error:r}),r}}createProviderAdapter(e){switch(e.provider){case"openai":case"azure-ai":case"aws-bedrock":case"huggingface":case"stability-ai":case"cohere":case"mistral":case"replicate":return new me(e);case"anthropic":return new ge(e);case"google-cloud-ai":return new ye(e);case"deepseek":return new ie(e);case"perplexity":return new se(e);case"ibm-watson":return new ae(e);case"minimax":return new ne(e);case"databricks":return new oe(e);case"xai":return new ce(e);case"clarifai":return new le(e);case"together-ai":return new he(e);case"nlp-cloud":return new de(e);case"aimlapi":return new ue(e);default:throw new Error(`Unsupported AI provider: ${e.provider}`)}}getProvider(e){const t=this.providers.get(e);if(!t)throw new Error(`Provider ${e} is not registered`);return t}mergeConfig(e,t){const r=this.configs.get(e);if(!r)throw new Error(`Provider ${e} is not registered`);return{...r,...t}}getRegisteredProviders(){return Array.from(this.providers.keys())}getProviderCapabilities(e){return this.getProvider(e).getCapabilities()}getProviderConfig(e){const t=this.configs.get(e);if(!t)throw new Error(`Provider ${e} is not registered`);return{...t}}async testProvider(e){try{const t=this.getProvider(e);return await t.healthCheck(),!0}catch(t){return this.logger.error(`Provider ${e} health check failed:`,t),!1}}getStats(){return{registeredProviders:this.providers.size,providers:Array.from(this.providers.keys())}}}class me extends re{async generateText(e,t){const r=await fetch("https://api.openai.com/v1/completions",{method:"POST",headers:{Authorization:`Bearer ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({model:t.model,prompt:e,max_tokens:t.maxTokens||2e3,temperature:t.temperature||.7})});if(!r.ok)throw new Error(`OpenAI API error: ${r.statusText}`);const i=await r.json();return{content:i.choices[0].text,usage:i.usage,model:t.model,provider:"openai",timestamp:new Date}}async streamCompletion(e,t,r){throw new Error("Streaming not implemented for basic OpenAI adapter")}async generateEmbedding(e,t){throw new Error("Embeddings not implemented for basic OpenAI adapter")}async chatCompletion(e,t){const r=await fetch("https://api.openai.com/v1/chat/completions",{method:"POST",headers:{Authorization:`Bearer ${t.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({model:t.model,messages:e,temperature:t.temperature||.7,max_tokens:t.maxTokens||2e3})});if(!r.ok)throw new Error(`OpenAI API error: ${r.statusText}`);const i=await r.json();return{content:i.choices[0].message.content,usage:i.usage,model:t.model,provider:"openai",timestamp:new Date}}getCapabilities(){return{textGeneration:!0,chatCompletion:!0,imageGeneration:!1,imageAnalysis:!1,audioGeneration:!1,audioTranscription:!1,embedding:!1,fineTuning:!1,streaming:!1,functionCalling:!0,multimodal:!1,maxContextLength:4096,supportedLanguages:["en"]}}async healthCheck(){const e=await fetch("https://api.openai.com/v1/models",{method:"GET",headers:{Authorization:`Bearer ${this.config.apiKey}`}});if(!e.ok)throw new Error(`OpenAI health check failed: ${e.statusText}`)}}class ge extends re{async generateText(e,t){return{content:`Anthropic response to: ${e}`,model:t.model,provider:"anthropic",timestamp:new Date}}async streamCompletion(e,t,r){throw new Error("Streaming not implemented for basic Anthropic adapter")}async generateEmbedding(e,t){throw new Error("Embeddings not implemented for basic Anthropic adapter")}async chatCompletion(e,t){return{content:"Anthropic chat response",model:t.model,provider:"anthropic",timestamp:new Date}}getCapabilities(){return{textGeneration:!0,chatCompletion:!0,imageGeneration:!1,imageAnalysis:!1,audioGeneration:!1,audioTranscription:!1,embedding:!1,fineTuning:!1,streaming:!1,functionCalling:!1,multimodal:!1,maxContextLength:1e5,supportedLanguages:["en"]}}async healthCheck(){}}class ye extends re{async generateText(e,t){return{content:`Google Cloud AI response to: ${e}`,model:t.model,provider:"google-cloud-ai",timestamp:new Date}}async streamCompletion(e,t,r){throw new Error("Streaming not implemented for basic Google Cloud AI adapter")}async generateEmbedding(e,t){throw new Error("Embeddings not implemented for basic Google Cloud AI adapter")}async chatCompletion(e,t){return{content:"Google Cloud AI chat response",model:t.model,provider:"google-cloud-ai",timestamp:new Date}}getCapabilities(){return{textGeneration:!0,chatCompletion:!0,imageGeneration:!1,imageAnalysis:!1,audioGeneration:!1,audioTranscription:!1,embedding:!1,fineTuning:!1,streaming:!1,functionCalling:!1,multimodal:!1,maxContextLength:8192,supportedLanguages:["en"]}}async healthCheck(){}}class fe extends S{constructor(e){super(),this.name="redis-cloud",this.provider="Redis Cloud",this.connected=!1,this.errorCount=0,this.config={database:0,tls:!0,poolSize:10,retryAttempts:3,retryDelay:1e3,commandTimeout:5e3,...e},this.logger=new m(!1,"RedisCloudAdapter")}async connect(){try{await this.executeCommand("PING"),this.connected=!0,this.emit("connected",{adapter:this.name}),this.logger.info("Connected to Redis Cloud")}catch(e){throw this.errorCount++,this.lastError=e instanceof Error?e.message:"Connection failed",this.emit("error",{error:e,adapter:this.name}),e}}async disconnect(){try{await this.executeCommand("QUIT")}catch(e){this.logger.warn("Error during disconnect:",e)}this.connected=!1,this.emit("disconnected",{adapter:this.name}),this.logger.info("Disconnected from Redis Cloud")}isConnected(){return this.connected}async sync(e){if(!this.connected)throw new Error("Redis Cloud adapter is not connected");try{const t="brolostack:sync:data",r=JSON.stringify(e);await this.executeCommand("SET",t,r),await this.executeCommand("EXPIRE",t,86400),this.lastSync=new Date,this.emit("sync-completed",{data:e,adapter:this.name})}catch(e){throw this.errorCount++,this.lastError=e instanceof Error?e.message:"Sync failed",this.emit("sync-failed",{error:e,adapter:this.name}),e}}async backup(e){if(!this.connected)throw new Error("Redis Cloud adapter is not connected");try{const t=`brolostack:backup:${Date.now()}`,r=JSON.stringify({data:e,timestamp:(new Date).toISOString(),checksum:this.generateChecksum(e)});await this.executeCommand("SET",t,r),await this.executeCommand("ZADD","brolostack:backup:index",Date.now(),t),await this.executeCommand("ZREMRANGEBYRANK","brolostack:backup:index",0,-101),this.lastBackup=new Date,this.emit("backup-completed",{data:e,backupKey:t,adapter:this.name})}catch(e){throw this.errorCount++,this.lastError=e instanceof Error?e.message:"Backup failed",this.emit("backup-failed",{error:e,adapter:this.name}),e}}async restore(){if(!this.connected)throw new Error("Redis Cloud adapter is not connected");try{const e="brolostack:sync:data",t=await this.executeCommand("GET",e);if(!t)throw new Error("No sync data found");const r=JSON.parse(t);return this.emit("restore-completed",{data:r,adapter:this.name}),r}catch(e){throw this.errorCount++,this.lastError=e instanceof Error?e.message:"Restore failed",this.emit("restore-failed",{error:e,adapter:this.name}),e}}async syncStore(e,t){if(!this.connected)throw new Error("Redis Cloud adapter is not connected");try{const r=`brolostack:store:${e}`,i=JSON.stringify(t);await this.executeCommand("SET",r,i),await this.executeCommand("EXPIRE",r,86400),this.emit("store-sync-completed",{storeName:e,data:t,adapter:this.name})}catch(t){throw this.errorCount++,this.lastError=t instanceof Error?t.message:"Store sync failed",this.emit("store-sync-failed",{storeName:e,error:t,adapter:this.name}),t}}async restoreStore(e){if(!this.connected)throw new Error("Redis Cloud adapter is not connected");try{const t=`brolostack:store:${e}`,r=await this.executeCommand("GET",t);if(!r)return null;const i=JSON.parse(r);return this.emit("store-restore-completed",{storeName:e,data:i,adapter:this.name}),i}catch(t){throw this.errorCount++,this.lastError=t instanceof Error?t.message:"Store restore failed",this.emit("store-restore-failed",{storeName:e,error:t,adapter:this.name}),t}}async set(e,t,r){const i="string"==typeof t?t:JSON.stringify(t);r?await this.executeCommand("SETEX",e,r,i):await this.executeCommand("SET",e,i)}async get(e){const t=await this.executeCommand("GET",e);if(!t)return null;try{return JSON.parse(t)}catch{return t}}async delete(e){return 1===await this.executeCommand("DEL",e)}async exists(e){return 1===await this.executeCommand("EXISTS",e)}async expire(e,t){return 1===await this.executeCommand("EXPIRE",e,t)}async hset(e,t,r){const i="string"==typeof r?r:JSON.stringify(r);await this.executeCommand("HSET",e,t,i)}async hget(e,t){const r=await this.executeCommand("HGET",e,t);if(!r)return null;try{return JSON.parse(r)}catch{return r}}async hgetall(e){const t=await this.executeCommand("HGETALL",e),r={};for(let e=0;e<t.length;e+=2){const i=t[e],s=t[e+1];try{r[i]=JSON.parse(s)}catch{r[i]=s}}return r}async lpush(e,...t){const r=t.map(e=>"string"==typeof e?e:JSON.stringify(e));return await this.executeCommand("LPUSH",e,...r)}async rpush(e,...t){const r=t.map(e=>"string"==typeof e?e:JSON.stringify(e));return await this.executeCommand("RPUSH",e,...r)}async lpop(e){const t=await this.executeCommand("LPOP",e);if(!t)return null;try{return JSON.parse(t)}catch{return t}}async lrange(e,t,r){return(await this.executeCommand("LRANGE",e,t,r)).map(e=>{try{return JSON.parse(e)}catch{return e}})}async sadd(e,...t){const r=t.map(e=>"string"==typeof e?e:JSON.stringify(e));return await this.executeCommand("SADD",e,...r)}async smembers(e){return(await this.executeCommand("SMEMBERS",e)).map(e=>{try{return JSON.parse(e)}catch{return e}})}async publish(e,t){const r="string"==typeof t?t:JSON.stringify(t);return await this.executeCommand("PUBLISH",e,r)}async subscribe(e,t){this.emit("subscribed",{channel:e})}async xadd(e,t){const r=["*"];return Object.entries(t).forEach(([e,t])=>{r.push(e),r.push("string"==typeof t?t:JSON.stringify(t))}),await this.executeCommand("XADD",e,...r)}async xread(e,t,r){const i=[];return t&&i.push("COUNT",t),void 0!==r&&i.push("BLOCK",r),i.push("STREAMS"),Object.entries(e).forEach(([e,t])=>{i.push(e)}),Object.values(e).forEach(e=>{i.push(e)}),await this.executeCommand("XREAD",...i)}async getInfo(){const e=await this.executeCommand("INFO"),t={};return e.split("\r\n\r\n").forEach(e=>{const r=e.split("\r\n"),i=r[0],s=i?i.replace("# ",""):"unknown";t[s]={},r.slice(1).forEach(e=>{if(e.includes(":")){const[r,i]=e.split(":");s&&r&&(t[s][r]=isNaN(Number(i))?i:Number(i))}})}),t}async getMemoryUsage(){const e=(await this.getInfo()).Memory||{};return{used:e.used_memory||0,peak:e.used_memory_peak||0,total:e.total_system_memory||0,available:e.available_memory||0,fragmentation:e.mem_fragmentation_ratio||1}}async executeCommand(e,...t){try{const r=await fetch(`${this.getRedisEndpoint()}/command`,{method:"POST",headers:{"Content-Type":"application/json",Authorization:this.getAuthHeader()},body:JSON.stringify({command:e,args:t,database:this.config.database}),signal:AbortSignal.timeout(this.config.commandTimeout)});if(!r.ok)throw new Error(`Redis command failed: ${r.statusText}`);return(await r.json()).data}catch(t){throw this.logger.error(`Redis command failed: ${e}`,t),t}}getRedisEndpoint(){return`${this.config.tls?"https":"http"}://${this.config.host}:${this.config.port}`}getAuthHeader(){if(this.config.username&&this.config.password){return`Basic ${btoa(`${this.config.username}:${this.config.password}`)}`}return this.config.password?`Bearer ${this.config.password}`:""}generateChecksum(e){const t=JSON.stringify(e);let r=0;for(let e=0;e<t.length;e++){r=(r<<5)-r+t.charCodeAt(e),r&=r}return r.toString(16)}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this.errorCount,lastError:this.lastError??void 0}}getCapabilities(){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!0,maxDataSize:536870912,supportedFormats:["json","string","binary"]}}}var we=Object.freeze({__proto__:null,RedisCloudAdapter:fe});class ke extends S{constructor(e){super(),this.name="mongodb-atlas",this.provider="MongoDB Atlas",this.connected=!1,this.errorCount=0,this.config={collectionPrefix:"brolostack_",options:{maxPoolSize:10,minPoolSize:2,maxIdleTimeMS:3e4,serverSelectionTimeoutMS:5e3,socketTimeoutMS:45e3,retryWrites:!0,retryReads:!0,readPreference:"primaryPreferred"},...e},this.logger=new m(!1,"MongoDBAtlasAdapter")}async connect(){try{await this.executeQuery({collection:"test",operation:"findOne",filter:{_id:"connection_test"}}),this.connected=!0,this.emit("connected",{adapter:this.name}),this.logger.info("Connected to MongoDB Atlas")}catch(e){throw this.errorCount++,this.lastError=e instanceof Error?e.message:"Connection failed",this.emit("error",{error:e,adapter:this.name}),e}}async disconnect(){this.connected=!1,this.emit("disconnected",{adapter:this.name}),this.logger.info("Disconnected from MongoDB Atlas")}isConnected(){return this.connected}async sync(e){if(!this.connected)throw new Error("MongoDB Atlas adapter is not connected");try{const t=`${this.config.collectionPrefix}sync`;await this.executeQuery({collection:t,operation:"insertOne",document:{data:e,timestamp:new Date,checksum:this.generateChecksum(e),type:"sync"}}),await this.executeQuery({collection:t,operation:"deleteMany",filter:{type:"sync",timestamp:{$lt:new Date(Date.now()-864e5)}}}),this.lastSync=new Date,this.emit("sync-completed",{data:e,adapter:this.name})}catch(e){throw this.errorCount++,this.lastError=e instanceof Error?e.message:"Sync failed",this.emit("sync-failed",{error:e,adapter:this.name}),e}}async backup(e){if(!this.connected)throw new Error("MongoDB Atlas adapter is not connected");try{const t=`${this.config.collectionPrefix}backups`,r={data:e,timestamp:new Date,checksum:this.generateChecksum(e),size:JSON.stringify(e).length,type:"backup",id:`backup_${Date.now()}`};await this.executeQuery({collection:t,operation:"insertOne",document:r});const i=await this.countDocuments(t,{type:"backup"});if(i>100){const e=(await this.executeQuery({collection:t,operation:"find",filter:{type:"backup"},options:{sort:{timestamp:1},limit:i-100,projection:{_id:1}}})).map(e=>e._id);await this.executeQuery({collection:t,operation:"deleteMany",filter:{_id:{$in:e}}})}this.lastBackup=new Date,this.emit("backup-completed",{data:e,backupId:r.id,adapter:this.name})}catch(e){throw this.errorCount++,this.lastError=e instanceof Error?e.message:"Backup failed",this.emit("backup-failed",{error:e,adapter:this.name}),e}}async restore(){if(!this.connected)throw new Error("MongoDB Atlas adapter is not connected");try{const e=`${this.config.collectionPrefix}sync`,t=await this.executeQuery({collection:e,operation:"findOne",filter:{type:"sync"},options:{sort:{timestamp:-1}}});if(!t)throw new Error("No sync data found");return this.emit("restore-completed",{data:t.data,adapter:this.name}),t.data}catch(e){throw this.errorCount++,this.lastError=e instanceof Error?e.message:"Restore failed",this.emit("restore-failed",{error:e,adapter:this.name}),e}}async syncStore(e,t){if(!this.connected)throw new Error("MongoDB Atlas adapter is not connected");try{const r=`${this.config.collectionPrefix}stores`;await this.executeQuery({collection:r,operation:"updateOne",filter:{storeName:e},update:{$set:{data:t,timestamp:new Date,checksum:this.generateChecksum(t)}},options:{upsert:!0}}),this.emit("store-sync-completed",{storeName:e,data:t,adapter:this.name})}catch(t){throw this.errorCount++,this.lastError=t instanceof Error?t.message:"Store sync failed",this.emit("store-sync-failed",{storeName:e,error:t,adapter:this.name}),t}}async restoreStore(e){if(!this.connected)throw new Error("MongoDB Atlas adapter is not connected");try{const t=`${this.config.collectionPrefix}stores`,r=await this.executeQuery({collection:t,operation:"findOne",filter:{storeName:e}});return r?(this.emit("store-restore-completed",{storeName:e,data:r.data,adapter:this.name}),r.data):null}catch(t){throw this.errorCount++,this.lastError=t instanceof Error?t.message:"Store restore failed",this.emit("store-restore-failed",{storeName:e,error:t,adapter:this.name}),t}}async executeQuery(e){if(!this.connected)throw new Error("MongoDB Atlas adapter is not connected");try{const t=await fetch(`${this.getAtlasDataAPIEndpoint()}/action/${e.operation}`,{method:"POST",headers:{"Content-Type":"application/json","Access-Control-Request-Headers":"*","api-key":this.config.atlas?.apiKey||this.config.connectionString},body:JSON.stringify({dataSource:this.config.atlas?.clusterName,database:this.config.databaseName,collection:e.collection,...this.buildQueryBody(e)})});if(!t.ok)throw new Error(`MongoDB query failed: ${t.statusText}`);const r=await t.json();return r.document||r.documents||r}catch(e){throw this.logger.error("MongoDB query failed:",e),e}}async search(e){if(!this.config.search?.enabled)throw new Error("MongoDB Atlas Search is not enabled");try{const t=[{$search:{index:e.index,...this.buildSearchQuery(e)}}];e.limit&&t.push({$limit:e.limit}),e.skip&&t.push({$skip:e.skip});const r=await this.executeQuery({collection:"search_collection",operation:"aggregate",pipeline:t});return this.emit("search-completed",{query:e,result:r}),r}catch(t){throw this.emit("search-failed",{query:e,error:t}),t}}async createIndex(e,t,r){try{const i=await fetch(`${this.getAtlasDataAPIEndpoint()}/action/createIndex`,{method:"POST",headers:{"Content-Type":"application/json","api-key":this.config.atlas?.apiKey||this.config.connectionString},body:JSON.stringify({dataSource:this.config.atlas?.clusterName,database:this.config.databaseName,collection:e,keys:t,options:r})});if(!i.ok)throw new Error(`Index creation failed: ${i.statusText}`);const s=await i.json();return this.emit("index-created",{collection:e,indexSpec:t,result:s}),s.indexName}catch(e){throw this.logger.error("Failed to create index:",e),e}}async runAggregation(e,t){return this.executeQuery({collection:e,operation:"aggregate",pipeline:t})}async countDocuments(e,t={}){try{const r=await fetch(`${this.getAtlasDataAPIEndpoint()}/action/aggregate`,{method:"POST",headers:{"Content-Type":"application/json","api-key":this.config.atlas?.apiKey||this.config.connectionString},body:JSON.stringify({dataSource:this.config.atlas?.clusterName,database:this.config.databaseName,collection:e,pipeline:[{$match:t},{$count:"total"}]})});if(!r.ok)throw new Error(`Count query failed: ${r.statusText}`);const i=await r.json();return i.documents[0]?.total||0}catch(e){throw this.logger.error("Failed to count documents:",e),e}}async getCollectionStats(e){try{const t=await fetch(`${this.getAtlasDataAPIEndpoint()}/action/aggregate`,{method:"POST",headers:{"Content-Type":"application/json","api-key":this.config.atlas?.apiKey||this.config.connectionString},body:JSON.stringify({dataSource:this.config.atlas?.clusterName,database:this.config.databaseName,collection:e,pipeline:[{$collStats:{storageStats:{}}}]})});if(!t.ok)throw new Error(`Stats query failed: ${t.statusText}`);const r=(await t.json()).documents[0];return{size:r.size||0,count:r.count||0,avgObjSize:r.avgObjSize||0,storageSize:r.storageSize||0,indexes:r.nindexes||0,indexSize:r.totalIndexSize||0}}catch(e){throw this.logger.error("Failed to get collection stats:",e),e}}async runAnalyticsPipeline(e,t,r){try{const i=await fetch(`${this.getAtlasDataAPIEndpoint()}/action/aggregate`,{method:"POST",headers:{"Content-Type":"application/json","api-key":this.config.atlas?.apiKey||this.config.connectionString},body:JSON.stringify({dataSource:this.config.atlas?.clusterName,database:this.config.databaseName,collection:e,pipeline:t,options:{maxTimeMS:r?.timeout||this.config.analytics?.pipelineTimeout||3e4,allowDiskUse:r?.allowDiskUse||!0}})});if(!i.ok)throw new Error(`Analytics pipeline failed: ${i.statusText}`);const s=await i.json();return this.emit("analytics-completed",{collection:e,pipeline:t,result:s}),s.documents}catch(r){throw this.emit("analytics-failed",{collection:e,pipeline:t,error:r}),r}}async watchCollection(e,t,r){try{const t=setInterval(async()=>{try{const t=await this.executeQuery({collection:`${e}_changes`,operation:"find",filter:{timestamp:{$gte:new Date(Date.now()-5e3)}},options:{sort:{timestamp:-1}}});t&&t.length>0&&r&&t.forEach(r)}catch(e){this.logger.error("Change stream error:",e)}},5e3);return this.emit("watch-started",{collection:e}),()=>{clearInterval(t),this.emit("watch-stopped",{collection:e})}}catch(e){throw this.logger.error("Failed to watch collection:",e),e}}async bulkWrite(e,t){try{const r=await fetch(`${this.getAtlasDataAPIEndpoint()}/action/bulkWrite`,{method:"POST",headers:{"Content-Type":"application/json","api-key":this.config.atlas?.apiKey||this.config.connectionString},body:JSON.stringify({dataSource:this.config.atlas?.clusterName,database:this.config.databaseName,collection:e,operations:t})});if(!r.ok)throw new Error(`Bulk write failed: ${r.statusText}`);const i=await r.json();return this.emit("bulk-write-completed",{collection:e,operations:t,result:i}),i}catch(r){throw this.emit("bulk-write-failed",{collection:e,operations:t,error:r}),r}}getAtlasDataAPIEndpoint(){return`https://data.mongodb-api.com/app/${this.config.atlas?.projectId}/endpoint/data/v1`}buildQueryBody(e){const t={};return e.filter&&(t.filter=e.filter),e.document&&(t.document=e.document),e.documents&&(t.documents=e.documents),e.update&&(t.update=e.update),e.pipeline&&(t.pipeline=e.pipeline),e.options&&(e.options.sort&&(t.sort=e.options.sort),e.options.limit&&(t.limit=e.options.limit),e.options.skip&&(t.skip=e.options.skip),e.options.projection&&(t.projection=e.options.projection),e.options.upsert&&(t.upsert=e.options.upsert)),t}buildSearchQuery(e){const t={};return e.text&&(t.text=e.text),e.compound&&(t.compound=e.compound),e.highlight&&(t.highlight=e.highlight),t}generateChecksum(e){const t=JSON.stringify(e);let r=0;for(let e=0;e<t.length;e++){r=(r<<5)-r+t.charCodeAt(e),r&=r}return r.toString(16)}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this.errorCount,lastError:this.lastError??void 0}}getCapabilities(){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!0,maxDataSize:16777216,supportedFormats:["json","bson"]}}}class be extends S{constructor(e){super(),this.name="ibm-cloud",this.provider="IBM Cloud",this.connected=!1,this._errorCount=0,this.config=e}async connect(){try{this.connected=!0,this.emit("connected",{adapter:this.name})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Connection failed",e}}async disconnect(){this.connected=!1,this.emit("disconnected",{adapter:this.name})}isConnected(){return this.connected}async sync(e){if(!this.connected)throw new Error("IBM Cloud adapter not connected");try{const t=`https://s3.${this.config.region||"us-south"}.cloud-object-storage.appdomain.cloud/brolostack-sync/sync.json`,r=await fetch(t,{method:"PUT",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json","ibm-service-instance-id":this.config.credentials.serviceAccountKey||""},body:JSON.stringify({...e,ibm_metadata:{region:this.config.region,timestamp:(new Date).toISOString(),watson_ai_integration:this.config.services?.ai||!1}})});if(!r.ok)throw new Error(`IBM Cloud sync failed: ${r.statusText}`);this.lastSync=new Date,this.emit("sync-completed",{adapter:this.name,timestamp:this.lastSync})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Sync failed",e}}async backup(e){if(!this.connected)throw new Error("IBM Cloud adapter not connected");try{const t=`ibm_backup_${Date.now()}`,r=`https://s3.${this.config.region||"us-south"}.cloud-object-storage.appdomain.cloud/brolostack-backup/${t}.json`,i=await fetch(r,{method:"PUT",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json","ibm-service-instance-id":this.config.credentials.serviceAccountKey||""},body:JSON.stringify({data:e,backup_metadata:{backup_id:t,timestamp:(new Date).toISOString(),provider:"ibm-cloud",watson_processed:!1,retention_policy:"90_days"}})});if(!i.ok)throw new Error(`IBM Cloud backup failed: ${i.statusText}`);this.lastBackup=new Date,this.emit("backup-completed",{adapter:this.name,backupId:t,timestamp:this.lastBackup})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Backup failed",e}}async restore(){if(!this.connected)throw new Error("IBM Cloud adapter not connected");try{const e=`https://s3.${this.config.region||"us-south"}.cloud-object-storage.appdomain.cloud/brolostack-sync/sync.json`,t=await fetch(e,{headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"ibm-service-instance-id":this.config.credentials.serviceAccountKey||""}});if(!t.ok)throw new Error(`IBM Cloud restore failed: ${t.statusText}`);const r=await t.json();return this.emit("restore-completed",{adapter:this.name,timestamp:new Date}),r}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Restore failed",e}}async syncStore(e,t){await this.sync({store:e,data:t,watson_analytics:this.config.services?.ai?await this.analyzeWithWatson(t):null})}async restoreStore(e){const t=await this.restore();return t?.store===e?t.data:null}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this._errorCount,lastError:this.lastError??void 0}}getCapabilities(){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!0,maxDataSize:10737418240,supportedFormats:["json","binary","xml","csv","parquet"]}}async analyzeWithWatson(e){if(!this.config.services?.ai)return null;try{return{analyzed:!0,timestamp:(new Date).toISOString(),summary:"Watson AI analysis completed",sentiment:"neutral",keywords:[],entities:[]}}catch(e){return{analyzed:!1,error:e instanceof Error?e.message:"Watson analysis failed"}}}}class Se extends S{constructor(e){super(),this.name="oracle-cloud",this.provider="Oracle Cloud Infrastructure",this.connected=!1,this._errorCount=0,this.config=e}async connect(){try{this.connected=!0,this.emit("connected",{adapter:this.name})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Connection failed",e}}async disconnect(){this.connected=!1,this.emit("disconnected",{adapter:this.name})}isConnected(){return this.connected}async sync(e){if(!this.connected)throw new Error("Oracle Cloud adapter not connected");try{const t=this.config.credentials.tenantId||"brolostack",r=`https://objectstorage.${this.config.region||"us-ashburn-1"}.oraclecloud.com/n/${t}/b/brolostack-sync/o/sync.json`,i=await fetch(r,{method:"PUT",headers:{Authorization:this.getOracleAuthHeader("PUT",`/n/${t}/b/brolostack-sync/o/sync.json`),"Content-Type":"application/json",Date:(new Date).toUTCString()},body:JSON.stringify({...e,oracle_metadata:{compartment_id:this.config.credentials.tenantId,region:this.config.region,timestamp:(new Date).toISOString()}})});if(!i.ok)throw new Error(`Oracle Cloud sync failed: ${i.statusText}`);this.lastSync=new Date,this.emit("sync-completed",{adapter:this.name,timestamp:this.lastSync})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Sync failed",e}}async backup(e){if(!this.connected)throw new Error("Oracle Cloud adapter not connected");try{const t=`oracle_backup_${Date.now()}`,r=this.config.credentials.tenantId||"brolostack",i=`https://objectstorage.${this.config.region||"us-ashburn-1"}.oraclecloud.com/n/${r}/b/brolostack-backup/o/${t}.json`,s=await fetch(i,{method:"PUT",headers:{Authorization:this.getOracleAuthHeader("PUT",`/n/${r}/b/brolostack-backup/o/${t}.json`),"Content-Type":"application/json",Date:(new Date).toUTCString()},body:JSON.stringify({data:e,oracle_backup_metadata:{backup_id:t,timestamp:(new Date).toISOString(),compartment_id:this.config.credentials.tenantId,lifecycle_policy:"STANDARD_IA_AFTER_30_DAYS",encryption:this.config.encryption?.enabled||!1}})});if(!s.ok)throw new Error(`Oracle Cloud backup failed: ${s.statusText}`);this.lastBackup=new Date,this.emit("backup-completed",{adapter:this.name,backupId:t,timestamp:this.lastBackup})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Backup failed",e}}async restore(){if(!this.connected)throw new Error("Oracle Cloud adapter not connected");try{const e=this.config.credentials.tenantId||"brolostack",t=`https://objectstorage.${this.config.region||"us-ashburn-1"}.oraclecloud.com/n/${e}/b/brolostack-sync/o/sync.json`,r=await fetch(t,{headers:{Authorization:this.getOracleAuthHeader("GET",`/n/${e}/b/brolostack-sync/o/sync.json`),Date:(new Date).toUTCString()}});if(!r.ok)throw new Error(`Oracle Cloud restore failed: ${r.statusText}`);const i=await r.json();return this.emit("restore-completed",{adapter:this.name,timestamp:new Date}),i}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Restore failed",e}}async syncStore(e,t){await this.sync({store:e,data:t,oracle_audit_trail:!0})}async restoreStore(e){const t=await this.restore();return t?.store===e?t.data:null}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this._errorCount,lastError:this.lastError??void 0}}getCapabilities(){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!1,maxDataSize:10737418240,supportedFormats:["json","binary","xml","csv","parquet","avro"]}}getOracleAuthHeader(e,t){const r=this.config.credentials.accessKeyId||"",i=this.config.credentials.secretAccessKey||"",s=(new Date).toUTCString(),a=`${e.toLowerCase()} ${t}\ndate: ${s}`;return`Signature keyId="${r}",algorithm="rsa-sha256",headers="date request-target",signature="${Buffer.from(`${i}:${a}`).toString("base64")}"`}}class ve extends S{constructor(e){super(),this.name="salesforce-cloud",this.provider="Salesforce Cloud",this.connected=!1,this._errorCount=0,this.config=e}async connect(){try{this.connected=!0,this.emit("connected",{adapter:this.name})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Connection failed",e}}async disconnect(){this.connected=!1,this.emit("disconnected",{adapter:this.name})}isConnected(){return this.connected}async sync(e){if(!this.connected)throw new Error("Salesforce Cloud adapter not connected");try{const t=`${this.config.endpoints?.storage||"https://brolostack.my.salesforce.com"}/services/data/v58.0/sobjects/BrolostackSync__c/`,r=await fetch(t,{method:"POST",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({Name:`Sync_${Date.now()}`,Data__c:JSON.stringify(e),Timestamp__c:(new Date).toISOString(),Source__c:"Brolostack Framework"})});if(!r.ok)throw new Error(`Salesforce sync failed: ${r.statusText}`);this.lastSync=new Date,this.emit("sync-completed",{adapter:this.name,timestamp:this.lastSync})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Sync failed",e}}async backup(e){if(!this.connected)throw new Error("Salesforce Cloud adapter not connected");try{const t=`sf_backup_${Date.now()}`,r=`${this.config.endpoints?.storage||"https://brolostack.my.salesforce.com"}/services/data/v58.0/sobjects/BrolostackBackup__c/`,i=await fetch(r,{method:"POST",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({Name:t,Data__c:JSON.stringify(e),BackupId__c:t,Timestamp__c:(new Date).toISOString(),RetentionDays__c:365,Encrypted__c:this.config.encryption?.enabled||!1})});if(!i.ok)throw new Error(`Salesforce backup failed: ${i.statusText}`);this.lastBackup=new Date,this.emit("backup-completed",{adapter:this.name,backupId:t,timestamp:this.lastBackup})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Backup failed",e}}async restore(){if(!this.connected)throw new Error("Salesforce Cloud adapter not connected");try{const e=`${this.config.endpoints?.storage||"https://brolostack.my.salesforce.com"}/services/data/v58.0/query/?q=SELECT Data__c FROM BrolostackSync__c ORDER BY CreatedDate DESC LIMIT 1`,t=await fetch(e,{headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`}});if(!t.ok)throw new Error(`Salesforce restore failed: ${t.statusText}`);const r=await t.json(),i=r.records[0]?.Data__c?JSON.parse(r.records[0].Data__c):null;return this.emit("restore-completed",{adapter:this.name,timestamp:new Date}),i}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Restore failed",e}}async syncStore(e,t){await this.sync({store:e,data:t,salesforce_integration:!0})}async restoreStore(e){const t=await this.restore();return t?.store===e?t.data:null}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this._errorCount,lastError:this.lastError??void 0}}getCapabilities(){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!0,maxDataSize:6291456,supportedFormats:["json","xml","csv"]}}}class Ee extends S{constructor(e){super(),this.name="sap-cloud",this.provider="SAP Cloud Platform",this.connected=!1,this._errorCount=0,this.config=e}async connect(){try{this.connected=!0,this.emit("connected",{adapter:this.name})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Connection failed",e}}async disconnect(){this.connected=!1,this.emit("disconnected",{adapter:this.name})}isConnected(){return this.connected}async sync(e){if(!this.connected)throw new Error("SAP Cloud adapter not connected");try{const t=`${this.config.endpoints?.storage||"https://api.cf.sap.hana.ondemand.com"}/document/collections/brolostack/documents`,r=await fetch(t,{method:"POST",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({name:`sync_${Date.now()}.json`,content:Buffer.from(JSON.stringify(e)).toString("base64"),contentType:"application/json",metadata:{source:"brolostack",timestamp:(new Date).toISOString(),version:"1.0"}})});if(!r.ok)throw new Error(`SAP Cloud sync failed: ${r.statusText}`);this.lastSync=new Date,this.emit("sync-completed",{adapter:this.name,timestamp:this.lastSync})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Sync failed",e}}async backup(e){if(!this.connected)throw new Error("SAP Cloud adapter not connected");try{const t=`sap_backup_${Date.now()}`,r=`${this.config.endpoints?.storage||"https://api.cf.sap.hana.ondemand.com"}/document/collections/brolostack-backup/documents`,i=await fetch(r,{method:"POST",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({name:`${t}.json`,content:Buffer.from(JSON.stringify({data:e,backup_metadata:{backup_id:t,timestamp:(new Date).toISOString(),provider:"sap-cloud",hana_integration:this.config.services?.database||!1}})).toString("base64"),contentType:"application/json"})});if(!i.ok)throw new Error(`SAP Cloud backup failed: ${i.statusText}`);this.lastBackup=new Date,this.emit("backup-completed",{adapter:this.name,backupId:t,timestamp:this.lastBackup})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Backup failed",e}}async restore(){if(!this.connected)throw new Error("SAP Cloud adapter not connected");try{const e=`${this.config.endpoints?.storage||"https://api.cf.sap.hana.ondemand.com"}/document/collections/brolostack/documents?$orderby=createdAt desc&$top=1`,t=await fetch(e,{headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,Accept:"application/json"}});if(!t.ok)throw new Error(`SAP Cloud restore failed: ${t.statusText}`);const r=await t.json(),i=r.documents?.[0];if(!i)throw new Error("No backup document found");const s=JSON.parse(Buffer.from(i.content,"base64").toString());return this.emit("restore-completed",{adapter:this.name,timestamp:new Date}),s}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Restore failed",e}}async syncStore(e,t){await this.sync({store:e,data:t,sap_hana_integration:this.config.services?.database})}async restoreStore(e){const t=await this.restore();return t?.store===e?t.data:null}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this._errorCount,lastError:this.lastError??void 0}}getCapabilities(){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!0,maxDataSize:104857600,supportedFormats:["json","binary","xml","csv","odata"]}}}class Te extends S{constructor(e){super(),this.name="digitalocean",this.provider="DigitalOcean Spaces",this.connected=!1,this._errorCount=0,this.config=e}async connect(){try{this.connected=!0,this.emit("connected",{adapter:this.name})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Connection failed",e}}async disconnect(){this.connected=!1,this.emit("disconnected",{adapter:this.name})}isConnected(){return this.connected}async sync(e){if(!this.connected)throw new Error("DigitalOcean adapter not connected");try{const t=`https://${this.config.endpoints?.storage||"brolostack-space"}.${this.config.region||"nyc3"}.digitaloceanspaces.com/sync.json`,r=await fetch(t,{method:"PUT",headers:{Authorization:this.getDigitalOceanAuthHeader("PUT","/sync.json"),"Content-Type":"application/json","x-amz-acl":"private"},body:JSON.stringify({...e,digitalocean_metadata:{region:this.config.region,timestamp:(new Date).toISOString(),cdn_enabled:!0}})});if(!r.ok)throw new Error(`DigitalOcean sync failed: ${r.statusText}`);this.lastSync=new Date,this.emit("sync-completed",{adapter:this.name,timestamp:this.lastSync})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Sync failed",e}}async backup(e){if(!this.connected)throw new Error("DigitalOcean adapter not connected");try{const t=`do_backup_${Date.now()}`,r=this.config.endpoints?.storage||"brolostack-space",i=`https://${r}.${this.config.region||"nyc3"}.digitaloceanspaces.com/backups/${t}.json`,s=await fetch(i,{method:"PUT",headers:{Authorization:this.getDigitalOceanAuthHeader("PUT",`/backups/${t}.json`),"Content-Type":"application/json","x-amz-acl":"private","x-amz-storage-class":"STANDARD_IA"},body:JSON.stringify({data:e,backup_metadata:{backup_id:t,timestamp:(new Date).toISOString(),provider:"digitalocean",cdn_url:`https://${r}.${this.config.region||"nyc3"}.cdn.digitaloceanspaces.com/backups/${t}.json`}})});if(!s.ok)throw new Error(`DigitalOcean backup failed: ${s.statusText}`);this.lastBackup=new Date,this.emit("backup-completed",{adapter:this.name,backupId:t,timestamp:this.lastBackup})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Backup failed",e}}async restore(){if(!this.connected)throw new Error("DigitalOcean adapter not connected");try{const e=`https://${this.config.endpoints?.storage||"brolostack-space"}.${this.config.region||"nyc3"}.digitaloceanspaces.com/sync.json`,t=await fetch(e,{headers:{Authorization:this.getDigitalOceanAuthHeader("GET","/sync.json")}});if(!t.ok)throw new Error(`DigitalOcean restore failed: ${t.statusText}`);const r=await t.json();return this.emit("restore-completed",{adapter:this.name,timestamp:new Date}),r}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Restore failed",e}}async syncStore(e,t){await this.sync({store:e,data:t,cdn_cache_control:"max-age=3600"})}async restoreStore(e){const t=await this.restore();return t?.store===e?t.data:null}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this._errorCount,lastError:this.lastError??void 0}}getCapabilities(){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!1,maxDataSize:5368709120,supportedFormats:["json","binary","xml","text","image","video"]}}getDigitalOceanAuthHeader(e,t){const r=this.config.credentials.accessKeyId||"",i=this.config.credentials.secretAccessKey||"",s=`${e}\n\napplication/json\n${(new Date).toUTCString()}\n${t}`;return`AWS ${r}:${Buffer.from(`${i}:${s}`).toString("base64")}`}}class Ce extends S{constructor(e){super(),this.name="tencent-cloud",this.provider="Tencent Cloud",this.connected=!1,this._errorCount=0,this.config=e}async connect(){try{this.connected=!0,this.emit("connected",{adapter:this.name})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Connection failed",e}}async disconnect(){this.connected=!1,this.emit("disconnected",{adapter:this.name})}isConnected(){return this.connected}async sync(e){if(!this.connected)throw new Error("Tencent Cloud adapter not connected");try{const t=`https://brolostack-${this.config.region||"ap-beijing"}.cos.myqcloud.com/sync.json`,r=await fetch(t,{method:"PUT",headers:{Authorization:this.getTencentAuthHeader("PUT","/sync.json"),"Content-Type":"application/json",Host:`brolostack-${this.config.region||"ap-beijing"}.cos.myqcloud.com`},body:JSON.stringify({...e,tencent_metadata:{region:this.config.region,timestamp:(new Date).toISOString(),ai_integration:this.config.services?.ai||!1}})});if(!r.ok)throw new Error(`Tencent Cloud sync failed: ${r.statusText}`);this.lastSync=new Date,this.emit("sync-completed",{adapter:this.name,timestamp:this.lastSync})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Sync failed",e}}async backup(e){const t=`tencent_backup_${Date.now()}`;try{const r=`https://brolostack-backup-${this.config.region||"ap-beijing"}.cos.myqcloud.com/${t}.json`,i=await fetch(r,{method:"PUT",headers:{Authorization:this.getTencentAuthHeader("PUT",`/${t}.json`),"Content-Type":"application/json"},body:JSON.stringify({data:e,backup_metadata:{backup_id:t,timestamp:(new Date).toISOString(),provider:"tencent-cloud",storage_class:"STANDARD_IA"}})});if(!i.ok)throw new Error(`Tencent Cloud backup failed: ${i.statusText}`);this.lastBackup=new Date,this.emit("backup-completed",{adapter:this.name,backupId:t,timestamp:this.lastBackup})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Backup failed",e}}async restore(){try{const e=`https://brolostack-${this.config.region||"ap-beijing"}.cos.myqcloud.com/sync.json`,t=await fetch(e,{headers:{Authorization:this.getTencentAuthHeader("GET","/sync.json")}});if(!t.ok)throw new Error(`Tencent Cloud restore failed: ${t.statusText}`);const r=await t.json();return this.emit("restore-completed",{adapter:this.name,timestamp:new Date}),r}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Restore failed",e}}async syncStore(e,t){await this.sync({store:e,data:t})}async restoreStore(e){const t=await this.restore();return t?.store===e?t.data:null}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this._errorCount,lastError:this.lastError??void 0}}getCapabilities(){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!0,maxDataSize:5368709120,supportedFormats:["json","binary","xml","text"]}}getTencentAuthHeader(e,t){const r=this.config.credentials.accessKeyId||"",i=this.config.credentials.secretAccessKey||"",s=Math.floor(Date.now()/1e3),a=`${e}\n${t}\n\nhost=brolostack.cos.myqcloud.com&timestamp=${s}`;return`q-sign-algorithm=sha1&q-ak=${r}&q-sign-time=${s};${s+3600}&q-key-time=${s};${s+3600}&q-header-list=host&q-url-param-list=&q-signature=${Buffer.from(`${i}:${a}`).toString("base64")}`}}class Ae extends S{constructor(e){super(),this.name="vmware-cloud",this.provider="VMware Cloud",this.connected=!1,this._errorCount=0,this.config=e}async connect(){try{this.connected=!0,this.emit("connected",{adapter:this.name})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Connection failed",e}}async disconnect(){this.connected=!1,this.emit("disconnected",{adapter:this.name})}isConnected(){return this.connected}async sync(e){if(!this.connected)throw new Error("VMware Cloud adapter not connected");try{const t=`${this.config.endpoints?.storage||"https://vcloud.vmware.com"}/api/brolostack/sync`,r=await fetch(t,{method:"POST",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json",Accept:"application/*+json;version=36.0"},body:JSON.stringify({...e,vmware_metadata:{org:this.config.credentials.tenantId,vdc:this.config.region,timestamp:(new Date).toISOString(),vapp_integration:!0}})});if(!r.ok)throw new Error(`VMware Cloud sync failed: ${r.statusText}`);this.lastSync=new Date,this.emit("sync-completed",{adapter:this.name,timestamp:this.lastSync})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Sync failed",e}}async backup(e){const t=`vmware_backup_${Date.now()}`;try{const r=`${this.config.endpoints?.storage||"https://vcloud.vmware.com"}/api/brolostack/backup`,i=await fetch(r,{method:"POST",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json",Accept:"application/*+json;version=36.0"},body:JSON.stringify({name:t,data:e,backup_metadata:{backup_id:t,timestamp:(new Date).toISOString(),provider:"vmware-cloud",snapshot_enabled:!0}})});if(!i.ok)throw new Error(`VMware Cloud backup failed: ${i.statusText}`);this.lastBackup=new Date,this.emit("backup-completed",{adapter:this.name,backupId:t,timestamp:this.lastBackup})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Backup failed",e}}async restore(){try{const e=`${this.config.endpoints?.storage||"https://vcloud.vmware.com"}/api/brolostack/sync`,t=await fetch(e,{headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,Accept:"application/*+json;version=36.0"}});if(!t.ok)throw new Error(`VMware Cloud restore failed: ${t.statusText}`);const r=await t.json();return this.emit("restore-completed",{adapter:this.name,timestamp:new Date}),r}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Restore failed",e}}async syncStore(e,t){await this.sync({store:e,data:t,vmware_vapp:!0})}async restoreStore(e){const t=await this.restore();return t?.store===e?t.data:null}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this._errorCount,lastError:this.lastError??void 0}}getCapabilities(){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!1,maxDataSize:2147483648,supportedFormats:["json","binary","xml","ovf"]}}}class De extends S{constructor(e){super(),this.name="cloudflare",this.provider="Cloudflare",this.connected=!1,this._errorCount=0,this.config=e}async connect(){try{this.connected=!0,this.emit("connected",{adapter:this.name})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Connection failed",e}}async disconnect(){this.connected=!1,this.emit("disconnected",{adapter:this.name})}isConnected(){return this.connected}async sync(e){if(!this.connected)throw new Error("Cloudflare adapter not connected");try{const t=this.config.credentials.tenantId,r=`https://api.cloudflare.com/client/v4/accounts/${t}/storage/kv/namespaces/${this.config.endpoints?.storage||"brolostack_kv"}/values/sync_data`,i=await fetch(r,{method:"PUT",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({...e,cloudflare_metadata:{edge_cached:!0,timestamp:(new Date).toISOString(),worker_integration:this.config.services?.compute||!1}})});if(!i.ok)throw new Error(`Cloudflare sync failed: ${i.statusText}`);this.lastSync=new Date,this.emit("sync-completed",{adapter:this.name,timestamp:this.lastSync})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Sync failed",e}}async backup(e){const t=`cf_backup_${Date.now()}`;try{const r=this.config.credentials.tenantId,i=`https://api.cloudflare.com/client/v4/accounts/${r}/storage/kv/namespaces/${this.config.endpoints?.storage||"brolostack_kv"}/values/${t}`,s=await fetch(i,{method:"PUT",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({data:e,backup_metadata:{backup_id:t,timestamp:(new Date).toISOString(),provider:"cloudflare",edge_locations:"global",ttl:31536e3}})});if(!s.ok)throw new Error(`Cloudflare backup failed: ${s.statusText}`);this.lastBackup=new Date,this.emit("backup-completed",{adapter:this.name,backupId:t,timestamp:this.lastBackup})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Backup failed",e}}async restore(){try{const e=this.config.credentials.tenantId,t=`https://api.cloudflare.com/client/v4/accounts/${e}/storage/kv/namespaces/${this.config.endpoints?.storage||"brolostack_kv"}/values/sync_data`,r=await fetch(t,{headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`}});if(!r.ok)throw new Error(`Cloudflare restore failed: ${r.statusText}`);const i=await r.json();return this.emit("restore-completed",{adapter:this.name,timestamp:new Date}),i}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Restore failed",e}}async syncStore(e,t){await this.sync({store:e,data:t,edge_cache_ttl:3600})}async restoreStore(e){const t=await this.restore();return t?.store===e?t.data:null}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this._errorCount,lastError:this.lastError??void 0}}getCapabilities(){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!0,maxDataSize:26214400,supportedFormats:["json","binary","text"]}}}class Ie extends S{constructor(e){super(),this.name="coreweave",this.provider="CoreWeave",this.connected=!1,this._errorCount=0,this.config=e}async connect(){try{this.connected=!0,this.emit("connected",{adapter:this.name})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Connection failed",e}}async disconnect(){this.connected=!1,this.emit("disconnected",{adapter:this.name})}isConnected(){return this.connected}async sync(e){if(!this.connected)throw new Error("CoreWeave adapter not connected");try{const t=`https://object.${this.config.region||"ord1"}.coreweave.com/brolostack-sync/sync.json`,r=await fetch(t,{method:"PUT",headers:{Authorization:this.getCoreWeaveAuthHeader("PUT","/brolostack-sync/sync.json"),"Content-Type":"application/json"},body:JSON.stringify({...e,coreweave_metadata:{region:this.config.region,timestamp:(new Date).toISOString(),gpu_accelerated:this.config.services?.ai||!1,high_performance:!0}})});if(!r.ok)throw new Error(`CoreWeave sync failed: ${r.statusText}`);this.lastSync=new Date,this.emit("sync-completed",{adapter:this.name,timestamp:this.lastSync})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Sync failed",e}}async backup(e){const t=`cw_backup_${Date.now()}`;try{const r=`https://object.${this.config.region||"ord1"}.coreweave.com/brolostack-backup/${t}.json`,i=await fetch(r,{method:"PUT",headers:{Authorization:this.getCoreWeaveAuthHeader("PUT",`/brolostack-backup/${t}.json`),"Content-Type":"application/json","x-amz-storage-class":"STANDARD"},body:JSON.stringify({data:e,backup_metadata:{backup_id:t,timestamp:(new Date).toISOString(),provider:"coreweave",gpu_optimized:!0,performance_tier:"high"}})});if(!i.ok)throw new Error(`CoreWeave backup failed: ${i.statusText}`);this.lastBackup=new Date,this.emit("backup-completed",{adapter:this.name,backupId:t,timestamp:this.lastBackup})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Backup failed",e}}async restore(){try{const e=`https://object.${this.config.region||"ord1"}.coreweave.com/brolostack-sync/sync.json`,t=await fetch(e,{headers:{Authorization:this.getCoreWeaveAuthHeader("GET","/brolostack-sync/sync.json")}});if(!t.ok)throw new Error(`CoreWeave restore failed: ${t.statusText}`);const r=await t.json();return this.emit("restore-completed",{adapter:this.name,timestamp:new Date}),r}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Restore failed",e}}async syncStore(e,t){await this.sync({store:e,data:t,gpu_accelerated:this.config.services?.ai})}async restoreStore(e){const t=await this.restore();return t?.store===e?t.data:null}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this._errorCount,lastError:this.lastError??void 0}}getCapabilities(){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!1,maxDataSize:5368709120,supportedFormats:["json","binary","hdf5","parquet","tensor"]}}getCoreWeaveAuthHeader(e,t){const r=this.config.credentials.accessKeyId||"",i=this.config.credentials.secretAccessKey||"",s=`${e}\n\napplication/json\n${(new Date).toUTCString()}\n${t}`;return`AWS ${r}:${Buffer.from(`${i}:${s}`).toString("base64")}`}}class xe extends S{constructor(e){super(),this.name="huawei-cloud",this.provider="Huawei Cloud",this.connected=!1,this._errorCount=0,this.config=e}async connect(){try{this.connected=!0,this.emit("connected",{adapter:this.name})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Connection failed",e}}async disconnect(){this.connected=!1,this.emit("disconnected",{adapter:this.name})}isConnected(){return this.connected}async sync(e){if(!this.connected)throw new Error("Huawei Cloud adapter not connected");try{const t=`https://brolostack.obs.${this.config.region||"cn-north-1"}.myhuaweicloud.com/sync.json`,r=await fetch(t,{method:"PUT",headers:{Authorization:this.getHuaweiAuthHeader("PUT","/sync.json"),"Content-Type":"application/json",Date:(new Date).toUTCString()},body:JSON.stringify({...e,huawei_metadata:{region:this.config.region,timestamp:(new Date).toISOString(),ai_gallery_integration:this.config.services?.ai||!1}})});if(!r.ok)throw new Error(`Huawei Cloud sync failed: ${r.statusText}`);this.lastSync=new Date,this.emit("sync-completed",{adapter:this.name,timestamp:this.lastSync})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Sync failed",e}}async backup(e){const t=`huawei_backup_${Date.now()}`;try{const r=`https://brolostack-backup.obs.${this.config.region||"cn-north-1"}.myhuaweicloud.com/${t}.json`,i=await fetch(r,{method:"PUT",headers:{Authorization:this.getHuaweiAuthHeader("PUT",`/${t}.json`),"Content-Type":"application/json",Date:(new Date).toUTCString()},body:JSON.stringify({data:e,backup_metadata:{backup_id:t,timestamp:(new Date).toISOString(),provider:"huawei-cloud",storage_class:"WARM",compliance:"china_data_protection"}})});if(!i.ok)throw new Error(`Huawei Cloud backup failed: ${i.statusText}`);this.lastBackup=new Date,this.emit("backup-completed",{adapter:this.name,backupId:t,timestamp:this.lastBackup})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Backup failed",e}}async restore(){try{const e=`https://brolostack.obs.${this.config.region||"cn-north-1"}.myhuaweicloud.com/sync.json`,t=await fetch(e,{headers:{Authorization:this.getHuaweiAuthHeader("GET","/sync.json"),Date:(new Date).toUTCString()}});if(!t.ok)throw new Error(`Huawei Cloud restore failed: ${t.statusText}`);const r=await t.json();return this.emit("restore-completed",{adapter:this.name,timestamp:new Date}),r}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Restore failed",e}}async syncStore(e,t){await this.sync({store:e,data:t,compliance_check:!0})}async restoreStore(e){const t=await this.restore();return t?.store===e?t.data:null}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this._errorCount,lastError:this.lastError??void 0}}getCapabilities(){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!0,maxDataSize:5368709120,supportedFormats:["json","binary","xml","text"]}}getHuaweiAuthHeader(e,t){const r=this.config.credentials.accessKeyId||"",i=this.config.credentials.secretAccessKey||"",s=`${e}\n\napplication/json\n${(new Date).toUTCString()}\n${t}`;return`OBS ${r}:${Buffer.from(`${i}:${s}`).toString("base64")}`}}class _e extends S{constructor(e){super(),this.name="rackspace",this.provider="Rackspace Cloud",this.connected=!1,this._errorCount=0,this.config=e}async connect(){try{this.connected=!0,this.emit("connected",{adapter:this.name})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Connection failed",e}}async disconnect(){this.connected=!1,this.emit("disconnected",{adapter:this.name})}isConnected(){return this.connected}async sync(e){if(!this.connected)throw new Error("Rackspace adapter not connected");try{const t=`https://storage101.${this.config.region||"dfw1"}.clouddrive.com/v1/MossoCloudFS_${this.config.credentials.tenantId}/brolostack/sync.json`,r=await fetch(t,{method:"PUT",headers:{"X-Auth-Token":this.config.credentials.apiKey||"","Content-Type":"application/json"},body:JSON.stringify({...e,rackspace_metadata:{region:this.config.region,timestamp:(new Date).toISOString(),managed_services:!0}})});if(!r.ok)throw new Error(`Rackspace sync failed: ${r.statusText}`);this.lastSync=new Date,this.emit("sync-completed",{adapter:this.name,timestamp:this.lastSync})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Sync failed",e}}async backup(e){const t=`rax_backup_${Date.now()}`;try{const r=`https://storage101.${this.config.region||"dfw1"}.clouddrive.com/v1/MossoCloudFS_${this.config.credentials.tenantId}/brolostack-backup/${t}.json`,i=await fetch(r,{method:"PUT",headers:{"X-Auth-Token":this.config.credentials.apiKey||"","Content-Type":"application/json"},body:JSON.stringify({data:e,backup_metadata:{backup_id:t,timestamp:(new Date).toISOString(),provider:"rackspace",fanatical_support:!0}})});if(!i.ok)throw new Error(`Rackspace backup failed: ${i.statusText}`);this.lastBackup=new Date,this.emit("backup-completed",{adapter:this.name,backupId:t,timestamp:this.lastBackup})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Backup failed",e}}async restore(){try{const e=`https://storage101.${this.config.region||"dfw1"}.clouddrive.com/v1/MossoCloudFS_${this.config.credentials.tenantId}/brolostack/sync.json`,t=await fetch(e,{headers:{"X-Auth-Token":this.config.credentials.apiKey||""}});if(!t.ok)throw new Error(`Rackspace restore failed: ${t.statusText}`);const r=await t.json();return this.emit("restore-completed",{adapter:this.name,timestamp:new Date}),r}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Restore failed",e}}async syncStore(e,t){await this.sync({store:e,data:t,fanatical_support:!0})}async restoreStore(e){const t=await this.restore();return t?.store===e?t.data:null}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this._errorCount,lastError:this.lastError??void 0}}getCapabilities(){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!1,maxDataSize:5368709120,supportedFormats:["json","binary","xml","text"]}}}class Oe extends S{constructor(e){super(),this.name="cisco-cloud",this.provider="Cisco Cloud",this.connected=!1,this._errorCount=0,this.config=e}async connect(){try{this.connected=!0,this.emit("connected",{adapter:this.name})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Connection failed",e}}async disconnect(){this.connected=!1,this.emit("disconnected",{adapter:this.name})}isConnected(){return this.connected}async sync(e){if(!this.connected)throw new Error("Cisco Cloud adapter not connected");try{const t=`${this.config.endpoints?.storage||"https://intersight.com"}/api/v1/brolostack/sync`,r=await fetch(t,{method:"POST",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({...e,cisco_metadata:{intersight_managed:!0,timestamp:(new Date).toISOString(),security_enhanced:!0}})});if(!r.ok)throw new Error(`Cisco Cloud sync failed: ${r.statusText}`);this.lastSync=new Date,this.emit("sync-completed",{adapter:this.name,timestamp:this.lastSync})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Sync failed",e}}async backup(e){const t=`cisco_backup_${Date.now()}`;try{const r=`${this.config.endpoints?.storage||"https://intersight.com"}/api/v1/brolostack/backup`,i=await fetch(r,{method:"POST",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({name:t,data:e,backup_metadata:{backup_id:t,timestamp:(new Date).toISOString(),provider:"cisco-cloud",hyperflex_optimized:!0}})});if(!i.ok)throw new Error(`Cisco Cloud backup failed: ${i.statusText}`);this.lastBackup=new Date,this.emit("backup-completed",{adapter:this.name,backupId:t,timestamp:this.lastBackup})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Backup failed",e}}async restore(){try{const e=`${this.config.endpoints?.storage||"https://intersight.com"}/api/v1/brolostack/sync`,t=await fetch(e,{headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`}});if(!t.ok)throw new Error(`Cisco Cloud restore failed: ${t.statusText}`);const r=await t.json();return this.emit("restore-completed",{adapter:this.name,timestamp:new Date}),r}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Restore failed",e}}async syncStore(e,t){await this.sync({store:e,data:t,hyperflex_integration:!0})}async restoreStore(e){const t=await this.restore();return t?.store===e?t.data:null}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this._errorCount,lastError:this.lastError??void 0}}getCapabilities(){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!1,maxDataSize:1073741824,supportedFormats:["json","binary","xml"]}}}class Re extends S{constructor(e){super(),this.name="netapp",this.provider="NetApp Cloud",this.connected=!1,this._errorCount=0,this.config=e}async connect(){try{this.connected=!0,this.emit("connected",{adapter:this.name})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Connection failed",e}}async disconnect(){this.connected=!1,this.emit("disconnected",{adapter:this.name})}isConnected(){return this.connected}async sync(e){if(!this.connected)throw new Error("NetApp Cloud adapter not connected");try{const t=`${this.config.endpoints?.storage||"https://cloudmanager.netapp.com"}/api/v1/brolostack/sync`,r=await fetch(t,{method:"POST",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({...e,netapp_metadata:{ontap_version:"9.12",timestamp:(new Date).toISOString(),data_fabric:!0,snapshot_enabled:!0}})});if(!r.ok)throw new Error(`NetApp Cloud sync failed: ${r.statusText}`);this.lastSync=new Date,this.emit("sync-completed",{adapter:this.name,timestamp:this.lastSync})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Sync failed",e}}async backup(e){const t=`netapp_backup_${Date.now()}`;try{const r=`${this.config.endpoints?.storage||"https://cloudmanager.netapp.com"}/api/v1/brolostack/backup`,i=await fetch(r,{method:"POST",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({name:t,data:e,backup_metadata:{backup_id:t,timestamp:(new Date).toISOString(),provider:"netapp",snapshot_policy:"daily",deduplication:!0,compression:!0}})});if(!i.ok)throw new Error(`NetApp Cloud backup failed: ${i.statusText}`);this.lastBackup=new Date,this.emit("backup-completed",{adapter:this.name,backupId:t,timestamp:this.lastBackup})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Backup failed",e}}async restore(){try{const e=`${this.config.endpoints?.storage||"https://cloudmanager.netapp.com"}/api/v1/brolostack/sync`,t=await fetch(e,{headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`}});if(!t.ok)throw new Error(`NetApp Cloud restore failed: ${t.statusText}`);const r=await t.json();return this.emit("restore-completed",{adapter:this.name,timestamp:new Date}),r}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Restore failed",e}}async syncStore(e,t){await this.sync({store:e,data:t,ontap_optimization:!0})}async restoreStore(e){const t=await this.restore();return t?.store===e?t.data:null}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this._errorCount,lastError:this.lastError??void 0}}getCapabilities(){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!1,maxDataSize:10737418240,supportedFormats:["json","binary","nfs","cifs","iscsi"]}}}class $e extends S{constructor(e){super(),this.name="dell-cloud",this.provider="Dell Technologies Cloud",this.connected=!1,this._errorCount=0,this.config=e}async connect(){try{this.connected=!0,this.emit("connected",{adapter:this.name})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Connection failed",e}}async disconnect(){this.connected=!1,this.emit("disconnected",{adapter:this.name})}isConnected(){return this.connected}async sync(e){if(!this.connected)throw new Error("Dell Cloud adapter not connected");try{const t=`${this.config.endpoints?.storage||"https://objectscale.dell.com"}/api/v1/brolostack/sync`,r=await fetch(t,{method:"POST",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({...e,dell_metadata:{objectscale_version:"1.2",timestamp:(new Date).toISOString(),powerprotect_integration:!0,vxrail_optimized:!0}})});if(!r.ok)throw new Error(`Dell Cloud sync failed: ${r.statusText}`);this.lastSync=new Date,this.emit("sync-completed",{adapter:this.name,timestamp:this.lastSync})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Sync failed",e}}async backup(e){const t=`dell_backup_${Date.now()}`;try{const r=`${this.config.endpoints?.storage||"https://powerprotect.dell.com"}/api/v1/brolostack/backup`,i=await fetch(r,{method:"POST",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({name:t,data:e,backup_metadata:{backup_id:t,timestamp:(new Date).toISOString(),provider:"dell-cloud",powerprotect_managed:!0,data_domain_integration:!0}})});if(!i.ok)throw new Error(`Dell Cloud backup failed: ${i.statusText}`);this.lastBackup=new Date,this.emit("backup-completed",{adapter:this.name,backupId:t,timestamp:this.lastBackup})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Backup failed",e}}async restore(){try{const e=`${this.config.endpoints?.storage||"https://objectscale.dell.com"}/api/v1/brolostack/sync`,t=await fetch(e,{headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`}});if(!t.ok)throw new Error(`Dell Cloud restore failed: ${t.statusText}`);const r=await t.json();return this.emit("restore-completed",{adapter:this.name,timestamp:new Date}),r}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Restore failed",e}}async syncStore(e,t){await this.sync({store:e,data:t,vxrail_integration:!0})}async restoreStore(e){const t=await this.restore();return t?.store===e?t.data:null}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this._errorCount,lastError:this.lastError??void 0}}getCapabilities(){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!1,maxDataSize:10737418240,supportedFormats:["json","binary","xml","s3"]}}}class Ne extends S{constructor(e){super(),this.name="cohesity",this.provider="Cohesity",this.connected=!1,this._errorCount=0,this.config=e}async connect(){try{this.connected=!0,this.emit("connected",{adapter:this.name})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Connection failed",e}}async disconnect(){this.connected=!1,this.emit("disconnected",{adapter:this.name})}isConnected(){return this.connected}async sync(e){if(!this.connected)throw new Error("Cohesity adapter not connected");try{const t=`${this.config.endpoints?.storage||"https://helios.cohesity.com"}/v2/brolostack/sync`,r=await fetch(t,{method:"POST",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({...e,cohesity_metadata:{cluster_id:this.config.credentials.tenantId,timestamp:(new Date).toISOString(),data_governance:!0,threat_detection:!0}})});if(!r.ok)throw new Error(`Cohesity sync failed: ${r.statusText}`);this.lastSync=new Date,this.emit("sync-completed",{adapter:this.name,timestamp:this.lastSync})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Sync failed",e}}async backup(e){const t=`cohesity_backup_${Date.now()}`;try{const r=`${this.config.endpoints?.storage||"https://helios.cohesity.com"}/v2/brolostack/backup`,i=await fetch(r,{method:"POST",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({name:t,data:e,backup_metadata:{backup_id:t,timestamp:(new Date).toISOString(),provider:"cohesity",protection_policy:"brolostack_policy",immutable:!0,ransomware_protection:!0}})});if(!i.ok)throw new Error(`Cohesity backup failed: ${i.statusText}`);this.lastBackup=new Date,this.emit("backup-completed",{adapter:this.name,backupId:t,timestamp:this.lastBackup})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Backup failed",e}}async restore(){try{const e=`${this.config.endpoints?.storage||"https://helios.cohesity.com"}/v2/brolostack/sync`,t=await fetch(e,{headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`}});if(!t.ok)throw new Error(`Cohesity restore failed: ${t.statusText}`);const r=await t.json();return this.emit("restore-completed",{adapter:this.name,timestamp:new Date}),r}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Restore failed",e}}async syncStore(e,t){await this.sync({store:e,data:t,immutable_backup:!0})}async restoreStore(e){const t=await this.restore();return t?.store===e?t.data:null}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this._errorCount,lastError:this.lastError??void 0}}getCapabilities(){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!1,maxDataSize:107374182400,supportedFormats:["json","binary","vm","database","file"]}}}class Pe extends S{constructor(e){super(),this.name="broadcom",this.provider="Broadcom",this.connected=!1,this._errorCount=0,this.config=e}async connect(){try{this.connected=!0,this.emit("connected",{adapter:this.name})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Connection failed",e}}async disconnect(){this.connected=!1,this.emit("disconnected",{adapter:this.name})}isConnected(){return this.connected}async sync(e){if(!this.connected)throw new Error("Broadcom adapter not connected");try{const t=`${this.config.endpoints?.storage||"https://api.broadcom.com"}/v1/brolostack/sync`,r=await fetch(t,{method:"POST",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({...e,broadcom_metadata:{timestamp:(new Date).toISOString(),enterprise_grade:!0}})});if(!r.ok)throw new Error(`Broadcom sync failed: ${r.statusText}`);this.lastSync=new Date,this.emit("sync-completed",{adapter:this.name,timestamp:this.lastSync})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Sync failed",e}}async backup(e){const t=`broadcom_backup_${Date.now()}`;try{const r=`${this.config.endpoints?.storage||"https://api.broadcom.com"}/v1/brolostack/backup`,i=await fetch(r,{method:"POST",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({name:t,data:e,backup_metadata:{backup_id:t,timestamp:(new Date).toISOString(),provider:"broadcom"}})});if(!i.ok)throw new Error(`Broadcom backup failed: ${i.statusText}`);this.lastBackup=new Date,this.emit("backup-completed",{adapter:this.name,backupId:t,timestamp:this.lastBackup})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Backup failed",e}}async restore(){try{const e=`${this.config.endpoints?.storage||"https://api.broadcom.com"}/v1/brolostack/sync`,t=await fetch(e,{headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`}});if(!t.ok)throw new Error(`Broadcom restore failed: ${t.statusText}`);const r=await t.json();return this.emit("restore-completed",{adapter:this.name,timestamp:new Date}),r}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Restore failed",e}}async syncStore(e,t){await this.sync({store:e,data:t})}async restoreStore(e){const t=await this.restore();return t?.store===e?t.data:null}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this._errorCount,lastError:this.lastError??void 0}}getCapabilities(){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!1,maxDataSize:1073741824,supportedFormats:["json","binary","xml"]}}}class Me extends S{constructor(){super(),this.providers=new Map,this.configs=new Map,this.logger=new m(!1,"CloudProviderFactory")}registerProvider(e){const t=this.createProviderAdapter(e);return this.providers.set(e.provider,t),this.configs.set(e.provider,e),this.emit("provider-registered",{provider:e.provider,config:e}),this.logger.info(`Registered cloud provider: ${e.provider}`),t}unregisterProvider(e){this.providers.delete(e),this.configs.delete(e),this.emit("provider-unregistered",{provider:e}),this.logger.info(`Unregistered cloud provider: ${e}`)}getProvider(e){const t=this.providers.get(e);if(!t)throw new Error(`Provider ${e} is not registered`);return t}async syncAcrossProviders(e,t,r){const i={};for(const e of t)try{const t=this.getProvider(e);await t.sync(r),i[e]={status:"success"}}catch(t){i[e]={status:"failed",error:t instanceof Error?t.message:"Unknown error"}}return this.emit("multi-cloud-sync-completed",{sourceProvider:e,targetProviders:t,results:i}),i}async backupAcrossProviders(e,t,r){const i={};try{const t=this.getProvider(e);await t.backup(r),i[e]={status:"success",type:"primary"}}catch(t){i[e]={status:"failed",error:t instanceof Error?t.message:"Unknown error",type:"primary"}}for(const e of t)try{const t=this.getProvider(e);await t.backup(r),i[e]={status:"success",type:"backup"}}catch(t){i[e]={status:"failed",error:t instanceof Error?t.message:"Unknown error",type:"backup"}}return this.emit("multi-cloud-backup-completed",{primaryProvider:e,backupProviders:t,results:i}),i}createProviderAdapter(e){switch(e.provider){case"aws":return new ze(e);case"azure":return new Le(e);case"gcp":return new Be(e);case"alibaba-cloud":return new je(e);case"ibm-cloud":return new be(e);case"oracle-cloud":return new Se(e);case"salesforce-cloud":return new ve(e);case"sap-cloud":return new Ee(e);case"digitalocean":return new Te(e);case"tencent-cloud":return new Ce(e);case"vmware-cloud":return new Ae(e);case"huawei-cloud":return new xe(e);case"cloudflare":return new De(e);case"coreweave":return new Ie(e);case"rackspace":return new _e(e);case"cisco-cloud":return new Oe(e);case"dell-cloud":return new $e(e);case"netapp":return new Re(e);case"broadcom":return new Pe(e);case"cohesity":return new Ne(e);case"redis-cloud":return new fe(e);case"mongodb-atlas":return new ke(e);default:throw new Error(`Unsupported cloud provider: ${e.provider}`)}}getRegisteredProviders(){return Array.from(this.providers.keys())}getProviderCapabilities(e){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!1,maxDataSize:1073741824,supportedFormats:["json","binary"]}}async testProvider(e){try{const t=this.getProvider(e);return await t.connect({}),await t.disconnect(),!0}catch(t){return this.logger.error(`Provider ${e} test failed:`,t),!1}}getStats(){return{registeredProviders:this.providers.size,providers:Array.from(this.providers.keys())}}}class ze extends S{constructor(e){super(),this.name="aws",this.provider="Amazon Web Services",this.connected=!1,this._errorCount=0,this.config=e}async connect(){try{this.connected=!0,this.emit("connected",{adapter:this.name})}catch(e){throw e}}async disconnect(){this.connected=!1,this.emit("disconnected",{adapter:this.name})}isConnected(){return this.connected}async sync(e){const t=`https://s3.${this.config.region}.amazonaws.com/brolostack-sync`,r=await fetch(t,{method:"PUT",headers:{Authorization:this.getAWSAuthHeader(),"Content-Type":"application/json"},body:JSON.stringify(e)});if(!r.ok)throw new Error(`AWS sync failed: ${r.statusText}`)}async backup(e){const t=`https://s3.${this.config.region}.amazonaws.com/brolostack-backup`,r=await fetch(t,{method:"PUT",headers:{Authorization:this.getAWSAuthHeader(),"Content-Type":"application/json"},body:JSON.stringify({data:e,timestamp:(new Date).toISOString(),backup_id:`backup_${Date.now()}`})});if(!r.ok)throw new Error(`AWS backup failed: ${r.statusText}`)}async restore(){const e=`https://s3.${this.config.region}.amazonaws.com/brolostack-sync`,t=await fetch(e,{headers:{Authorization:this.getAWSAuthHeader()}});if(!t.ok)throw new Error(`AWS restore failed: ${t.statusText}`);return await t.json()}async syncStore(e,t){await this.sync({store:e,data:t})}async restoreStore(e){return(await this.restore())[e]}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this._errorCount,lastError:this.lastError??void 0}}getCapabilities(){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!1,maxDataSize:1073741824,supportedFormats:["json","binary"]}}getAWSAuthHeader(){return`AWS4-HMAC-SHA256 Credential=${this.config.credentials.accessKeyId}`}}class Le extends S{constructor(e){super(),this.name="azure",this.provider="Microsoft Azure",this.connected=!1,this._errorCount=0,this.config=e}async connect(){try{this.connected=!0,this.emit("connected",{adapter:this.name})}catch(e){throw e}}async disconnect(){this.connected=!1,this.emit("disconnected",{adapter:this.name})}isConnected(){return this.connected}async sync(e){const t=`https://${this.config.endpoints?.storage}.blob.core.windows.net/brolostack/sync.json`,r=await fetch(t,{method:"PUT",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json","x-ms-blob-type":"BlockBlob"},body:JSON.stringify(e)});if(!r.ok)throw new Error(`Azure sync failed: ${r.statusText}`)}async backup(e){const t=`https://${this.config.endpoints?.storage}.blob.core.windows.net/brolostack/backup_${Date.now()}.json`,r=await fetch(t,{method:"PUT",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json","x-ms-blob-type":"BlockBlob"},body:JSON.stringify(e)});if(!r.ok)throw new Error(`Azure backup failed: ${r.statusText}`)}async restore(){const e=`https://${this.config.endpoints?.storage}.blob.core.windows.net/brolostack/sync.json`,t=await fetch(e,{headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`}});if(!t.ok)throw new Error(`Azure restore failed: ${t.statusText}`);return await t.json()}async syncStore(e,t){await this.sync({store:e,data:t})}async restoreStore(e){return(await this.restore())[e]}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this._errorCount,lastError:this.lastError??void 0}}getCapabilities(){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!1,maxDataSize:1073741824,supportedFormats:["json","binary"]}}}class Be extends S{constructor(e){super(),this.name="gcp",this.provider="Google Cloud Platform",this.connected=!1,this._errorCount=0,this.config=e}async connect(){try{this.connected=!0,this.emit("connected",{adapter:this.name})}catch(e){throw e}}async disconnect(){this.connected=!1,this.emit("disconnected",{adapter:this.name})}isConnected(){return this.connected}async sync(e){const t=await fetch("https://storage.googleapis.com/storage/v1/b/brolostack-sync/o/sync.json",{method:"POST",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify(e)});if(!t.ok)throw new Error(`GCP sync failed: ${t.statusText}`)}async backup(e){const t=`https://storage.googleapis.com/storage/v1/b/brolostack-backup/o/backup_${Date.now()}.json`,r=await fetch(t,{method:"POST",headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify(e)});if(!r.ok)throw new Error(`GCP backup failed: ${r.statusText}`)}async restore(){const e=await fetch("https://storage.googleapis.com/storage/v1/b/brolostack-sync/o/sync.json?alt=media",{headers:{Authorization:`Bearer ${this.config.credentials.apiKey}`}});if(!e.ok)throw new Error(`GCP restore failed: ${e.statusText}`);return await e.json()}async syncStore(e,t){await this.sync({store:e,data:t})}async restoreStore(e){return(await this.restore())[e]}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this._errorCount,lastError:this.lastError??void 0}}getCapabilities(){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!1,maxDataSize:1073741824,supportedFormats:["json","binary"]}}}class je extends S{constructor(e){super(),this.name="alibaba-cloud",this.provider="Alibaba Cloud",this.connected=!1,this._errorCount=0,this.config=e}async connect(){try{this.connected=!0,this.emit("connected",{adapter:this.name})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Unknown error",e}}async disconnect(){this.connected=!1,this.emit("disconnected",{adapter:this.name})}isConnected(){return this.connected}async sync(e){if(!this.connected)throw new Error("Alibaba Cloud adapter not connected");try{const t=`https://${this.config.endpoints?.storage||"brolostack"}.oss-${this.config.region||"cn-hangzhou"}.aliyuncs.com/sync.json`,r=await fetch(t,{method:"PUT",headers:{Authorization:this.getAlibabaAuthHeader("PUT","/sync.json"),"Content-Type":"application/json",Date:(new Date).toUTCString()},body:JSON.stringify(e)});if(!r.ok)throw new Error(`Alibaba Cloud sync failed: ${r.statusText}`);this.lastSync=new Date,this.emit("sync-completed",{adapter:this.name,timestamp:this.lastSync})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Sync failed",e}}async backup(e){if(!this.connected)throw new Error("Alibaba Cloud adapter not connected");try{const t=`backup_${Date.now()}`,r=`https://${this.config.endpoints?.storage||"brolostack"}.oss-${this.config.region||"cn-hangzhou"}.aliyuncs.com/${t}.json`,i=await fetch(r,{method:"PUT",headers:{Authorization:this.getAlibabaAuthHeader("PUT",`/${t}.json`),"Content-Type":"application/json",Date:(new Date).toUTCString()},body:JSON.stringify({data:e,timestamp:(new Date).toISOString(),backup_id:t,metadata:{version:"1.0",provider:"alibaba-cloud",region:this.config.region}})});if(!i.ok)throw new Error(`Alibaba Cloud backup failed: ${i.statusText}`);this.lastBackup=new Date,this.emit("backup-completed",{adapter:this.name,backupId:t,timestamp:this.lastBackup})}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Backup failed",e}}async restore(){if(!this.connected)throw new Error("Alibaba Cloud adapter not connected");try{const e=`https://${this.config.endpoints?.storage||"brolostack"}.oss-${this.config.region||"cn-hangzhou"}.aliyuncs.com/sync.json`,t=await fetch(e,{headers:{Authorization:this.getAlibabaAuthHeader("GET","/sync.json"),Date:(new Date).toUTCString()}});if(!t.ok)throw new Error(`Alibaba Cloud restore failed: ${t.statusText}`);const r=await t.json();return this.emit("restore-completed",{adapter:this.name,timestamp:new Date}),r}catch(e){throw this._errorCount++,this.lastError=e instanceof Error?e.message:"Restore failed",e}}async syncStore(e,t){await this.sync({store:e,data:t,timestamp:(new Date).toISOString()})}async restoreStore(e){const t=await this.restore();return t?.store===e?t.data:null}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this._errorCount,lastError:this.lastError??void 0}}getCapabilities(){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!0,maxDataSize:5368709120,supportedFormats:["json","binary","xml","text"]}}getAlibabaAuthHeader(e,t){const r=this.config.credentials.accessKeyId||"",i=this.config.credentials.secretAccessKey||"",s=`${e}\n\napplication/json\n${(new Date).toUTCString()}\n${t}`;return`OSS ${r}:${Buffer.from(`${i}:${s}`).toString("base64")}`}}class Ue extends S{constructor(e){super(),this.healthChecks=new Map,this.metrics=new Map,this.config=e,this.logger=new m(!1,"EnterpriseProviderManager"),this.aiFactory=new pe,this.cloudFactory=new Me}async initialize(){try{this.logger.info("Initializing Enterprise Provider Manager");for(const e of this.config.ai.providers)e.enabled&&this.aiFactory.registerProvider({provider:e.name,...e.config});for(const e of this.config.cloud.providers)e.enabled&&this.cloudFactory.registerProvider({provider:e.name,...e.config});this.config.monitoring.enabled&&(this.startHealthMonitoring(),this.startMetricsCollection()),this.emit("initialized",{aiProviders:this.config.ai.providers.filter(e=>e.enabled).length,cloudProviders:this.config.cloud.providers.filter(e=>e.enabled).length}),this.logger.info("Enterprise Provider Manager initialized successfully")}catch(e){throw this.logger.error("Failed to initialize Enterprise Provider Manager:",e),e}}async shutdown(){try{this.healthCheckInterval&&clearInterval(this.healthCheckInterval),this.metricsCollectionInterval&&clearInterval(this.metricsCollectionInterval);for(const e of this.config.cloud.providers)if(e.enabled)try{const t=this.cloudFactory.getProvider(e.name);await t.disconnect()}catch(t){this.logger.warn(`Failed to disconnect ${e.name}:`,t)}this.emit("shutdown"),this.logger.info("Enterprise Provider Manager shut down")}catch(e){throw this.logger.error("Error during shutdown:",e),e}}async generateText(e,t){const r=Date.now(),i=t?.provider||this.config.ai.defaultProvider;try{const s=await this.aiFactory.generateText(i,e,t),a=Date.now()-r;return this.updateMetrics(i,"ai",{requests:{total:1,successful:1,failed:0,averageLatency:a},usage:{dataTransferred:0,tokensUsed:s.usage?.totalTokens||0,computeTime:a,cost:.01}}),s}catch(r){if(this.updateMetrics(i,"ai",{requests:{total:1,successful:0,failed:1,averageLatency:0}}),this.config.ai.fallback.enabled)return this.tryAIFallback(e,t,i);throw r}}async chatCompletion(e,t){const r=Date.now(),i=t?.provider||this.config.ai.defaultProvider;try{const s=await this.aiFactory.chatCompletion(i,e,t),a=Date.now()-r;return this.updateMetrics(i,"ai",{requests:{total:1,successful:1,failed:0,averageLatency:a},usage:{dataTransferred:0,tokensUsed:s.usage?.totalTokens||0,computeTime:a,cost:.01}}),s}catch(r){if(this.updateMetrics(i,"ai",{requests:{total:1,successful:0,failed:1,averageLatency:0}}),this.config.ai.fallback.enabled)return this.tryAIChatFallback(e,t,i);throw r}}async syncData(e,t){const r=Date.now(),i=t?.provider||this.config.cloud.defaultProvider;try{const s=this.cloudFactory.getProvider(i);await s.sync(e);const a=Date.now()-r;return this.updateMetrics(i,"cloud",{requests:{total:1,successful:1,failed:0,averageLatency:a},usage:{dataTransferred:JSON.stringify(e).length,computeTime:a,cost:.01}}),t?.crossProvider&&this.config.cloud.backup.crossProvider&&await this.syncAcrossProviders(e,i),{status:"success",provider:i}}catch(e){throw this.updateMetrics(i,"cloud",{requests:{total:1,successful:0,failed:1,averageLatency:0}}),e}}async backupData(e,t){const r={};if(t?.crossProvider||this.config.cloud.backup.crossProvider){const t=this.config.cloud.providers.filter(e=>e.enabled).map(e=>e.name);for(const i of t)try{const t=this.cloudFactory.getProvider(i);await t.backup(e),r[i]={status:"success"}}catch(e){r[i]={status:"failed",error:e instanceof Error?e.message:"Unknown error"}}}else{const i=t?.provider||this.config.cloud.defaultProvider,s=this.cloudFactory.getProvider(i);await s.backup(e),r[i]={status:"success"}}return this.emit("backup-completed",{data:e,results:r}),r}async selectOptimalAIProvider(e,t){const r=this.config.ai.providers.filter(e=>e.enabled).map(e=>e.name);if(0===r.length)throw new Error("No AI providers available");if(1===r.length)return r[0]||this.config.ai.defaultProvider;switch(this.config.ai.loadBalancing.strategy){case"round-robin":return this.roundRobinSelection(r,"ai");case"weighted":return this.weightedSelection(r,"ai");case"cost-optimized":return this.costOptimizedSelection(r,e,t);case"performance-optimized":return this.performanceOptimizedSelection(r,e);default:return r[0]||this.config.ai.defaultProvider}}async selectOptimalCloudProvider(e,t){const r=this.config.cloud.providers.filter(e=>e.enabled).map(e=>e.name);if(0===r.length)throw new Error("No cloud providers available");if(1===r.length)return r[0]||this.config.cloud.defaultProvider;if(this.config.cloud.compliance.required.length>0){const e=await this.filterCompliantProviders(r);if(e.length>0)return e[0]||this.config.cloud.defaultProvider}return r[0]||this.config.cloud.defaultProvider}async startHealthMonitoring(){const e=async()=>{for(const e of this.config.ai.providers)e.enabled&&await this.checkProviderHealth(e.name,"ai");for(const e of this.config.cloud.providers)e.enabled&&await this.checkProviderHealth(e.name,"cloud")};await e(),this.healthCheckInterval=setInterval(e,6e4)}async checkProviderHealth(e,t){const r=Date.now();try{let i=!1;i="ai"===t?await this.aiFactory.testProvider(e):await this.cloudFactory.testProvider(e);const s={provider:e,type:t,status:i?"healthy":"unhealthy",latency:Date.now()-r,uptime:100,errorRate:0,lastCheck:new Date,capabilities:"ai"===t?this.aiFactory.getProviderCapabilities(e):this.cloudFactory.getProviderCapabilities(e)};this.healthChecks.set(`${t}:${e}`,s),this.emit("health-check-completed",s),i||(this.emit("provider-unhealthy",{provider:e,type:t}),this.logger.warn(`Provider ${e} (${t}) is unhealthy`))}catch(i){const s={provider:e,type:t,status:"unhealthy",latency:Date.now()-r,uptime:0,errorRate:100,lastCheck:new Date,capabilities:{}};this.healthChecks.set(`${t}:${e}`,s),this.emit("health-check-failed",{provider:e,type:t,error:i}),this.logger.error(`Health check failed for ${e} (${t}):`,i)}}startMetricsCollection(){return this.metricsCollectionInterval=setInterval(()=>{this.collectMetrics()},3e5),Promise.resolve()}async collectMetrics(){try{for(const e of this.config.ai.providers)if(e.enabled){const t={provider:e.name,type:"ai",requests:{total:100,successful:95,failed:5,averageLatency:250},usage:{dataTransferred:1048576,tokensUsed:5e4,computeTime:3600,cost:2.5},timeRange:{start:new Date(Date.now()-3e5),end:new Date}};this.metrics.set(`ai:${e.name}`,t)}for(const e of this.config.cloud.providers)if(e.enabled){const t={provider:e.name,type:"cloud",requests:{total:50,successful:48,failed:2,averageLatency:150},usage:{dataTransferred:10485760,computeTime:1800,cost:.5},timeRange:{start:new Date(Date.now()-3e5),end:new Date}};this.metrics.set(`cloud:${e.name}`,t)}this.emit("metrics-collected",{timestamp:new Date,providers:this.metrics.size})}catch(e){this.logger.error("Failed to collect metrics:",e)}}roundRobinSelection(e,t){const r=`${t}_round_robin_index`,i=global[r]||0,s=e[i%e.length];return global[r]=i+1,s}weightedSelection(e,t){const r="ai"===t?this.config.ai.providers:this.config.cloud.providers,i=e.map(e=>{const t=r.find(t=>t.name===e);return t?.priority||1}),s=i.reduce((e,t)=>e+t,0),a=Math.random()*s;let n=0;for(let t=0;t<e.length;t++){const r=i[t];if(void 0!==r&&(n+=r),a<=n)return e[t]}return e[0]}async costOptimizedSelection(e,t,r){let i=1/0,s=e[0];for(const a of e)try{const e=await this.estimateProviderCost(a,t,r);e<i&&(i=e,s=a)}catch(e){this.logger.warn(`Failed to estimate cost for ${a}:`,e)}return s}async performanceOptimizedSelection(e,t){let r=1/0,i=e[0];for(const t of e){const e=this.healthChecks.get(`ai:${t}`)||this.healthChecks.get(`cloud:${t}`);e&&e.latency<r&&(r=e.latency,i=t)}return i}async tryAIFallback(e,t,r){const i=this.config.ai.providers.filter(e=>e.enabled&&e.name!==r).sort((e,t)=>t.priority-e.priority).map(e=>e.name);for(const r of i)try{return this.logger.info(`Trying AI fallback provider: ${r}`),await this.aiFactory.generateText(r,e,{...t,provider:r})}catch(e){this.logger.warn(`Fallback provider ${r} also failed:`,e)}throw new Error("All AI providers failed")}async tryAIChatFallback(e,t,r){const i=this.config.ai.providers.filter(e=>e.enabled&&e.name!==r).sort((e,t)=>t.priority-e.priority).map(e=>e.name);for(const r of i)try{return this.logger.info(`Trying AI chat fallback provider: ${r}`),await this.aiFactory.chatCompletion(r,e,{...t,provider:r})}catch(e){this.logger.warn(`Fallback provider ${r} also failed:`,e)}throw new Error("All AI providers failed")}async syncAcrossProviders(e,t){const r=this.config.cloud.providers.filter(e=>e.enabled&&e.name!==t).map(e=>e.name);await this.cloudFactory.syncAcrossProviders(t,r,e)}async estimateProviderCost(e,t,r){return 10*Math.random()}async filterCompliantProviders(e){const t=[];for(const r of e)try{const e=this.cloudFactory.getProvider(r).getCapabilities();this.config.cloud.compliance.required.every(t=>e.supportedFormats?.includes(t)||!1)&&t.push(r)}catch(e){this.logger.warn(`Failed to check compliance for ${r}:`,e)}return t}updateMetrics(e,t,r){const i=`${t}:${e}`,s=this.metrics.get(i);s&&this.metrics.set(i,{...s,...r})}getProviderHealth(e){if(e){const t=this.healthChecks.get(e);return t?[t]:[]}return Array.from(this.healthChecks.values())}getProviderMetrics(e){if(e){const t=this.metrics.get(e);return t?[t]:[]}return Array.from(this.metrics.values())}getRegisteredProviders(){return{ai:this.aiFactory.getRegisteredProviders(),cloud:this.cloudFactory.getRegisteredProviders()}}getConfig(){return{...this.config}}updateConfig(e){this.config={...this.config,...e},this.emit("config-updated",this.config)}getStats(){return{aiProviders:this.aiFactory.getStats(),cloudProviders:this.cloudFactory.getStats(),healthChecks:this.healthChecks.size,metricsCollected:this.metrics.size,monitoringEnabled:this.config.monitoring.enabled}}}class Fe{constructor(e){this.isInitialized=!1,this.startTime=Date.now();const t=P.applyToConfig(e);this.config={storageEngine:"localStorage",encryption:!1,compression:!1,maxStorageSize:100,debug:!1,...t},j("info","Brolostack initializing",{environment:M(),appName:this.config.appName,version:this.config.version,debug:this.config.debug}),this.logger=new m(this.config.debug),this.eventEmitter=new S,this.stores=new Map,this.storage=new g({name:this.config.appName,version:parseInt(this.config.version)||1,size:this.config.maxStorageSize||52428800}),this.api=new y(this.storage),this.aiManager=new w(this.storage,this.eventEmitter),this.ai={agents:this.aiManager.agents,createAgent:e=>this.aiManager.createAgent(e),getAgent:e=>this.aiManager.getAgent(e),removeAgent:e=>this.aiManager.removeAgent(e),runAgent:async(e,t)=>{const r=this.aiManager.getAgent(e);if(!r)throw new Error(`Agent ${e} not found`);return await r.execute(t)},getMemory:async()=>await this.aiManager.exportMemory(),storeMemory:async(e,t,r,i)=>await this.aiManager.storeMemory(e,t,r,i),clearMemory:async()=>await this.aiManager.clearMemory(),getMemoryStats:()=>this.aiManager.getMemoryStats()},this.initializeEnterpriseFeatures(),this.logger.info("Brolostack initialized",{appName:this.config.appName,version:this.config.version})}async initializeCloudIntegration(e){try{const{CloudBrolostack:t}=await Promise.resolve().then(function(){return lt});this.cloud=new t(e)}catch(e){this.logger.error("Failed to initialize cloud integration:",e)}}initializeEnterpriseFeatures(){const e=this.config.enterprise;e?.auth?.enabled&&(this.auth=new v(e.auth),this.logger.info("Enterprise Authentication enabled")),e?.realtime?.enabled&&(this.realtime=new q(e.realtime),this.logger.info("Real-time WebSocket Manager enabled")),e?.mrm?.enabled&&(this.ssr=new H(this,e.mrm),this.logger.info("Multi-Rendering Mode (MRM) enabled")),e?.worker?.enabled&&(this.worker=new Q(e.worker),this.logger.info("Brolostack Worker enabled")),e?.security?.enabled&&(this.security=new te(e.security),this.logger.info("Enterprise Security Framework enabled")),e?.providers?.enabled&&(this.providers=new Ue(e.providers),this.logger.info("Enterprise Provider Manager enabled")),e?.cloud?.enabled&&this.logger.info("Cloud Integration scheduled for async initialization")}async initialize(){if(this.isInitialized)this.logger.warn("Brolostack already initialized");else try{"initialize"in this.storage&&"function"==typeof this.storage.initialize&&await this.storage.initialize(),await this.aiManager.initialize(),await this.initializeEnterpriseComponents(),this.eventEmitter.emit("initialized",{appName:this.config.appName,version:this.config.version}),this.isInitialized=!0,this.logger.info("Brolostack initialization completed")}catch(e){const t={name:"BrolostackInitializationError",message:`Failed to initialize Brolostack: ${e instanceof Error?e.message:"Unknown error"}`,code:"INITIALIZATION_FAILED",context:{config:this.config},timestamp:Date.now()};throw this.logger.error("Brolostack initialization failed",t),t}}async initializeEnterpriseComponents(){try{this.auth&&this.logger.info("Authentication Manager initialized"),this.realtime&&(await this.realtime.connect(),this.logger.info("WebSocket Manager initialized")),this.worker&&(await this.worker.initialize(),this.logger.info("Brolostack Worker initialized")),this.security&&this.logger.info("Security Framework initialized"),this.providers&&(await this.providers.initialize(),this.logger.info("Enterprise Provider Manager initialized"));const e=this.config.enterprise;e?.cloud?.enabled&&(await this.initializeCloudIntegration(e.cloud),this.logger.info("Cloud Integration initialized"))}catch(e){const t="Failed to initialize enterprise components";throw this.logger.error(t,e),U(e instanceof Error?e:new Error(t),{component:"EnterpriseComponents",config:this.config.enterprise}),e}}createStore(e,t){if(this.stores.has(e))return this.logger.warn(`Store '${e}' already exists, returning existing store`),this.stores.get(e);const r=new qe(e,t,this.storage,this.eventEmitter);return this.stores.set(e,r),this.logger.info(`Store '${e}' created`,{initialState:t}),this.eventEmitter.emit("store:created",{name:e,initialState:t}),r}getStore(e){return this.stores.get(e)}removeStore(e){const t=this.stores.get(e);return!!t&&(t.clear(),this.stores.delete(e),this.logger.info(`Store '${e}' removed`),this.eventEmitter.emit("store:removed",{name:e}),!0)}getStoreNames(){return Array.from(this.stores.keys())}clearAllStores(){this.stores.forEach((e,t)=>{e.clear(),this.logger.info(`Store '${t}' cleared`)}),this.eventEmitter.emit("stores:cleared",{count:this.stores.size})}async exportData(){const e={};for(const[t,r]of this.stores)e[t]=r.getState();return e._aiMemory=await this.aiManager.exportMemory(),e._metadata={appName:this.config.appName,version:this.config.version,exportDate:(new Date).toISOString(),storeCount:this.stores.size,aiAgentCount:this.ai.agents.size},this.logger.info("Data exported",{storeCount:this.stores.size,aiAgentCount:this.ai.agents.size}),this.eventEmitter.emit("data:exported",{storeCount:this.stores.size,aiAgentCount:this.ai.agents.size}),e}async importData(e){try{for(const[t,r]of Object.entries(e)){if(t.startsWith("_"))continue;let e=this.stores.get(t);e?e.setState(r):e=this.createStore(t,r)}e._aiMemory&&await this.aiManager.importMemory(e._aiMemory),this.logger.info("Data imported successfully",{storeCount:Object.keys(e).filter(e=>!e.startsWith("_")).length}),this.eventEmitter.emit("data:imported",{storeCount:Object.keys(e).filter(e=>!e.startsWith("_")).length})}catch(e){throw this.logger.error("Data import failed:",e),e}}getStats(){const e=P.getPerformanceOptimizations(),t={stores:this.stores.size,aiAgents:this.ai.agents.size,storageSize:"getSize"in this.storage&&"function"==typeof this.storage.getSize?this.storage.getSize():0,uptime:Date.now()-this.startTime,version:this.config.version,environment:{current:M(),debug:z(),performance:e,security:P.getSecurityConfig()}};return this.hasEnterpriseFeatures()&&(t.enterprise={auth:!!this.auth,realtime:!!this.realtime,mrm:!!this.ssr,worker:!!this.worker,security:!!this.security,providers:!!this.providers,cloud:!!this.cloud}),t}hasEnterpriseFeatures(){return!!(this.auth||this.realtime||this.ssr||this.worker||this.security||this.providers||this.cloud)}getEnterpriseStatus(){const e=[];return this.auth&&e.push("authentication"),this.realtime&&e.push("realtime"),this.ssr&&e.push("mrm"),this.worker&&e.push("worker"),this.security&&e.push("security"),this.providers&&e.push("providers"),this.cloud&&e.push("cloud"),{enabled:e.length>0,features:e,version:"1.0.2"}}persist(e){this.stores.forEach((t,r)=>{"persist"in t&&"function"==typeof t.persist&&t.persist(e)}),this.logger.info("All stores persisted"),this.eventEmitter.emit("stores:persisted",{count:this.stores.size})}destroy(){this.logger.info("Destroying Brolostack instance"),this.destroyEnterpriseComponents(),this.clearAllStores(),this.ai.clearMemory(),this.eventEmitter.emit("destroyed",{appName:this.config.appName,version:this.config.version}),this.isInitialized=!1,this.logger.info("Brolostack instance destroyed")}destroyEnterpriseComponents(){try{this.realtime&&(this.realtime.disconnect(),this.logger.info("WebSocket Manager disconnected")),this.worker&&this.logger.info("Brolostack Worker terminated"),this.providers&&this.logger.info("Enterprise Provider Manager destroyed"),this.cloud&&this.logger.info("Cloud Integration destroyed")}catch(e){this.logger.error("Error destroying enterprise components:",e)}}getEventEmitter(){return this.eventEmitter}getLogger(){return this.logger}}class qe{constructor(e,t,r,i){this.name=e,this.storage=r,this.eventEmitter=i,this.listeners=new Set,this.isPersisted=!1,this.persistConfig=null,this.state=t}getState(){return this.state}setState(e){const t=this.state;this.state={...this.state,...e},this.listeners.forEach(e=>e(this.state)),this.eventEmitter.emit("store:updated",{name:this.name,oldState:t,newState:this.state}),this.isPersisted&&this.saveToStorage()}subscribe(e){return this.listeners.add(e),()=>{this.listeners.delete(e)}}persist(e){this.persistConfig=e,this.isPersisted=!0,this.saveToStorage()}async saveToStorage(){try{await this.storage.setItem(`store:${this.name}`,JSON.stringify({state:this.state,config:this.persistConfig,timestamp:Date.now()}))}catch(e){this.logger.error(`Failed to persist store '${this.name}'`,e)}}async loadFromStorage(){try{const e=await this.storage.getItem(`store:${this.name}`);if(e&&"string"==typeof e){const t=JSON.parse(e);t&&"object"==typeof t&&"state"in t&&(this.state=t.state,this.persistConfig=t.config,this.isPersisted=!0)}}catch(e){this.logger.error(`Failed to load store '${this.name}'`,e)}}clear(){this.state={},this.listeners.clear(),this.isPersisted=!1,this.persistConfig=null,this.storage.removeItem(`store:${this.name}`),this.eventEmitter.emit("store:cleared",{name:this.name})}reset(){this.state={},this.listeners.clear(),this.isPersisted=!1,this.persistConfig=null,this.storage.removeItem(`store:${this.name}`),this.eventEmitter.emit("store:reset",{name:this.name})}}const He=t(null);function Ke({appName:e,config:t,children:s,initialData:a,ssrMode:n="client",hydrationStrategy:o="immediate"}){const[c,l]=r(null),[h,d]=r(new Map),[u,m]=r(!1),[g,y]=r("client"===n);i(()=>((async()=>{try{const r={appName:e,version:t?.version||"1.0.0",...t,enterprise:{...t?.enterprise,mrm:{enabled:"client"!==n,mode:"client"===n?"ssr":n,hydration:{strategy:o},...t?.enterprise?.mrm}}},i=new Fe(r);await i.initialize(),a&&Object.keys(a).length>0&&await i.importData(a),l(i),d(i.stores),m(!0),"client"!==n&&await f(o)}catch(e){console.error("Failed to initialize Brolostack:",e)}})(),()=>{c&&c.destroy()}),[e,t,n,o,a]);const f=async e=>{try{switch(e){case"immediate":default:y(!0);break;case"lazy":setTimeout(()=>y(!0),100);break;case"on-demand":const e=()=>{y(!0),document.removeEventListener("click",e),document.removeEventListener("scroll",e),document.removeEventListener("keydown",e)};document.addEventListener("click",e),document.addEventListener("scroll",e),document.addEventListener("keydown",e)}}catch(e){console.error("Hydration failed:",e),y(!0)}},w={app:c,stores:h};return u&&c?"client"===n||g?p.jsx(He.Provider,{value:w,children:s}):p.jsx(He.Provider,{value:{app:c,stores:h},children:p.jsx("div",{suppressHydrationWarning:!0,children:s})}):p.jsx("div",{children:"Initializing Brolostack..."})}function Je(){const e=s(He);if(!e)throw new Error("useBrolostack must be used within a BrolostackProvider");return e}function Qe(e){const{stores:t}=Je(),r=t.get(e);if(!r)throw new Error(`Store '${e}' not found`);return r}function We(e,t){const s=Qe(e),[a,n]=r(()=>{const e=s.getState();return t?t(e):e});return i(()=>s.subscribe(e=>{const r=t?t(e):e;n(r)}),[s,t]),a}function Ge(){const{app:e}=Je();if(!e.auth)throw new Error("Authentication not enabled. Enable auth in enterprise config.");return e.auth}function Ve(){const{app:e}=Je();if(!e.realtime)throw new Error("Real-time features not enabled. Enable realtime in enterprise config.");return e.realtime}function Xe(){const{app:e}=Je();if(!e.ssr)throw new Error("MRM not enabled. Enable mrm in enterprise config.");return e.ssr}function Ye(){const{app:e}=Je();if(!e.security)throw new Error("Security features not enabled. Enable security in enterprise config.");return e.security}function Ze(){const{app:e}=Je();if(!e.providers)throw new Error("Provider management not enabled. Enable providers in enterprise config.");return e.providers}function et(){const{app:e}=Je();if(!e.cloud)throw new Error("Cloud integration not enabled. Enable cloud in enterprise config.");return e.cloud}function tt(){const{app:e}=Je();return{isEnabled:e.hasEnterpriseFeatures?.()||!1,status:e.getEnterpriseStatus?.()||{enabled:!1,features:[],version:"1.0.2"},features:{auth:!!e.auth,realtime:!!e.realtime,mrm:!!e.ssr,worker:!!e.worker,security:!!e.security,providers:!!e.providers,cloud:!!e.cloud}}}class rt{constructor(e){this.selectClause=["*"],this.fromClause="",this.whereConditions=[],this.joinClauses=[],this.groupByClause=[],this.havingConditions=[],this.orderByClause=[],this.params=[],this.dialect=e}select(e){return e&&e.length>0&&(this.selectClause=e),this}from(e){return this.fromClause=e,this}where(e){return"string"==typeof e?this.whereConditions.push(e):Object.entries(e).forEach(([e,t])=>{this.whereConditions.push(`${e} = ?`),this.params.push(t)}),this}join(e,t,r="INNER"){return this.joinClauses.push(`${r} JOIN ${e} ON ${t}`),this}groupBy(e){return this.groupByClause=e,this}having(e){return"string"==typeof e?this.havingConditions.push(e):Object.entries(e).forEach(([e,t])=>{this.havingConditions.push(`${e} = ?`),this.params.push(t)}),this}orderBy(e,t="ASC"){return this.orderByClause.push(`${e} ${t}`),this}limit(e){return this.limitClause=e,this}offset(e){return this.offsetClause=e,this}build(){let e=`SELECT ${this.selectClause.join(", ")} FROM ${this.fromClause}`;return this.joinClauses.length>0&&(e+=` ${this.joinClauses.join(" ")}`),this.whereConditions.length>0&&(e+=` WHERE ${this.whereConditions.join(" AND ")}`),this.groupByClause.length>0&&(e+=` GROUP BY ${this.groupByClause.join(", ")}`),this.havingConditions.length>0&&(e+=` HAVING ${this.havingConditions.join(" AND ")}`),this.orderByClause.length>0&&(e+=` ORDER BY ${this.orderByClause.join(", ")}`),void 0!==this.limitClause&&("mssql"===this.dialect?e=e.replace("SELECT",`SELECT TOP ${this.limitClause}`):e+=` LIMIT ${this.limitClause}`),void 0!==this.offsetClause&&"mssql"!==this.dialect&&(e+=` OFFSET ${this.offsetClause}`),{sql:e,params:this.params}}}var it=Object.freeze({__proto__:null,SQLAdapter:class extends S{constructor(e){super(),this.name="sql",this.connected=!1,this.errorCount=0,this.config=e,this.provider=`SQL (${e.dialect})`,this.logger=new m(!1,"SQLAdapter")}async connect(){try{await this.testConnection(),this.config.migrations?.enabled&&await this.runMigrations(),this.connected=!0,this.emit("connected",{adapter:this.name,dialect:this.config.dialect}),this.logger.info(`Connected to ${this.config.dialect} database`)}catch(e){throw this.errorCount++,this.lastError=e instanceof Error?e.message:"Connection failed",this.emit("error",{error:e,adapter:this.name}),e}}async disconnect(){this.connected=!1,this.emit("disconnected",{adapter:this.name}),this.logger.info(`Disconnected from ${this.config.dialect} database`)}isConnected(){return this.connected}async sync(e){if(!this.connected)throw new Error("SQL adapter is not connected");try{await this.ensureSyncTable(),await this.executeQuery("\n        INSERT INTO brolostack_sync (data, timestamp, checksum, sync_type)\n        VALUES (?, ?, ?, ?)\n      ",[JSON.stringify(e),new Date,this.generateChecksum(e),"full"]),this.lastSync=new Date,this.emit("sync-completed",{data:e,adapter:this.name})}catch(e){throw this.errorCount++,this.lastError=e instanceof Error?e.message:"Sync failed",this.emit("sync-failed",{error:e,adapter:this.name}),e}}async backup(e){if(!this.connected)throw new Error("SQL adapter is not connected");try{await this.ensureBackupTable();const t=`backup_${Date.now()}`;await this.executeQuery("\n        INSERT INTO brolostack_backups (backup_id, data, timestamp, size, checksum)\n        VALUES (?, ?, ?, ?, ?)\n      ",[t,JSON.stringify(e),new Date,JSON.stringify(e).length,this.generateChecksum(e)]),this.lastBackup=new Date,this.emit("backup-completed",{data:e,backupId:t,adapter:this.name})}catch(e){throw this.errorCount++,this.lastError=e instanceof Error?e.message:"Backup failed",this.emit("backup-failed",{error:e,adapter:this.name}),e}}async restore(){if(!this.connected)throw new Error("SQL adapter is not connected");try{const e=await this.executeQuery("\n        SELECT data FROM brolostack_sync \n        ORDER BY timestamp DESC \n        LIMIT 1\n      ");if(0===e.length)throw new Error("No sync data found");const t=JSON.parse(e[0].data);return this.emit("restore-completed",{data:t,adapter:this.name}),t}catch(e){throw this.errorCount++,this.lastError=e instanceof Error?e.message:"Restore failed",this.emit("restore-failed",{error:e,adapter:this.name}),e}}async syncStore(e,t){if(!this.connected)throw new Error("SQL adapter is not connected");try{await this.ensureStoreTable();const r=this.getUpsertQuery();await this.executeQuery(r,[e,JSON.stringify(t),new Date,this.generateChecksum(t)]),this.emit("store-sync-completed",{storeName:e,data:t,adapter:this.name})}catch(t){throw this.errorCount++,this.lastError=t instanceof Error?t.message:"Store sync failed",this.emit("store-sync-failed",{storeName:e,error:t,adapter:this.name}),t}}async restoreStore(e){if(!this.connected)throw new Error("SQL adapter is not connected");try{const t=await this.executeQuery("\n        SELECT data FROM brolostack_stores \n        WHERE store_name = ? \n        ORDER BY timestamp DESC \n        LIMIT 1\n      ",[e]);if(0===t.length)return null;const r=JSON.parse(t[0].data);return this.emit("store-restore-completed",{storeName:e,data:r,adapter:this.name}),r}catch(t){throw this.errorCount++,this.lastError=t instanceof Error?t.message:"Store restore failed",this.emit("store-restore-failed",{storeName:e,error:t,adapter:this.name}),t}}async executeQuery(e,t){if(!this.connected)throw new Error("SQL adapter is not connected");try{const r=await fetch("/api/sql/query",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({sql:e,params:t,dialect:this.config.dialect,database:this.config.database})});if(!r.ok)throw new Error(`SQL query failed: ${r.statusText}`);const i=await r.json();return this.emit("query-executed",{sql:e,params:t,result:i,dialect:this.config.dialect}),i.rows||i}catch(e){throw this.logger.error("SQL query failed:",e),e}}createQueryBuilder(){return new rt(this.config.dialect)}async runMigrations(){if(this.config.migrations?.enabled)try{await this.ensureMigrationTable();const e=await fetch("/api/sql/migrations/run",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({dialect:this.config.dialect,database:this.config.database,directory:this.config.migrations.directory})});if(!e.ok)throw new Error(`Migration failed: ${e.statusText}`);const t=await e.json();this.emit("migrations-completed",{result:t}),this.logger.info(`Ran ${t.executed} migrations`)}catch(e){throw this.logger.error("Migration failed:",e),e}}async createMigration(e,t,r){const i={version:Date.now().toString(),name:e,up:t,down:r,timestamp:new Date},s=await fetch("/api/sql/migrations/create",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({migration:i,dialect:this.config.dialect})});if(!s.ok)throw new Error(`Migration creation failed: ${s.statusText}`);const a=await s.json();return this.emit("migration-created",{migration:i,filename:a.filename}),a.filename}async testConnection(){const e={postgresql:"SELECT 1",mysql:"SELECT 1",sqlite:"SELECT 1",mssql:"SELECT 1",oracle:"SELECT 1 FROM DUAL",mariadb:"SELECT 1"}[this.config.dialect];await this.executeQuery(e)}getUpsertQuery(){return{postgresql:"\n        INSERT INTO brolostack_stores (store_name, data, timestamp, checksum)\n        VALUES (?, ?, ?, ?)\n        ON CONFLICT (store_name)\n        DO UPDATE SET data = EXCLUDED.data, timestamp = EXCLUDED.timestamp, checksum = EXCLUDED.checksum\n      ",mysql:"\n        INSERT INTO brolostack_stores (store_name, data, timestamp, checksum)\n        VALUES (?, ?, ?, ?)\n        ON DUPLICATE KEY UPDATE data = VALUES(data), timestamp = VALUES(timestamp), checksum = VALUES(checksum)\n      ",sqlite:"\n        INSERT OR REPLACE INTO brolostack_stores (store_name, data, timestamp, checksum)\n        VALUES (?, ?, ?, ?)\n      ",mssql:"\n        MERGE brolostack_stores AS target\n        USING (VALUES (?, ?, ?, ?)) AS source (store_name, data, timestamp, checksum)\n        ON target.store_name = source.store_name\n        WHEN MATCHED THEN UPDATE SET data = source.data, timestamp = source.timestamp, checksum = source.checksum\n        WHEN NOT MATCHED THEN INSERT (store_name, data, timestamp, checksum) VALUES (source.store_name, source.data, source.timestamp, source.checksum);\n      ",oracle:"\n        MERGE INTO brolostack_stores target\n        USING (SELECT ? as store_name, ? as data, ? as timestamp, ? as checksum FROM DUAL) source\n        ON (target.store_name = source.store_name)\n        WHEN MATCHED THEN UPDATE SET data = source.data, timestamp = source.timestamp, checksum = source.checksum\n        WHEN NOT MATCHED THEN INSERT (store_name, data, timestamp, checksum) VALUES (source.store_name, source.data, source.timestamp, source.checksum)\n      ",mariadb:"\n        INSERT INTO brolostack_stores (store_name, data, timestamp, checksum)\n        VALUES (?, ?, ?, ?)\n        ON DUPLICATE KEY UPDATE data = VALUES(data), timestamp = VALUES(timestamp), checksum = VALUES(checksum)\n      "}[this.config.dialect]}async ensureSyncTable(){const e={postgresql:"\n        CREATE TABLE IF NOT EXISTS brolostack_sync (\n          id SERIAL PRIMARY KEY,\n          data JSONB NOT NULL,\n          timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n          checksum VARCHAR(64),\n          sync_type VARCHAR(20) DEFAULT 'full'\n        );\n        CREATE INDEX IF NOT EXISTS idx_brolostack_sync_timestamp ON brolostack_sync(timestamp);\n      ",mysql:"\n        CREATE TABLE IF NOT EXISTS brolostack_sync (\n          id INT AUTO_INCREMENT PRIMARY KEY,\n          data LONGTEXT NOT NULL,\n          timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n          checksum VARCHAR(64),\n          sync_type VARCHAR(20) DEFAULT 'full',\n          INDEX idx_timestamp (timestamp)\n        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n      ",sqlite:"\n        CREATE TABLE IF NOT EXISTS brolostack_sync (\n          id INTEGER PRIMARY KEY AUTOINCREMENT,\n          data TEXT NOT NULL,\n          timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\n          checksum TEXT,\n          sync_type TEXT DEFAULT 'full'\n        );\n        CREATE INDEX IF NOT EXISTS idx_brolostack_sync_timestamp ON brolostack_sync(timestamp);\n      ",mssql:"\n        IF NOT EXISTS (SELECT * FROM sysobjects WHERE name='brolostack_sync' AND xtype='U')\n        CREATE TABLE brolostack_sync (\n          id INT IDENTITY(1,1) PRIMARY KEY,\n          data NVARCHAR(MAX) NOT NULL,\n          timestamp DATETIME2 DEFAULT GETUTCDATE(),\n          checksum VARCHAR(64),\n          sync_type VARCHAR(20) DEFAULT 'full'\n        );\n        IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name='idx_brolostack_sync_timestamp')\n        CREATE INDEX idx_brolostack_sync_timestamp ON brolostack_sync(timestamp);\n      ",oracle:"\n        BEGIN\n          EXECUTE IMMEDIATE 'CREATE TABLE brolostack_sync (\n            id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,\n            data CLOB NOT NULL,\n            timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n            checksum VARCHAR2(64),\n            sync_type VARCHAR2(20) DEFAULT ''full''\n          )';\n        EXCEPTION\n          WHEN OTHERS THEN\n            IF SQLCODE != -955 THEN RAISE; END IF;\n        END;\n      ",mariadb:"\n        CREATE TABLE IF NOT EXISTS brolostack_sync (\n          id INT AUTO_INCREMENT PRIMARY KEY,\n          data LONGTEXT NOT NULL,\n          timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n          checksum VARCHAR(64),\n          sync_type VARCHAR(20) DEFAULT 'full',\n          INDEX idx_timestamp (timestamp)\n        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n      "}[this.config.dialect];await this.executeQuery(e)}async ensureBackupTable(){const e={postgresql:"\n        CREATE TABLE IF NOT EXISTS brolostack_backups (\n          id SERIAL PRIMARY KEY,\n          backup_id VARCHAR(100) UNIQUE NOT NULL,\n          data JSONB NOT NULL,\n          timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n          size INTEGER,\n          checksum VARCHAR(64)\n        );\n        CREATE INDEX IF NOT EXISTS idx_brolostack_backups_timestamp ON brolostack_backups(timestamp);\n        CREATE INDEX IF NOT EXISTS idx_brolostack_backups_backup_id ON brolostack_backups(backup_id);\n      ",mysql:"\n        CREATE TABLE IF NOT EXISTS brolostack_backups (\n          id INT AUTO_INCREMENT PRIMARY KEY,\n          backup_id VARCHAR(100) UNIQUE NOT NULL,\n          data LONGTEXT NOT NULL,\n          timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n          size INT,\n          checksum VARCHAR(64),\n          INDEX idx_timestamp (timestamp),\n          INDEX idx_backup_id (backup_id)\n        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n      ",sqlite:"\n        CREATE TABLE IF NOT EXISTS brolostack_backups (\n          id INTEGER PRIMARY KEY AUTOINCREMENT,\n          backup_id TEXT UNIQUE NOT NULL,\n          data TEXT NOT NULL,\n          timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\n          size INTEGER,\n          checksum TEXT\n        );\n        CREATE INDEX IF NOT EXISTS idx_brolostack_backups_timestamp ON brolostack_backups(timestamp);\n      ",mssql:"\n        IF NOT EXISTS (SELECT * FROM sysobjects WHERE name='brolostack_backups' AND xtype='U')\n        CREATE TABLE brolostack_backups (\n          id INT IDENTITY(1,1) PRIMARY KEY,\n          backup_id VARCHAR(100) UNIQUE NOT NULL,\n          data NVARCHAR(MAX) NOT NULL,\n          timestamp DATETIME2 DEFAULT GETUTCDATE(),\n          size INT,\n          checksum VARCHAR(64)\n        );\n      ",oracle:"\n        BEGIN\n          EXECUTE IMMEDIATE 'CREATE TABLE brolostack_backups (\n            id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,\n            backup_id VARCHAR2(100) UNIQUE NOT NULL,\n            data CLOB NOT NULL,\n            timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n            size NUMBER,\n            checksum VARCHAR2(64)\n          )';\n        EXCEPTION\n          WHEN OTHERS THEN\n            IF SQLCODE != -955 THEN RAISE; END IF;\n        END;\n      ",mariadb:"\n        CREATE TABLE IF NOT EXISTS brolostack_backups (\n          id INT AUTO_INCREMENT PRIMARY KEY,\n          backup_id VARCHAR(100) UNIQUE NOT NULL,\n          data LONGTEXT NOT NULL,\n          timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n          size INT,\n          checksum VARCHAR(64),\n          INDEX idx_timestamp (timestamp),\n          INDEX idx_backup_id (backup_id)\n        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n      "}[this.config.dialect];await this.executeQuery(e)}async ensureStoreTable(){const e={postgresql:"\n        CREATE TABLE IF NOT EXISTS brolostack_stores (\n          id SERIAL PRIMARY KEY,\n          store_name VARCHAR(100) UNIQUE NOT NULL,\n          data JSONB NOT NULL,\n          timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n          checksum VARCHAR(64)\n        );\n        CREATE INDEX IF NOT EXISTS idx_brolostack_stores_store_name ON brolostack_stores(store_name);\n      ",mysql:"\n        CREATE TABLE IF NOT EXISTS brolostack_stores (\n          id INT AUTO_INCREMENT PRIMARY KEY,\n          store_name VARCHAR(100) UNIQUE NOT NULL,\n          data LONGTEXT NOT NULL,\n          timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n          checksum VARCHAR(64),\n          INDEX idx_store_name (store_name)\n        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n      ",sqlite:"\n        CREATE TABLE IF NOT EXISTS brolostack_stores (\n          id INTEGER PRIMARY KEY AUTOINCREMENT,\n          store_name TEXT UNIQUE NOT NULL,\n          data TEXT NOT NULL,\n          timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\n          checksum TEXT\n        );\n        CREATE INDEX IF NOT EXISTS idx_brolostack_stores_store_name ON brolostack_stores(store_name);\n      ",mssql:"\n        IF NOT EXISTS (SELECT * FROM sysobjects WHERE name='brolostack_stores' AND xtype='U')\n        CREATE TABLE brolostack_stores (\n          id INT IDENTITY(1,1) PRIMARY KEY,\n          store_name VARCHAR(100) UNIQUE NOT NULL,\n          data NVARCHAR(MAX) NOT NULL,\n          timestamp DATETIME2 DEFAULT GETUTCDATE(),\n          checksum VARCHAR(64)\n        );\n      ",oracle:"\n        BEGIN\n          EXECUTE IMMEDIATE 'CREATE TABLE brolostack_stores (\n            id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,\n            store_name VARCHAR2(100) UNIQUE NOT NULL,\n            data CLOB NOT NULL,\n            timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n            checksum VARCHAR2(64)\n          )';\n        EXCEPTION\n          WHEN OTHERS THEN\n            IF SQLCODE != -955 THEN RAISE; END IF;\n        END;\n      ",mariadb:"\n        CREATE TABLE IF NOT EXISTS brolostack_stores (\n          id INT AUTO_INCREMENT PRIMARY KEY,\n          store_name VARCHAR(100) UNIQUE NOT NULL,\n          data LONGTEXT NOT NULL,\n          timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n          checksum VARCHAR(64),\n          INDEX idx_store_name (store_name)\n        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n      "}[this.config.dialect];await this.executeQuery(e)}async ensureMigrationTable(){const e=`\n      CREATE TABLE IF NOT EXISTS ${this.config.migrations?.tableName||"schema_migrations"} (\n        version VARCHAR(255) PRIMARY KEY,\n        name VARCHAR(255),\n        executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `;await this.executeQuery(e)}generateChecksum(e){const t=JSON.stringify(e);let r=0;for(let e=0;e<t.length;e++){r=(r<<5)-r+t.charCodeAt(e),r&=r}return r.toString(16)}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this.errorCount,lastError:this.lastError??void 0}}getCapabilities(){return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:!1,maxDataSize:this.getMaxDataSize(),supportedFormats:["json","sql"]}}getMaxDataSize(){return{postgresql:1073741824,mysql:4294967296,sqlite:1073741824,mssql:2147483648,oracle:4e3,mariadb:4294967296}[this.config.dialect]||1048576}}});var st=Object.freeze({__proto__:null,NoSQLAdapter:class extends S{constructor(e){super(),this.name="nosql",this.connected=!1,this.errorCount=0,this.config=e,this.provider=`NoSQL (${e.dialect})`,this.logger=new m(!1,"NoSQLAdapter")}async connect(){try{await this.testConnection(),this.connected=!0,this.emit("connected",{adapter:this.name,dialect:this.config.dialect}),this.logger.info(`Connected to ${this.config.dialect} database`)}catch(e){throw this.errorCount++,this.lastError=e instanceof Error?e.message:"Connection failed",this.emit("error",{error:e,adapter:this.name}),e}}async disconnect(){this.connected=!1,this.emit("disconnected",{adapter:this.name}),this.logger.info(`Disconnected from ${this.config.dialect} database`)}isConnected(){return this.connected}async sync(e){if(!this.connected)throw new Error("NoSQL adapter is not connected");try{const t={data:e,timestamp:new Date,checksum:this.generateChecksum(e),syncType:"full"};await this.executeQuery({collection:"brolostack_sync",operation:"insert",document:t}),await this.cleanOldRecords("brolostack_sync",100),this.lastSync=new Date,this.emit("sync-completed",{data:e,adapter:this.name})}catch(e){throw this.errorCount++,this.lastError=e instanceof Error?e.message:"Sync failed",this.emit("sync-failed",{error:e,adapter:this.name}),e}}async backup(e){if(!this.connected)throw new Error("NoSQL adapter is not connected");try{const t=`backup_${Date.now()}`,r={backupId:t,data:e,timestamp:new Date,size:JSON.stringify(e).length,checksum:this.generateChecksum(e),backupType:"manual"};await this.executeQuery({collection:"brolostack_backups",operation:"insert",document:r}),await this.cleanOldRecords("brolostack_backups",50),this.lastBackup=new Date,this.emit("backup-completed",{data:e,backupId:t,adapter:this.name})}catch(e){throw this.errorCount++,this.lastError=e instanceof Error?e.message:"Backup failed",this.emit("backup-failed",{error:e,adapter:this.name}),e}}async restore(){if(!this.connected)throw new Error("NoSQL adapter is not connected");try{const e=await this.executeQuery({collection:"brolostack_sync",operation:"findOne",options:{sort:{timestamp:-1}}});if(!e)throw new Error("No sync data found");return this.emit("restore-completed",{data:e.data,adapter:this.name}),e.data}catch(e){throw this.errorCount++,this.lastError=e instanceof Error?e.message:"Restore failed",this.emit("restore-failed",{error:e,adapter:this.name}),e}}async syncStore(e,t){if(!this.connected)throw new Error("NoSQL adapter is not connected");try{const r={storeName:e,data:t,timestamp:new Date,checksum:this.generateChecksum(t)};await this.executeQuery({collection:"brolostack_stores",operation:"update",filter:{storeName:e},update:{$set:r},options:{upsert:!0}}),this.emit("store-sync-completed",{storeName:e,data:t,adapter:this.name})}catch(t){throw this.errorCount++,this.lastError=t instanceof Error?t.message:"Store sync failed",this.emit("store-sync-failed",{storeName:e,error:t,adapter:this.name}),t}}async restoreStore(e){if(!this.connected)throw new Error("NoSQL adapter is not connected");try{const t=await this.executeQuery({collection:"brolostack_stores",operation:"findOne",filter:{storeName:e}});return t?(this.emit("store-restore-completed",{storeName:e,data:t.data,adapter:this.name}),t.data):null}catch(t){throw this.errorCount++,this.lastError=t instanceof Error?t.message:"Store restore failed",this.emit("store-restore-failed",{storeName:e,error:t,adapter:this.name}),t}}async executeQuery(e){if(!this.connected)throw new Error("NoSQL adapter is not connected");try{const t=await fetch("/api/nosql/query",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({...e,dialect:this.config.dialect,database:this.config.database,keyspace:this.config.keyspace,index:this.config.index})});if(!t.ok)throw new Error(`NoSQL query failed: ${t.statusText}`);const r=await t.json();return this.emit("query-executed",{query:e,result:r,dialect:this.config.dialect}),r.data||r}catch(e){throw this.logger.error("NoSQL query failed:",e),e}}async findDocuments(e,t={},r){if("mongodb"!==this.config.dialect)throw new Error("findDocuments is only available for MongoDB");return this.executeQuery({collection:e,operation:"find",filter:t,options:r||{}})}async insertDocument(e,t){if("mongodb"!==this.config.dialect)throw new Error("insertDocument is only available for MongoDB");return this.executeQuery({collection:e,operation:"insert",document:t})}async updateDocument(e,t,r,i){if("mongodb"!==this.config.dialect)throw new Error("updateDocument is only available for MongoDB");return this.executeQuery({collection:e,operation:"update",filter:t,update:r,options:i||{}})}async aggregateDocuments(e,t){if("mongodb"!==this.config.dialect)throw new Error("aggregateDocuments is only available for MongoDB");return this.executeQuery({collection:e,operation:"aggregate",pipeline:t})}async searchDocuments(e,t,r){if("elasticsearch"!==this.config.dialect)throw new Error("searchDocuments is only available for Elasticsearch");return this.executeQuery({index:e,operation:"search",searchQuery:t,options:r||{}})}async indexDocument(e,t,r){if("elasticsearch"!==this.config.dialect)throw new Error("indexDocument is only available for Elasticsearch");return this.executeQuery({index:e,operation:"insert",document:{...t,_id:r}})}async putItem(e,t){if("dynamodb"!==this.config.dialect)throw new Error("putItem is only available for DynamoDB");return this.executeQuery({table:e,operation:"insert",document:t})}async getItem(e,t){if("dynamodb"!==this.config.dialect)throw new Error("getItem is only available for DynamoDB");return this.executeQuery({table:e,operation:"findOne",filter:t})}async scanTable(e,t,r){if("dynamodb"!==this.config.dialect)throw new Error("scanTable is only available for DynamoDB");return this.executeQuery({table:e,operation:"find",filter:t||{},options:r||{}})}async executeCQL(e,t){if("cassandra"!==this.config.dialect)throw new Error("executeCQL is only available for Cassandra");const r=await fetch("/api/cassandra/query",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({cql:e,params:t,keyspace:this.config.keyspace})});if(!r.ok)throw new Error(`Cassandra query failed: ${r.statusText}`);return await r.json()}async createIndex(e){try{const t=await fetch("/api/nosql/index/create",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({...e,dialect:this.config.dialect,database:this.config.database})});if(!t.ok)throw new Error(`Index creation failed: ${t.statusText}`);this.emit("index-created",{indexConfig:e,dialect:this.config.dialect})}catch(e){throw this.logger.error("Failed to create index:",e),e}}async dropIndex(e,t){try{const r=await fetch("/api/nosql/index/drop",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({indexName:e,collection:t,dialect:this.config.dialect,database:this.config.database})});if(!r.ok)throw new Error(`Index deletion failed: ${r.statusText}`);this.emit("index-dropped",{indexName:e,collection:t,dialect:this.config.dialect})}catch(e){throw this.logger.error("Failed to drop index:",e),e}}async listIndexes(e){try{const t=await fetch("/api/nosql/index/list",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({collection:e,dialect:this.config.dialect,database:this.config.database})});if(!t.ok)throw new Error(`Index listing failed: ${t.statusText}`);return(await t.json()).indexes||[]}catch(e){throw this.logger.error("Failed to list indexes:",e),e}}async getCollectionStats(e){try{const t=await fetch("/api/nosql/stats",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({collection:e,dialect:this.config.dialect,database:this.config.database})});if(!t.ok)throw new Error(`Stats query failed: ${t.statusText}`);return(await t.json()).stats}catch(e){throw this.logger.error("Failed to get collection stats:",e),e}}async getPerformanceMetrics(){try{const e=await fetch("/api/nosql/metrics",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({dialect:this.config.dialect,database:this.config.database})});if(!e.ok)throw new Error(`Metrics query failed: ${e.statusText}`);return(await e.json()).metrics}catch(e){throw this.logger.error("Failed to get performance metrics:",e),e}}async watchCollection(e,t){if(!["mongodb","couchdb"].includes(this.config.dialect))throw new Error(`Real-time watching is not supported for ${this.config.dialect}`);try{const r=setInterval(async()=>{try{const r=await this.executeQuery({collection:`${e}_changes`,operation:"find",filter:{timestamp:{$gte:new Date(Date.now()-5e3)}},options:{sort:{timestamp:-1}}});r&&r.length>0&&r.forEach(t)}catch(e){this.logger.error("Watch collection error:",e)}},5e3);return this.emit("watch-started",{collection:e,dialect:this.config.dialect}),()=>{clearInterval(r),this.emit("watch-stopped",{collection:e,dialect:this.config.dialect})}}catch(e){throw this.logger.error("Failed to watch collection:",e),e}}async bulkWrite(e,t){try{const r=await fetch("/api/nosql/bulk",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({collection:e,operations:t,dialect:this.config.dialect,database:this.config.database})});if(!r.ok)throw new Error(`Bulk operation failed: ${r.statusText}`);const i=await r.json();return this.emit("bulk-write-completed",{collection:e,operations:t,result:i}),i}catch(r){throw this.emit("bulk-write-failed",{collection:e,operations:t,error:r}),r}}async testConnection(){const e={mongodb:{collection:"test",operation:"findOne",filter:{_id:"connection_test"}},couchdb:{collection:"_all_dbs",operation:"find"},dynamodb:{table:"test",operation:"findOne",filter:{id:"connection_test"}},cassandra:{keyspace:this.config.keyspace||"system",operation:"find"},redis:{collection:"test",operation:"findOne",filter:{key:"connection_test"}},elasticsearch:{index:"_cluster",operation:"search",searchQuery:{query:{match_all:{}},size:1}},neo4j:{operation:"find",filter:{query:"MATCH (n) RETURN n LIMIT 1"}}}[this.config.dialect];e&&await this.executeQuery(e)}async cleanOldRecords(e,t){try{const r=await this.executeQuery({collection:e,operation:"aggregate",pipeline:[{$count:"total"}]}),i=r[0]?.total||0;if(i>t){const r=await this.executeQuery({collection:e,operation:"find",options:{sort:{timestamp:1},limit:i-t,projection:{_id:1}}});if(r.length>0){const t=r.map(e=>e._id);await this.executeQuery({collection:e,operation:"delete",filter:{_id:{$in:t}}})}}}catch(t){this.logger.warn(`Failed to clean old records from ${e}:`,t)}}generateChecksum(e){const t=JSON.stringify(e);let r=0;for(let e=0;e<t.length;e++){r=(r<<5)-r+t.charCodeAt(e),r&=r}return r.toString(16)}getStatus(){return{connected:this.connected,lastSync:this.lastSync||new Date(0),lastBackup:this.lastBackup||new Date(0),errorCount:this.errorCount,lastError:this.lastError??void 0}}getCapabilities(){const e={mongodb:{supportsRealTime:!0,maxDataSize:16777216,supportedFormats:["json","bson"]},couchdb:{supportsRealTime:!0,maxDataSize:4194304,supportedFormats:["json"]},dynamodb:{supportsRealTime:!0,maxDataSize:409600,supportedFormats:["json"]},cassandra:{supportsRealTime:!1,maxDataSize:2097152,supportedFormats:["json"]},redis:{supportsRealTime:!0,maxDataSize:536870912,supportedFormats:["json","string","binary"]},elasticsearch:{supportsRealTime:!1,maxDataSize:104857600,supportedFormats:["json"]},neo4j:{supportsRealTime:!1,maxDataSize:1048576,supportedFormats:["json"]}}[this.config.dialect];return{supportsSync:!0,supportsBackup:!0,supportsRestore:!0,supportsRealTime:e.supportsRealTime,maxDataSize:e.maxDataSize,supportedFormats:e.supportedFormats}}}});class at{constructor(e,t,r){this.isOnline=navigator.onLine,this.config={syncInterval:3e4,conflictResolution:"client-wins",...e},this.eventEmitter=t,this.logger=r,window.addEventListener("online",()=>{this.isOnline=!0,this.logger.info("SyncManager: Back online, resuming sync")}),window.addEventListener("offline",()=>{this.isOnline=!1,this.logger.info("SyncManager: Gone offline, pausing sync")})}enableSync(e,t){this.config.enabled||(this.config.enabled=!0,this.config.serverUrl=e,this.config.apiKey=t,this.logger.info("SyncManager: Synchronization enabled"),this.startSync())}disableSync(){this.config.enabled=!1,this.syncInterval&&(clearInterval(this.syncInterval),this.syncInterval=void 0),this.logger.info("SyncManager: Synchronization disabled")}async syncStore(e,t){if(!this.config.enabled||!this.isOnline)return t;try{return this.logger.info(`SyncManager: Syncing store ${e}`),this.eventEmitter.emit("sync:data-synced",{type:"data-synced",storeName:e,data:t}),t}catch(r){return this.logger.error(`SyncManager: Sync failed for ${e}:`,r),this.eventEmitter.emit("sync:error",{type:"sync-error",storeName:e,error:r}),t}}async exportData(e){return this.logger.info(`SyncManager: Exporting data for ${e}`),JSON.stringify({storeName:e,timestamp:Date.now()})}async importData(e,t){try{return this.logger.info(`SyncManager: Importing data for ${e}`),!0}catch(t){return this.logger.error(`SyncManager: Import failed for ${e}:`,t),!1}}startSync(){this.syncInterval&&clearInterval(this.syncInterval),this.syncInterval=setInterval(()=>{this.config.enabled&&this.isOnline&&this.logger.info("SyncManager: Performing periodic sync")},this.config.syncInterval)}}class nt extends g{constructor(e,t={enabled:!1,autoBackup:!1}){super(e),this.backups=[],this.backupConfig={backupInterval:864e5,maxBackups:10,...t},this.backupConfig.enabled&&this.backupConfig.autoBackup&&this.startAutoBackup()}async createEnhancedBackup(){const e={},t={id:`backup_${Date.now()}`,timestamp:Date.now(),size:JSON.stringify(e).length,storeNames:[],checksum:this.generateChecksum(e)};return this.backups.push(t),this.backups.length>this.backupConfig.maxBackups&&(this.backups=this.backups.slice(-this.backupConfig.maxBackups)),t}async restoreFromBackup(e){if(!this.backups.find(t=>t.id===e))return!1;try{return!0}catch(e){return!1}}async exportData(){return JSON.stringify({},null,2)}async importData(e){try{return JSON.parse(e),!0}catch(e){return!1}}getBackups(){return[...this.backups]}deleteBackup(e){const t=this.backups.findIndex(t=>t.id===e);return-1!==t&&(this.backups.splice(t,1),!0)}startAutoBackup(){setInterval(()=>{this.backupConfig.enabled&&this.backupConfig.autoBackup&&this.createEnhancedBackup()},this.backupConfig.backupInterval)}generateChecksum(e){return btoa(JSON.stringify(e)).slice(0,16)}}class ot extends Fe{constructor(e){super(e),e.sync?.enabled&&(this.sync=new at(e.sync,this.eventEmitter,this.logger)),e.backup?.enabled&&(this.enhancedStorage=new nt({name:e.appName,version:parseInt(e.version)||1,size:e.maxStorageSize||52428800},e.backup))}enableSync(e,t){this.sync?this.sync.enableSync(e,t):this.logger.warn("SyncManager not initialized. Enable sync in config.")}disableSync(){this.sync&&this.sync.disableSync()}async createBackup(){return this.enhancedStorage?await this.enhancedStorage.createEnhancedBackup():(this.logger.warn("Enhanced storage not initialized. Enable backup in config."),null)}async restoreFromBackup(e){return this.enhancedStorage?await this.enhancedStorage.restoreFromBackup(e):(this.logger.warn("Enhanced storage not initialized. Enable backup in config."),!1)}async exportDataAsString(){return this.enhancedStorage?await this.enhancedStorage.exportData():(this.logger.warn("Enhanced storage not initialized. Enable backup in config."),"{}")}async importDataFromString(e){return this.enhancedStorage?await this.enhancedStorage.importData(e):(this.logger.warn("Enhanced storage not initialized. Enable backup in config."),!1)}getBackups(){return this.enhancedStorage?this.enhancedStorage.getBackups():[]}createStore(e,t){const r=super.createStore(e,t);if(this.sync){const t=r.setState;r.setState=i=>{t.call(r,i),this.sync&&this.sync.syncStore(e,r.getState())}}return r}}class ct{constructor(e,t,r,i){this.enabled=!1,this.config=e,this.adapters=t,this.eventEmitter=r,this.logger=i,e.autoSync&&e.syncInterval&&this.startAutoSync()}enable(){this.enabled=!0,this.logger.info("Cloud sync enabled"),this.eventEmitter.emit("cloud-sync:enabled",{type:"sync-started",timestamp:new Date})}disable(){this.enabled=!1,this.syncInterval&&(clearInterval(this.syncInterval),this.syncInterval=void 0),this.logger.info("Cloud sync disabled"),this.eventEmitter.emit("cloud-sync:disabled",{type:"sync-completed",timestamp:new Date})}isEnabled(){return this.enabled}async syncStore(e,t){if(this.enabled){this.logger.info(`Syncing store ${e} to cloud`);try{this.eventEmitter.emit("cloud-sync:store-sync-started",{type:"sync-started",storeName:e,timestamp:new Date});const r=Array.from(this.adapters.values()).map(r=>r.syncStore(e,t).catch(t=>{throw this.logger.error(`Failed to sync store ${e} to ${r.provider}:`,t),t}));await Promise.allSettled(r),this.eventEmitter.emit("cloud-sync:store-sync-completed",{type:"sync-completed",storeName:e,timestamp:new Date}),this.logger.info(`Store ${e} synced to cloud successfully`)}catch(t){throw this.logger.error(`Failed to sync store ${e} to cloud:`,t),this.eventEmitter.emit("cloud-sync:store-sync-failed",{type:"sync-failed",storeName:e,error:t,timestamp:new Date}),t}}else this.logger.warn("Cloud sync is disabled")}async restoreStore(e){if(!this.enabled)return this.logger.warn("Cloud sync is disabled"),null;this.logger.info(`Restoring store ${e} from cloud`);try{for(const t of this.adapters.values())try{const r=await t.restoreStore(e);if(r)return this.logger.info(`Store ${e} restored from ${t.provider}`),r}catch(r){this.logger.warn(`Failed to restore store ${e} from ${t.provider}:`,r)}return this.logger.warn(`No data found for store ${e} in any cloud adapter`),null}catch(t){throw this.logger.error(`Failed to restore store ${e} from cloud:`,t),t}}async syncAllStores(){if(this.enabled){this.logger.info("Syncing all stores to cloud");try{this.eventEmitter.emit("cloud-sync:all-sync-started",{type:"sync-started",timestamp:new Date}),this.eventEmitter.emit("cloud-sync:request-all-stores",{timestamp:new Date}),this.eventEmitter.emit("cloud-sync:all-sync-completed",{type:"sync-completed",timestamp:new Date}),this.logger.info("All stores synced to cloud successfully")}catch(e){throw this.logger.error("Failed to sync all stores to cloud:",e),this.eventEmitter.emit("cloud-sync:all-sync-failed",{type:"sync-failed",error:e,timestamp:new Date}),e}}else this.logger.warn("Cloud sync is disabled")}async restoreAllStores(){if(this.enabled){this.logger.info("Restoring all stores from cloud");try{this.eventEmitter.emit("cloud-sync:request-restore-all-stores",{timestamp:new Date}),this.logger.info("All stores restored from cloud successfully")}catch(e){throw this.logger.error("Failed to restore all stores from cloud:",e),e}}else this.logger.warn("Cloud sync is disabled")}async createBackup(){if(this.enabled){this.logger.info("Creating cloud backup");try{const e=Array.from(this.adapters.values()).map(e=>e.backup({timestamp:new Date}).catch(t=>{throw this.logger.error(`Failed to create backup with ${e.provider}:`,t),t}));await Promise.allSettled(e),this.logger.info("Cloud backup created successfully")}catch(e){throw this.logger.error("Failed to create cloud backup:",e),e}}else this.logger.warn("Cloud sync is disabled")}async restoreBackup(e){if(this.enabled){this.logger.info(`Restoring from backup ${e}`);try{this.eventEmitter.emit("cloud-sync:restore-backup",{backupId:e,timestamp:new Date}),this.logger.info(`Backup ${e} restored successfully`)}catch(t){throw this.logger.error(`Failed to restore backup ${e}:`,t),t}}else this.logger.warn("Cloud sync is disabled")}async listBackups(){if(!this.enabled)return this.logger.warn("Cloud sync is disabled"),[];this.logger.info("Listing cloud backups");try{return[]}catch(e){throw this.logger.error("Failed to list cloud backups:",e),e}}async resolveConflict(e,t,r){this.logger.info(`Resolving conflict for store ${e}`);try{switch(this.eventEmitter.emit("cloud-sync:conflict-detected",{type:"conflict-detected",storeName:e,data:{local:t,cloud:r},timestamp:new Date}),this.config.conflictResolution){case"client-wins":return this.logger.info(`Conflict resolved: client data wins for store ${e}`),t;case"server-wins":return this.logger.info(`Conflict resolved: server data wins for store ${e}`),r;case"merge":return this.logger.info(`Conflict resolved: merging data for store ${e}`),this.mergeData(t,r);default:return this.logger.warn(`Unknown conflict resolution strategy: ${this.config.conflictResolution}`),t}}catch(t){throw this.logger.error(`Failed to resolve conflict for store ${e}:`,t),t}}mergeData(e,t){return"object"==typeof e&&"object"==typeof t?{...t,...e}:e}startAutoSync(){this.syncInterval&&clearInterval(this.syncInterval),this.syncInterval=setInterval(async()=>{if(this.enabled)try{await this.syncAllStores()}catch(e){this.logger.error("Auto-sync failed:",e)}},this.config.syncInterval),this.logger.info(`Auto-sync started with interval ${this.config.syncInterval}ms`)}stopAutoSync(){this.syncInterval&&(clearInterval(this.syncInterval),this.syncInterval=void 0,this.logger.info("Auto-sync stopped"))}}var lt=Object.freeze({__proto__:null,CloudBrolostack:class extends ot{constructor(e){super(e),this.cloudAdapters=new Map,this.cloudConfig=e.cloud,e.cloud?.enabled&&(this.initializeCloudAdapters(e.cloud),this.cloudSync=new ct(e.cloud,this.cloudAdapters,this.eventEmitter,this.logger))}async initializeCloudAdapters(e){for(const t of e.adapters)if(t.enabled)try{const e=await this.createCloudAdapter(t);this.cloudAdapters.set(t.name,e),await e.connect(t.config),this.logger.info(`Cloud adapter ${t.name} (${t.provider}) initialized successfully`)}catch(e){this.logger.error(`Failed to initialize cloud adapter ${t.name}:`,e)}}async createCloudAdapter(e){switch(e.provider){case"aws":throw new Error("AWS adapter not yet implemented");case"google-cloud":throw new Error("Google Cloud adapter not yet implemented");case"cloudflare":throw new Error("Cloudflare adapter not yet implemented");case"mongodb":throw new Error("MongoDB adapter not yet implemented");case"redis":throw new Error("Redis adapter not yet implemented");case"firebase":throw new Error("Firebase adapter not yet implemented");default:throw new Error(`Unsupported cloud provider: ${e.provider}`)}}enableCloudSync(){if(!this.cloudSync)throw new Error("Cloud sync not available. Ensure cloud configuration is enabled.");this.cloudSync.enable()}disableCloudSync(){this.cloudSync&&this.cloudSync.disable()}async syncToCloud(e){if(!this.cloudSync)throw new Error("Cloud sync not available. Ensure cloud configuration is enabled.");if(e){const t=this.stores.get(e);t&&await this.cloudSync.syncStore(e,t.getState())}else await this.cloudSync.syncAllStores()}async restoreFromCloud(e){if(!this.cloudSync)throw new Error("Cloud sync not available. Ensure cloud configuration is enabled.");if(e){const t=await this.cloudSync.restoreStore(e);if(t){const r=this.stores.get(e);r&&r.setState(t)}}else await this.cloudSync.restoreAllStores()}async backupToCloud(){if(!this.cloudSync)throw new Error("Cloud sync not available. Ensure cloud configuration is enabled.");await this.cloudSync.createBackup()}getCloudAdapter(e){return this.cloudAdapters.get(e)}getCloudAdapters(){return Array.from(this.cloudAdapters.values())}isCloudEnabled(){return!0===this.cloudConfig?.enabled&&this.cloudAdapters.size>0}getCloudStatus(){return{enabled:this.isCloudEnabled(),adapters:Array.from(this.cloudAdapters.values()).map(e=>({name:e.name,provider:e.provider,connected:e.isConnected()})),syncEnabled:this.cloudSync?.isEnabled()||!1}}createStore(e,t){const r=super.createStore(e,t);if(this.cloudSync){const t=r.setState;r.setState=i=>{t(i),this.cloudConfig?.autoSync&&this.cloudSync&&this.cloudSync.syncStore(e,r.getState()).catch(t=>{this.logger.error(`Auto-sync failed for store ${e}:`,t)})}}return r}async disconnectFromCloud(){for(const[e,t]of this.cloudAdapters)try{await t.disconnect(),this.logger.info(`Disconnected from cloud adapter: ${e}`)}catch(t){this.logger.error(`Failed to disconnect from cloud adapter ${e}:`,t)}this.cloudAdapters.clear()}on(e,t){this.eventEmitter.on(e,t)}off(e,t){this.eventEmitter.off(e,t)}emit(e,...t){this.eventEmitter.emit(e,...t)}}});export{Ke as BrolostackProvider,Je as useBrolostack,Ge as useBrolostackAuth,et as useBrolostackCloud,tt as useBrolostackEnterprise,Xe as useBrolostackMRM,Ze as useBrolostackProviders,Ve as useBrolostackRealtime,Ye as useBrolostackSecurity,We as useBrolostackState,Qe as useBrolostackStore};
//# sourceMappingURL=react.esm.js.map
