import t from"localforage";import{nanoid as e}from"nanoid";var s;!function(t){t[t.DEBUG=0]="DEBUG",t[t.INFO=1]="INFO",t[t.WARN=2]="WARN",t[t.ERROR=3]="ERROR"}(s||(s={}));class i{constructor(t=!1,e="Brolostack"){this.level=t?s.DEBUG:s.INFO,this.prefix=e}debug(t,e){this.level<=s.DEBUG&&console.debug(`[${this.prefix}] ${t}`,e||"")}info(t,e){this.level<=s.INFO&&console.info(`[${this.prefix}] ${t}`,e||"")}warn(t,e){this.level<=s.WARN&&console.warn(`[${this.prefix}] ${t}`,e||"")}error(t,e){this.level<=s.ERROR&&console.error(`[${this.prefix}] ${t}`,e||"")}setLevel(t){this.level=t}setPrefix(t){this.prefix=t}}class a{constructor(e){this.isInitialized=!1,this.stats={totalItems:0,totalSize:0,availableSpace:0,usedSpace:0,averageItemSize:0},this.config={storeName:"brolostack",version:1,size:52428800,driver:["localStorageWrapper","indexedDB","webSQLStorage"],...e},this.logger=new i(!1,"LocalStorageAdapter"),this.storage=t.createInstance({name:this.config.name,storeName:this.config.storeName||"brolostack",description:this.config.description||"",version:this.config.version||1,size:this.config.size||52428800,driver:this.config.driver||["localStorageWrapper","indexedDB","webSQLStorage"]})}async initialize(){if(!this.isInitialized)try{await this.storage.setItem("__brolostack_test__","test"),await this.storage.removeItem("__brolostack_test__"),await this.updateStats(),this.isInitialized=!0,this.logger.info("LocalStorageAdapter initialized successfully")}catch(t){throw new Error(`Failed to initialize LocalStorageAdapter: ${t instanceof Error?t.message:"Unknown error"}`)}}async getItem(t){try{const e=await this.storage.getItem(t);return e?e.metadata?.expires&&Date.now()>e.metadata.expires?(await this.removeItem(t),null):e.value:null}catch(e){return this.logger.error(`Failed to get item '${t}'`,e),null}}async setItem(t,e){try{const s={key:t,value:e,timestamp:Date.now(),version:this.config.version||1,metadata:{size:new Blob([e]).size,compressed:!1,encrypted:!1}};await this.storage.setItem(t,s),await this.updateStats()}catch(e){throw this.logger.error(`Failed to set item '${t}'`,e),e}}async removeItem(t){try{await this.storage.removeItem(t),await this.updateStats()}catch(e){throw this.logger.error(`Failed to remove item '${t}'`,e),e}}async clear(){try{await this.storage.clear(),await this.updateStats()}catch(t){throw this.logger.error("Failed to clear storage",t),t}}async keys(){try{return await this.storage.keys()}catch(t){return this.logger.error("Failed to get keys",t),[]}}async length(){try{return await this.storage.length()}catch(t){return this.logger.error("Failed to get length",t),0}}getStats(){return{...this.stats}}getAvailableSpace(){return this.stats.availableSpace}getUsedSpace(){return this.stats.usedSpace}getSize(){return this.stats.totalSize}isAvailable(){return this.isInitialized}async createBackup(){try{const t=await this.keys(),e={};for(const s of t){const t=await this.storage.getItem(s);t&&(e[s]=t)}return{version:this.config.version?.toString()||"1.0.0",timestamp:Date.now(),data:e,metadata:{totalItems:t.length,totalSize:this.stats.totalSize,appName:this.config.name,appVersion:this.config.version?.toString()||"1.0.0"}}}catch(t){throw this.logger.error("Failed to create backup",t),t}}async restoreBackup(t){try{await this.clear();for(const[e,s]of Object.entries(t.data))await this.storage.setItem(e,s);await this.updateStats()}catch(t){throw this.logger.error("Failed to restore backup",t),t}}async getItems(t=0,e=100){try{const s=await this.keys(),i=[];for(let a=t;a<Math.min(t+e,s.length);a++){const t=s[a];if(t){const e=await this.storage.getItem(t);e&&i.push(e)}}return i}catch(t){return this.logger.error("Failed to get items",t),[]}}async searchItems(t){try{const e=(await this.keys()).filter(e=>"string"==typeof t?e.includes(t):t.test(e)),s=[];for(const t of e){const e=await this.storage.getItem(t);e&&s.push(e)}return s}catch(t){return this.logger.error("Failed to search items",t),[]}}async cleanup(){try{const t=await this.keys();let e=0;for(const s of t){const t=await this.storage.getItem(s);t&&t.metadata?.expires&&Date.now()>t.metadata.expires&&(await this.removeItem(s),e++)}return await this.updateStats(),e}catch(t){return this.logger.error("Failed to cleanup expired items",t),0}}async updateStats(){try{const t=await this.keys();let e,s,i=0;for(const a of t){const t=await this.storage.getItem(a);t&&(i+=t.metadata?.size||0,(!e||t.timestamp<e.timestamp)&&(e=t),(!s||t.timestamp>s.timestamp)&&(s=t))}this.stats={totalItems:t.length,totalSize:i,availableSpace:(this.config.size||52428800)-i,usedSpace:i,oldestItem:e,newestItem:s,averageItemSize:t.length>0?i/t.length:0}}catch(t){this.logger.error("Failed to update stats",t)}}}class r{constructor(t){this._storage=t,this.middleware=[],this.router=new o,this.setupDefaultEndpoints()}async get(t){return(await this.request("GET",t,void 0,{})).data}async post(t,e){return(await this.request("POST",t,e,{})).data}async put(t,e){return(await this.request("PUT",t,e,{})).data}async delete(t){return(await this.request("DELETE",t,void 0,{})).data}async patch(t,e){return(await this.request("PATCH",t,e,{})).data}async request(t,e,s,i){const a={method:t,path:e,headers:i?.headers||{},body:s,query:i?.query||{},params:{},timestamp:Date.now()};try{for(const t of this.middleware)if(t.request){const e=await t.request(a);Object.assign(a,e)}let t=await this.router.handle(a);for(const e of this.middleware)e.response&&(t=await e.response(t));return{data:t.data,status:t.status,statusText:t.statusText,headers:t.headers||{},config:a,request:a}}catch(t){let e=t;for(const t of this.middleware)t.error&&(e=await t.error(e));throw e}}registerEndpoint(t){this.router.register(t)}use(t){this.middleware.push(t)}setupDefaultEndpoints(){this.router.register({path:"/storage/:key",method:"GET",handler:async t=>{const e=t.params.key;if(!e)return{data:null,status:400,statusText:"Bad Request"};return{data:await this._storage.getItem(e),status:200,statusText:"OK"}}}),this.router.register({path:"/storage/:key",method:"POST",handler:async t=>{const e=t.params.key;return e?(await this._storage.setItem(e,t.body),{data:{success:!0,key:e},status:201,statusText:"Created"}):{data:null,status:400,statusText:"Bad Request"}}}),this.router.register({path:"/storage/:key",method:"PUT",handler:async t=>{const e=t.params.key;return e?(await this._storage.setItem(e,t.body),{data:{success:!0,key:e},status:200,statusText:"OK"}):{data:null,status:400,statusText:"Bad Request"}}}),this.router.register({path:"/storage/:key",method:"DELETE",handler:async t=>{const e=t.params.key;return e?(await this._storage.removeItem(e),{data:{success:!0,key:e},status:200,statusText:"OK"}):{data:null,status:400,statusText:"Bad Request"}}}),this.router.register({path:"/storage",method:"GET",handler:async t=>{const e=await this._storage.keys(),s={};for(const t of e)s[t]=await this._storage.getItem(t);return{data:s,status:200,statusText:"OK"}}}),this.router.register({path:"/storage/clear",method:"POST",handler:async t=>(await this._storage.clear(),{data:{success:!0},status:200,statusText:"OK"})}),this.router.register({path:"/storage/stats",method:"GET",handler:async t=>({data:{totalItems:await this._storage.length(),keys:await this._storage.keys()},status:200,statusText:"OK"})}),this.router.register({path:"/health",method:"GET",handler:async t=>({data:{status:"healthy",timestamp:Date.now(),storage:{available:!0,totalItems:await this._storage.length()}},status:200,statusText:"OK"})})}}class o{constructor(){this.routes=new Map,this.middleware=[]}register(t){const e=`${t.method}:${t.path}`;this.routes.set(e,t)}unregister(t,e){const s=`${e}:${t}`;this.routes.delete(s)}async handle(t){const e=`${t.method}:${t.path}`,s=this.routes.get(e);if(!s)return{data:{error:"Endpoint not found"},status:404,statusText:"Not Found"};try{for(const e of s.middleware||[])if(e.request){const s=await e.request(t);Object.assign(t,s)}let e=await s.handler(t);for(const t of s.middleware||[])t.response&&(e=await t.response(e));return e}catch(t){return{data:{error:t instanceof Error?t.message:"Internal Server Error"},status:500,statusText:"Internal Server Error"}}}use(t){this.middleware.push(t)}}class n{constructor(t,e){this._storage=t,this.eventEmitter=e,this.agents=new Map,this.multiAgentSystems=new Map,this.isInitialized=!1,this.memory=new c(t)}async initialize(){if(!this.isInitialized)try{"initialize"in this.memory&&"function"==typeof this.memory.initialize&&await this.memory.initialize(),await this.loadAgents(),this.isInitialized=!0,this.eventEmitter.emit("ai:manager:initialized",{timestamp:Date.now()})}catch(t){throw new Error(`Failed to initialize AI Manager: ${t instanceof Error?t.message:"Unknown error"}`)}}createAgent(t){const e=new h(t,this.memory,this.eventEmitter);return this.agents.set(e.id,e),this.saveAgent(e),this.eventEmitter.emit("ai:agent:created",{agentId:e.id,config:t}),e}getAgent(t){return this.agents.get(t)}removeAgent(t){return!!this.agents.get(t)&&(this.agents.delete(t),this._storage.removeItem(`ai_agent_${t}`),this.eventEmitter.emit("ai:agent:removed",{agentId:t}),!0)}getAllAgents(){return Array.from(this.agents.values())}async exportMemory(){return"export"in this.memory&&"function"==typeof this.memory.export&&await this.memory.export()||{}}async importMemory(t){"import"in this.memory&&"function"==typeof this.memory.import&&await this.memory.import(t)}async storeMemory(t,e,s="context",i=.5){const a={value:e,type:s,importance:i,timestamp:Date.now()};await this.memory.store(t,a)}async clearMemory(){this.memory.clear()}getMemoryStats(){return"getStats"in this.memory&&"function"==typeof this.memory.getStats?this.memory.getStats():{totalEntries:0,totalSize:0,averageImportance:0,entriesByType:{}}}async loadAgents(){try{const t=(await this._storage.keys()).filter(t=>t.startsWith("ai_agent_"));for(const e of t){const t=await this._storage.getItem(e);if(t){const e=JSON.parse(t),s=new h(e,this.memory,this.eventEmitter);this.agents.set(s.id,s)}}}catch(t){this.eventEmitter.emit("ai:manager:load-agents-error",{error:t instanceof Error?t.message:"Unknown error",timestamp:Date.now()})}}async saveAgent(t){try{const e={id:t.id,name:t.name,type:t.type,config:t.config,state:t.state};await this._storage.setItem(`ai_agent_${t.id}`,JSON.stringify(e))}catch(e){this.eventEmitter.emit("ai:manager:save-agent-error",{agentId:t.id,error:e instanceof Error?e.message:"Unknown error",timestamp:Date.now()})}}}class h{constructor(t,s,i){this.eventEmitter=i,this.state={isActive:!1,isProcessing:!1,lastActivity:0,totalRequests:0,totalTokens:0,errors:[]},this.id=t.id||e(),this.name=t.name,this.type=t.type,this.config=t,this.memory=s}async execute(t,s){this.state.isProcessing=!0,this.state.lastActivity=Date.now();try{let e;switch(await this.memory.store(`interaction_${Date.now()}`,{prompt:t,context:s,timestamp:Date.now(),agentId:this.id}),this.type){case"llm":e=await this.executeLLM(t,s);break;case"multi-agent":e=await this.executeMultiAgent(t,s);break;case"custom":e=await this.executeCustom(t,s);break;default:throw new Error(`Unknown agent type: ${this.type}`)}return this.state.totalRequests++,this.state.isProcessing=!1,this.eventEmitter.emit("ai:agent:executed",{agentId:this.id,prompt:t,result:e,timestamp:Date.now()}),e}catch(i){throw this.state.isProcessing=!1,this.state.errors.push({id:e(),timestamp:Date.now(),type:"execution",message:i instanceof Error?i.message:"Unknown error",context:{prompt:t,context:s},retryable:!0}),this.eventEmitter.emit("ai:agent:error",{agentId:this.id,error:i,timestamp:Date.now()}),i}}addTool(t){this.config.tools||(this.config.tools=[]),this.config.tools.push(t)}removeTool(t){this.config.tools&&(this.config.tools=this.config.tools.filter(e=>e.function.name!==t))}clearMemory(){this.memory.clear()}getMemoryStats(){return"getStats"in this.memory&&"function"==typeof this.memory.getStats?this.memory.getStats():{totalEntries:0,totalSize:0,averageImportance:0,entriesByType:{}}}async executeLLM(t,e){return{response:`AI Agent "${this.name}" processed: ${t}`,tokens:t.length,timestamp:Date.now()}}async executeMultiAgent(t,e){return{response:`Multi-agent system "${this.name}" processed: ${t}`,agents:[],timestamp:Date.now()}}async executeCustom(t,e){return{response:`Custom agent "${this.name}" processed: ${t}`,timestamp:Date.now()}}}class c{constructor(t){this._storage=t,this.entries=new Map,this.maxSize=1e3,this.strategy="lru"}async initialize(){await this.loadFromStorage()}async store(t,e,s="context",i=.5){const a={id:t,timestamp:Date.now(),type:s,content:e,importance:i,tags:[],metadata:{}};this.entries.set(t,a),this.entries.size>this.maxSize&&await this.cleanup(),await this._storage.setItem(`ai_memory_${t}`,JSON.stringify(a))}async retrieve(t){let e=this.entries.get(t);if(!e){const s=await this._storage.getItem(`ai_memory_${t}`);s&&(e=JSON.parse(s),e&&this.entries.set(t,e))}return e}async search(t,e,s=10){const i=[];for(const a of this.entries.values())if((!e||a.type===e)&&(JSON.stringify(a.content).toLowerCase().includes(t.toLowerCase())&&i.push(a),i.length>=s))break;return i.sort((t,e)=>{const s=t.importance+(Date.now()-t.timestamp)/864e5;return e.importance+(Date.now()-e.timestamp)/864e5-s})}async clear(){this.entries.clear();const t=(await this._storage.keys()).filter(t=>t.startsWith("ai_memory_"));for(const e of t)await this._storage.removeItem(e)}async getAll(){const t={};for(const[e,s]of this.entries)t[e]=s;return t}getStats(){const t=Array.from(this.entries.values()),e=t.reduce((t,e)=>t+JSON.stringify(e).length,0),s=t.length>0?t.reduce((t,e)=>t+e.importance,0)/t.length:0,i={};for(const e of t)i[e.type]=(i[e.type]||0)+1;const a=[...t].sort((t,e)=>t.timestamp-e.timestamp),r=[...t].sort((t,e)=>e.timestamp-t.timestamp);return{totalEntries:t.length,totalSize:e,averageImportance:s,oldestEntry:a[0]||void 0,newestEntry:r[0]||void 0,entriesByType:i}}async cleanup(){const t=Array.from(this.entries.values());let e;switch(this.strategy){case"fifo":case"lru":e=t.sort((t,e)=>t.timestamp-e.timestamp);break;case"importance":e=t.sort((t,e)=>t.importance-e.importance);break;default:e=t}const s=e.slice(0,Math.floor(.1*this.maxSize));for(const t of s)this.entries.delete(t.id),await this._storage.removeItem(`ai_memory_${t.id}`)}async loadFromStorage(){try{const t=(await this._storage.keys()).filter(t=>t.startsWith("ai_memory_"));for(const e of t){const t=await this._storage.getItem(e);if(t){const e=JSON.parse(t);this.entries.set(e.id,e)}}}catch(t){}}async export(){const t={};for(const[e,s]of this.entries)t[e]=s;return t}async import(t){for(const[e,s]of Object.entries(t))this.entries.set(e,s),await this._storage.setItem(`ai_memory_${e}`,JSON.stringify(s))}}class g{constructor(){this.events=new Map}on(t,e){this.events.has(t)||this.events.set(t,new Set),this.events.get(t).add(e)}off(t,e){const s=this.events.get(t);s&&(s.delete(e),0===s.size&&this.events.delete(t))}emit(t,...e){const s=this.events.get(t);s&&s.forEach(t=>{try{t(...e)}catch(t){}})}once(t,e){const s=(...i)=>{e(...i),this.off(t,s)};this.on(t,s)}removeAllListeners(t){t?this.events.delete(t):this.events.clear()}listenerCount(t){return this.events.get(t)?.size||0}eventNames(){return Array.from(this.events.keys())}}class m{constructor(t){this.isInitialized=!1,this.startTime=Date.now(),this.config={storageEngine:"localStorage",encryption:!1,compression:!1,maxStorageSize:100,debug:!1,...t},this.logger=new i(this.config.debug),this.eventEmitter=new g,this.stores=new Map,this.storage=new a({name:this.config.appName,version:parseInt(this.config.version)||1,size:this.config.maxStorageSize||52428800}),this.api=new r(this.storage),this.aiManager=new n(this.storage,this.eventEmitter),this.ai={agents:this.aiManager.agents,createAgent:t=>this.aiManager.createAgent(t),getAgent:t=>this.aiManager.getAgent(t),removeAgent:t=>this.aiManager.removeAgent(t),runAgent:async(t,e)=>{const s=this.aiManager.getAgent(t);if(!s)throw new Error(`Agent ${t} not found`);return await s.execute(e)},getMemory:async()=>await this.aiManager.exportMemory(),storeMemory:async(t,e,s,i)=>await this.aiManager.storeMemory(t,e,s,i),clearMemory:async()=>await this.aiManager.clearMemory(),getMemoryStats:()=>this.aiManager.getMemoryStats()},this.logger.info("Brolostack initialized",{appName:this.config.appName,version:this.config.version})}async initialize(){if(this.isInitialized)this.logger.warn("Brolostack already initialized");else try{"initialize"in this.storage&&"function"==typeof this.storage.initialize&&await this.storage.initialize(),await this.aiManager.initialize(),this.eventEmitter.emit("initialized",{appName:this.config.appName,version:this.config.version}),this.isInitialized=!0,this.logger.info("Brolostack initialization completed")}catch(t){const e={name:"BrolostackInitializationError",message:`Failed to initialize Brolostack: ${t instanceof Error?t.message:"Unknown error"}`,code:"INITIALIZATION_FAILED",context:{config:this.config},timestamp:Date.now()};throw this.logger.error("Brolostack initialization failed",e),e}}createStore(t,e){if(this.stores.has(t))return this.logger.warn(`Store '${t}' already exists, returning existing store`),this.stores.get(t);const s=new l(t,e,this.storage,this.eventEmitter);return this.stores.set(t,s),this.logger.info(`Store '${t}' created`,{initialState:e}),this.eventEmitter.emit("store:created",{name:t,initialState:e}),s}getStore(t){return this.stores.get(t)}removeStore(t){const e=this.stores.get(t);return!!e&&(e.clear(),this.stores.delete(t),this.logger.info(`Store '${t}' removed`),this.eventEmitter.emit("store:removed",{name:t}),!0)}getStoreNames(){return Array.from(this.stores.keys())}clearAllStores(){this.stores.forEach((t,e)=>{t.clear(),this.logger.info(`Store '${e}' cleared`)}),this.eventEmitter.emit("stores:cleared",{count:this.stores.size})}async exportData(){const t={};for(const[e,s]of this.stores)t[e]=s.getState();return t._aiMemory=await this.aiManager.exportMemory(),t._metadata={appName:this.config.appName,version:this.config.version,exportDate:(new Date).toISOString(),storeCount:this.stores.size,aiAgentCount:this.ai.agents.size},this.logger.info("Data exported",{storeCount:this.stores.size,aiAgentCount:this.ai.agents.size}),this.eventEmitter.emit("data:exported",{storeCount:this.stores.size,aiAgentCount:this.ai.agents.size}),t}async importData(t){try{for(const[e,s]of Object.entries(t)){if(e.startsWith("_"))continue;let t=this.stores.get(e);t?t.setState(s):t=this.createStore(e,s)}t._aiMemory&&await this.aiManager.importMemory(t._aiMemory),this.logger.info("Data imported successfully",{storeCount:Object.keys(t).filter(t=>!t.startsWith("_")).length}),this.eventEmitter.emit("data:imported",{storeCount:Object.keys(t).filter(t=>!t.startsWith("_")).length})}catch(t){throw this.logger.error("Data import failed:",t),t}}getStats(){return{stores:this.stores.size,aiAgents:this.ai.agents.size,storageSize:"getSize"in this.storage&&"function"==typeof this.storage.getSize?this.storage.getSize():0,uptime:Date.now()-this.startTime,version:this.config.version}}persist(t){this.stores.forEach((e,s)=>{"persist"in e&&"function"==typeof e.persist&&e.persist(t)}),this.logger.info("All stores persisted"),this.eventEmitter.emit("stores:persisted",{count:this.stores.size})}destroy(){this.logger.info("Destroying Brolostack instance"),this.clearAllStores(),this.ai.clearMemory(),this.eventEmitter.emit("destroyed",{appName:this.config.appName,version:this.config.version}),this.isInitialized=!1,this.logger.info("Brolostack instance destroyed")}getEventEmitter(){return this.eventEmitter}getLogger(){return this.logger}}class l{constructor(t,e,s,i){this.name=t,this.storage=s,this.eventEmitter=i,this.listeners=new Set,this.isPersisted=!1,this.persistConfig=null,this.state=e}getState(){return this.state}setState(t){const e=this.state;this.state={...this.state,...t},this.listeners.forEach(t=>t(this.state)),this.eventEmitter.emit("store:updated",{name:this.name,oldState:e,newState:this.state}),this.isPersisted&&this.saveToStorage()}subscribe(t){return this.listeners.add(t),()=>{this.listeners.delete(t)}}persist(t){this.persistConfig=t,this.isPersisted=!0,this.saveToStorage()}async saveToStorage(){try{await this.storage.setItem(`store:${this.name}`,JSON.stringify({state:this.state,config:this.persistConfig,timestamp:Date.now()}))}catch(t){this.logger.error(`Failed to persist store '${this.name}'`,t)}}async loadFromStorage(){try{const t=await this.storage.getItem(`store:${this.name}`);if(t&&"string"==typeof t){const e=JSON.parse(t);e&&"object"==typeof e&&"state"in e&&(this.state=e.state,this.persistConfig=e.config,this.isPersisted=!0)}}catch(t){this.logger.error(`Failed to load store '${this.name}'`,t)}}clear(){this.state={},this.listeners.clear(),this.isPersisted=!1,this.persistConfig=null,this.storage.removeItem(`store:${this.name}`),this.eventEmitter.emit("store:cleared",{name:this.name})}reset(){this.state={},this.listeners.clear(),this.isPersisted=!1,this.persistConfig=null,this.storage.removeItem(`store:${this.name}`),this.eventEmitter.emit("store:reset",{name:this.name})}}export{m as SimpleBrolostack,m as default};
//# sourceMappingURL=index.esm.js.map
